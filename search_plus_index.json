{"./":{"url":"./","title":"简介","keywords":"","body":"​ Hi，阅读者。欢迎来到我的笔记书，这里整理着我在前端学习过程中学习的笔记、知识。 ​ 希望所有来学习的朋友都能学有所成，万事胜意！:sparkles: 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/nodejs笔记总结.html":{"url":"js/nodejs笔记总结.html","title":"nodejs笔记总结","keywords":"","body":"nodejs笔记 本笔记根据河北师范大学软件学院王顶老师授课内容及网络资料编写，如果侵权，联系删除~ 如有错误欢迎联系更正~ nodejs简介，及常见名词解释 （此处的简介可以在后面文章中遇到疑问再返回此处查看） nodejs是什么 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。 Node 是一个让 JavaScript 运行在服务端的开发平台。 实质是对Chrome V8引擎进行了封装，使用C++实现。 node主要特征 1、单线程 在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。 Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。坏处，就是一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。 2、异步I/O 例如，当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。 由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。 当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。 阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。 3、事件驱动 在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。 Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。 运行 node.js 脚本文件时要省略 node 命令，如何操作 在脚本代码前面加入#!/usr/bin/node，并对脚本文件增加可执行权限 增加 linux 文件的可执行权限 chmod u+x file-name node的单线程 在开启电脑后，会运行浏览器，微信，视频等软件，然而cpu数量很少，所以使用的时并发的方式，即cpu给不同的进程分配时间片。打开视频，不仅可以有画面，还有音频播放等等，其实是这些进程内的线程在起作用。 一个进程至少要有一个线程。 node和浏览器中的JavaScript都是单线程的。 但是，我们要理解node的单线程到底是什么意思？实际上， 这里所说的单线程是指我们所编写的代码运行在单线程上，实际上node不是真正的单线程。比如我们执行 node app.js 时启动了一个进程，但是这个进程并不是只有一个线程，而是同时创建了很多歌线程（比如：异步IO需要的一些IO线程）。 但是，仍然只有一个线程会运行我们编写的代码。 这就是node中单线程的含义。 但是node单线程会导致下面的问题： 无法利用多核CPU（只能获得一个CPU的时间分片）。 错误就会引起整个应用退出（整个应用就一个进程，挂了就挂了）。 大量计算长时间占用CPU，导致阻塞线程内的其他操作（异步IO发不出调用，已完成的异步IO回调不能及时执行）。 http请求协议 http介绍 根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。 http请求头 起始行：HTTP请求方法 URL HTTP版本 请求头：请求头的形式通过一个键值对进行渲染 请求体：get方法的请求体是没有内容的（放在了url里） post方法的请求体包含请求的内容 /*起始行*/ GET /sample.jsp HTTP/1.1 /*请求头*/ Accept:image/gif.image/jpeg,*/* Accept-Language:zh-cn Connection:Keep-Alive Host:localhost User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) Accept-Encoding:gzip,deflate /*请求体*/ username=jinqiao&password=123412345678 http响应头 起始行：HTTP协议版本 响应状态码 响应状态信息 响应头(Response Header) ：通过键值对的形式进行表示 响应体： 网页代码 HTML、CSS、JS代码文件 HTTP/1.1 200 OK Server:Apache Tomcat/5.0.12 Date:Mon,6Oct2003 13:23:42 GMT Content-Length:112 HTTP响应示例 Hello HTTP! http应答码 HTTP应答码也称为状态码，它反映了Web服务器处理HTTP请求状态。HTTP应答码由3位数字构成，其中首位数字定义了应答码的类型： 1XX－信息类(Information),表示收到Web浏览器请求，正在进一步的处理中 2XX－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK 3XX - 重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。 4XX - 客户端错误(Client Error)，表示客户端提交的请求有错误 例如：404 NOT Found，意味着请求中所引用的文档不存在。 5XX - 服务器错误(Server Error)表示服务器不能完成对请求的处理：如 500 curl测试http协议 curl http://sample.wangding.in/web/one-div.html 显示出响应体 curl http://sample.wangding.in/web/one-div.html -v 显示所有响应内容、请求内容 跨域问题及代理 浏览器由于同源策略的原因，不同域名之间发送ajax请求，响应的数据不会被浏览器加载。而服务器向服务器发送请求则没有同源策略的限制 解决跨域问题的方法 1、jsonp 2、cors 3、配置代理服务器。 常用模块 见此博客 nodejs基础&全局api 全局api注意点 1.不需要require引入，可以直接使用 路径变量 __filename：展示当前的文件名称，从主目录开始的绝对路径 __dirname：展示当前文件所在的文件目录的名称，从主目录开始的绝对路径 //写在app.js文件中 console.log(__dirname);//C:\\学习\\大三\\nodejs\\nodejsTest console.log(__filename);//C:\\学习\\大三\\nodejs\\nodejsTest\\app.js 控制台变量 方法 描述 console.log() 向标准输出流打印字符并以换行符结束 console.info() 向标准输出流打印信息性消息。输出文字外，会显示一个蓝色的惊叹号。 console.warn() 向标准输出流打印警告性消息。输出文字外，会显示一个黄色的惊叹号。 console.error() 向标准输出流打印错误性消息。输出文字外，会显示一个红色的叉子。 console.time() 可通过此方法对方法进行时间采样 输出变量的三种方式 const user = { name:\"xiaweixuan\", age:21, qq:\"1977541709\" }; //method1 log(\"name: %s\",user.name); // string类型 log(\"age: %d\",user.age); // number类型 log(\"user: %j\",user);// json字符串 //method2 log(\"qq: \" + user.qq);// 字符串拼接 通过+进行连接 //method3 log(`qq: ${user.qq}`); console.time时间采样 function longTask(){ var n = 0; for(var i = 0;i进程对象 属性或方法 描述 process.arch CPU 架构信息 process.platform 操作系统版本信息 process.pid 打印进程 id 信息。 process.execPath Node.js 可执行文件的绝对路径信息 process.stdin.pause() 在脚本中让程序暂停执行 process.version nodejs版本信息 process.getuid() 当前用户id process.getgid() 当前用户组id process.cwd() 当前脚本路径信息 process.memoryUsage().rss 系统的常驻内存大小 process.memoryUsage().heapTotal v8动态分配的总内存大小 process.memoryUsage().heapUsed v8动态分配的已用内存大小 process.memoryUsage().external 查看 v8 管理的绑定到 JS 对象上的 C++ 对象的内存 process.env 查看环境变量 process.argv 是一个字符串数组 头两个字符串 第一个字符串是node 第二个参数是运行的脚本的绝对路径，之后为命令行参数 process.exit(n) 设置退出码 process.stdin.on() 用于标准输入输出流 process.on() 用于自定义接受信号 process.kill(pid,sig); 结束指定进程 退出码 退出码实质上是给程序看的，在Linux程序中，有时候子进程会输出退出码，父进程通过查看子进程输出的退出码来判断是否正确 在退出码中，0表示的是成功，1表示的是错误 var code = process.argv[2]; if(typeof code === 'number'){ console.log(\"命令行参数类型不符合！\"); process.exit(1); } if(process.argv.length 标准输入输出流 读取用户键盘输入信息，保存到对象中 用户键盘输入结束后，打印完整的对象信息 #!/usr/bin/node const msg = ['name','email','qq','mobile']; var i = 0, me = {}; console.log(msg[i] + ':'); process.stdin.on('data',(data)=>{ me[msg[i]] = data.slice(0,data.length-1).toString('utf-8');// slice 是将回车进行去掉 i++; if(i == msg.length){ console.log(me); process.exit(); } console.log(msg[i] + ':'); }); 自定义接受信号 第一个参数为监听的时间名字，后面为回调函数 接收信号量，并对信号（SIGINT 和 SIGTSTP）进行处理 process.stdin.resume(); process.on('SIGINT',()=>{ console.log('you have pressed Ctrl+C'); process.exit(); }) process.on('SIGTSTP',()=>{ console.log('you have pressed Ctrl+Z'); }) 实现my-kill程序 ​```javascript const pid = process.argv[2]; const sig = process.argv[3]; process.kill(pid,sig); 定时器 setTimeout（func(),0）setImmediate(func())代表主线程完成后立即执行，其执行结果是不确定的，可能是setTimeout回调函数执行结果在前，也可能是setImmediate回调函数执行结果在前，但setTimeout回调函数执行结果在前的概率更大些，这是因为他们采用的观察者不同，setTimeout采用的是类似IO观察者，setImmediate采用的是check观察者，而process.nextTick()采用的是idle观察者。 buffer 什么是buffer 数据在计算机中是以二进制存储的，不论是图片、视频哪怕只是简单的字符串都是要先转化为二进制数字去存储的，而具体的转化方式就叫做编码。如将字符转化为二进制，用多少位数字来表示一个字符，这就叫做==字符编码==。 在编程中，我们常常会需要将一系列二进制数据从一处传到另一处，我们传输数据往往是为了处理它，或者读它，或者基于这些数据做处理等。而且每次处理量是固定的，例如我可能一次就要处理1000个二进制数据。 但是，在每次传输过程中，有一个数据量的问题。因此当数据到达的时间比数据理出的时间快的时候，这个时候我们处理数据就需要等待了。 如果处理数据的时间比到达的时间快，这一时刻仅仅到达了一小部分数据，那这小部分数据需要等待剩下的数据填满，凑够了1000个二进制数据，然后再送过去统一处理。这个”等待区域”就是buffer。它是你电脑上的一个很小的物理地址，一般在RAM中，在这里数据暂时的存储、等待，最后在流(stream)中，发送过去并处理。 buffer虽然作为缓冲区，在stream中，Node.js会自动帮你创建buffer之外，你可以创建自己的buffer并操作它。 //buffer基本操作 var buf1 = new Buffer(256);//实例化一个 buffer 对象 buf1，缓冲区的大小是 256 字节 console.log(buf1)// console.log(buf1.length)//256 var buf2 = buf1.slice(246,257);//对 buf1 做切片操作，取出后 10 个字节，存放到 buf2 中 buf1.fill(1)// var arr = ['a',0xBA,0xDF,0x00,0x00,255,10]; var buf3 = new Buffer(arr,'utf-8'); buf2.copy(buf3);//复制buf3的内容到buf2中 字符串的编码有字符编码如ASCII，而文件编码在计算机中，有两种方式，一种方式是通过文本文件进行编码（例如：utf-8 ascii utf16le），另一种方式是通过二进制文件进行编码的（例如：base64 lantin1(二进制) hex） 对编码的理解：不论是字符串还是图片、音频等，在计算机中都是以二进制的形式去存储，不同的编码不过是把二进制翻译成字符串的规则不同而已。比如有的编码是8个二进制数表示一个字符，有的是16个二进制数表示一个字符。也即是说同样是存储‘abc’这个字符串，各种编码把他们转化成的二进制不相同，所以在解析二进制代码的时候，也一定要用相对应的编码方式去解码。此外，本文文件编码多指对字符串、文件的编码，二进制文本编码多指对图片、音频的编码。 在buffer的原型中存在着对应的编码的方法 //buffer编码 var str = 'xiaweixuan'; var buf = new Buffer(str); console.log(buf.toString('base64'));//eGlhd2VpeHVhbg== //buffer解码 var str = 'eGlhd2VpeHVhbg=='; var buf = new Buffer(str,\"base64\"); console.log(buf.toString('utf-8'));//xiaweixuan 模块管理 JS 模块化的两种方案分别是：AMD 和 CommonJS AMD 规范的主要内容：AMD是异步模块加载机制。从它的规范描述页面看，AMD很短也很简单，但它却完整描述了模块的定义，依赖关系，引用关系以及加载机制。define和require这两个定义模块、调用模块的方法,合称为AMD模式 CommonJS规范的主要内容：模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。 将模块发布到npm 1、npm init //初始化环境 2、npm login 3、npm publish npm init后 产生 package.json文件，记录当前环境配置。其中需要注意\"devDependencies\" 和\"dependencies\" ，其中前者是开发时以来的npm模块，后者是自己所写的打包成的应用程序所需要的npm模块 上传git时注意 创建.gitignore文件书写，里面指定的文件不会上传到git上 /node_modules 此外在模块中，使用module.exports = circle导出，通过var circle = require('./02-export-function')导入 使用全局对象 global // 03-global.js global.pi = Math.PI; global.circle = (radius)=>{ return { circumference:function(){return 2*Math.PI*radius;}, area:function(){return Math.PI*radius*radius;} } } global.circleobj = { circumference:function(radius){return 2*Math.PI.radius}, area:function(radius){return Math.PI*radius*radius} } // 03-main.js require('./03-global.js'); console.log(global.pi); console.log(global.circle(20).circumference()); console.log(global.circleobj.area(20)); 事件 Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。 events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。可以通过require(\"events\");来访问该模块。 // 引入 events 模块 var events = require('events').EventEmitter; // 创建 eventEmitter 对象 var eventEmitter = new events(); 方法 描述 evt.on() 监听事件 evt.emit() 发出事件 var EventEmitter = require('events').EventEmitter; var evt = new EventEmitter(); evt.on('hello',()=>{ console.log('hello'); }); /*一个事件可以有多个执行函数（订阅者）*/ evt.on('hello',()=>{ console.log('HELLO'); }) evt.on('bye',()=>{ console.log('bye'); process.exit(); }); global.setInterval(()=>{ evt.emit('hello'); },500);// 在触发hello事件的时候，有两个执行的函数，两个执行的函数会依次执行 global.setTimeout(()=>{ evt.emit('bye'); },3000); 继承EventEmitter对象 1、在构造函数中EventEmitter.bind(this) 2、ClassName.prototype = EventEmitter.prototype 之后ClassName实例出来的对象便继承了on方法 利用util设置继承 util = new require('util'); util.inherits(ClassName,EventEmitter); 流 什么是流 比如说我们将水从一个杯子倒入另一个杯子中，相当于水的位置发生了改变，即从一个杯子到了另一个杯子中，这实质上是每个水分子一个一个发生了位移中，而我们通常把流动着的水成为水流。 同理，数据在计算中，如果想从内存的一处移动到另一处，我们可以想成是每个字符在移动，这便成为字符流 此外，流是一种机制，我们不能说流有哪些方法，我们要理解为很多方法的实现基于流 标准输入流 敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，这就是标准输入流（stdin）。 标准输出流 如果应用程序把字符一个一个输出到显示器上，这就是标准输出流（stdout）。 为什么需要流？ 在node中读取文件的方式有来两种，一个是利用fs模块，一个是利用流来读取。如果读取小文件，我们可以使用fs读取，fs读取文件的时候，是将文件一次性读取到本地内存。而如果读取一个大文件，一次性读取会占用大量内存，效率很低，这个时候需要用流来读取。流是将数据分割段，一段一段的读取，效率很高。 process中基于流的方法 描述 process.stdin.on() 监听数据流 process.stdout.write() 写入输出流 //将输入的字符串转换为大写输出 process.stdin.resume(); process.stdin.setEncoding('utf-8'); process.stdin.on('data',(data)=>{ process.stdout.write(data.toUpperCase()); }); process.stdin.on('end',()=>{ process.exit(); }) fs中基于流的方法 描述 fs.redFileSync(file).pipe(res) 将文件数据写入输出流 //基于res.end的静态服务文件 const http = require('http'), path = require('path'), fs = require('fs'); http.createServer((req,res)=>{ // console.log(req); // console.log(req.headers); 显示头 // console.log(req.url); 显示请求的url地址 var file = path.join(__dirname,req.url); try{ res.end(fs.readFileSync(file).toString('utf-8')); }catch(err){ res.end(err.message); } }).listen(8080); //基于流的静态服务文件 const http = require('http'), path = require('path'), fs = require('fs'); http.createServer((req,res)=>{ var file = path.join(__dirname,req.url); fs.readFileSync(file).pipe(res);// 对于流来说 是异步的 是不能使用try catch的 }) 流的分类 Readable Stream :可读数据流， 数据的产生者，譬如 process.stdin Writeable Stream ：可写数据流， 数据的消费者，譬如 process.stdout 或者 process.stderr Duplex Stream ：双向数据流，可以同时读和写 Transform Stream： 转换数据流，可读可写， 数据的转化者 对流的理解 stream对象让我们可以直接生成流。 Stream 本身提供了一套接口规范，很多 Node.js 中的内建模块都遵循了该规范，譬如著名的 fs模块，即是使用 Stream 接口来进行文件读写；同样的，每个 HTTP 请求是可读流，而 HTTP 响应则是可写流。 可读流 可读流有两种模式：flowing和paused 在流动模式下，可读流自动从系统底层读取数据，并通过EventEmitter接口的事件尽快将数据提供给应用。 在暂停模式下，必须显示调用stream.read()方法来从流中读取数据片段。 当我们创建某个可读流时，其还并未开始进行数据流动；添加了 data 的事件监听器，它才会变成流动态的。在这之后，它就会读取一小块数据，然后传到我们的回调函数里面。 data 事件的触发频次同样是由实现者决定，譬如在进行文件读取时，可能每行都会触发一次；而在 HTTP 请求处理时，可能数 KB 的数据才会触发一次。 const stream = require('stream'); const fs = require('fs'); const readableStream = fs.createReadStream(process.argv[2], { encoding: 'utf8' }); // 手动设置流数据编码 // readableStream.setEncoding('utf8'); let wordCount = 0; readableStream.on('data', function(data) { wordCount += data.split(/\\s{1,}/).length; }); readableStream.on('end', function(){ // Don't count the end of the file. console.log('%d %s', --wordCount, process.argv[2]); }); Readable Stream 还包括如下常用的方法： 可读流名字 描述 Readable.resume() 这个方法会暂停流的流动。换句话说就是它不会再触发 data 事件。 Readable.pause() 这个方法和上面的相反，会让暂停流恢复流动。 Readable.unpipe() 这个方法会把目的地移除。如果有参数传入，它会让可读流停止流向某个特定的目的地，否则，它会移除所有目的地。 当然我们也可以直接为他制定一个输出流让其输出（例如下面的可读流） //可读流 const Readable = require('stream').Readable; var src = new Readable(); src.push('Hello'); src.push('World'); src.push(null); // 代表推送结束 src.pipe(process.stdout); //pipe方法指定输出位置 此处指定流到process的输出流 // process.stdout是一个指向标准输出流(stdout)的 可写的流(Writable Stream) 对于可读流而言，来源可以直接通过push方法向流中加入字符流，去向可以通过指向可写流输出，也可以直接指向process.stdout（本质相同，process.stdout也是一个可写流） 可写流 //可写流 const { Writable } = require('stream'); var a=new Writable({ write(chunk, encoding, callback) { console.log(chunk.toString()); callback(); } }); process.stdin.pipe(a); //process.stdin一个指向 标准输入流(stdin) 的可读流(Readable Stream)，将其指向可写流，这样就可以在用户写完新数据后立刻传入可写流并写出。 //src.pipe(a) 可以直接将刚刚的可读流直接指向可写流写出 通常情况下，可写流是向流中加入内容，而可写流是将内容写出，故可写流有一下几样事件，通过以下事件的监听，而输出东西。 可写流方法 描述 error 在写入或链接发生错误时触发 pipe 当可读流链接到可写流时，这个事件会触发 unpipe 在可读流调用 unpipe 时会触发 对于可写流而言，来源可以是由可读流直接指向的，也可以由输入流指向的，去向则是将数据输出。 文件系统 在linux中，我们常常会使用到很多操控文件或目录的命令，其实在nodejs中也提供了相应的方法。 fs方法分类 从操作方式上进行分类：底层文件操作、高级文件操作、流文件操作 从操作对象上进行分类：文件、目录、链接、属性 从操作的方式上进行分类：同步（同步的方法一般加上sync）和异步 说明：当文件比较大的时候，一般会用异步的方式（流）进行操作，当文件比较小的时候，会用同步的方式进行建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Dp2aVTYR-1573636223460)(https://github.com/fuziwang/node.js/raw/master/nodejs-course/images/21.png)] 处理异常 /* 1. 同步代码 try{ console.log(fs.readFileSync(file).toString('utf-8')); }catch(err){ console.log(err.message,err.name); process.exit(-1); } 2. 异步处理 fs.readFile(file,(err,data)=>{ if(err) { console.log('Sorry,Something Woring!'); process.exit(100); }else{ console.log(data.toString('utf-8')); } }) 3. 事件机制 src.on('error',(err)=>{ console.log(err.message); process.exit(1); }) */ 文件操作 打印文件内容 #!/usr/bin/node //异步 fs.readFile(file) const fs = require('fs'); var file = process.argv[2] || __filename; fs.readFile(file,(err,data)=>{ if(err){ console.log(err.message); process.exit(1); }else{ console.log(data.toString('utf-8')); } }) //同步 fs.readFileSync(file) const fs = require('fs'); var file = process.argv[2] || __filename; try{ console.log(fs.readFileSync(file).toString('utf-8')); }catch(err){ console.log(err.message); process.exit(1); } /*fs.readFileSync(path[, options]) 如果指定了 encoding 选项，则该函数返回一个字符串，否则返回一个 buffer。*/ //使用流 fs.createReadStream(file) const fs = require('fs'); var file = process.argv[2] || __filename; var readStream = fs.createReadStream(file);//这个api的作用是打开一个可读的文件流并且返回一个fs.ReadStream对象 readStream.on('error',(err)=>{console.log(err.message);process.exit(-1);}); readStream.on('open',function(){this.pipe(process.stdout)}); //使用底层方法 const fs = require('fs'); var file = process.argv[2] || __filename; var fid = fs.openSync(file,'r'); var len = fs.statSync(file).size; var buf = new Buffer(len); fs.readSync(fid,buf,0,len); console.log(buf.toString('utf-8')); fs.closeSync(fid) /* 打开文件的操作： fs.open(path, flags[, mode], callback) fs.openSync(path, flags[, mode]) // 异常处理需要使用try catch flags 可以是： r读 w写 a追加 'r' - 以读取模式打开文件。如果文件不存在则发生异常。 'r+' - 以读写模式打开文件。如果文件不存在则发生异常。 'rs+' - 以同步读写模式打开文件。命令操作系统绕过本地文件系统缓存。 mode 可设置文件模式（权限和 sticky 位），但只有当文件被创建时才有效。默认为 0o666，可读写。 获取文件信息操作： fs.stat(path, callback) 获取文件信息 path - 文件路径。callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象 返回读取字节的数量： fs.readSync(fd, buffer, offset, length, position) 返回读取字节的数量 关闭文件的操作： fs.close(fd, callback)：callback ：err 异步的 close(2)。 完成回调只有一个可能的异常参数。 */ //混合打印 const fs = require('fs'); var file = process.arv[2] || __filename; var fd = fs.openSync(file,'r'); fs.writeSync(1,fs.readFileSync(file).toString('utf-8')); fs.closeSync(fd); 复制文件 fs.writeFileSync(dst，src) #!/usr/bin/node const fs = require('fs'); var src = process.argv[2], dst = process.argv[3]; fs.writeFileSync(dst,fs.readFileSync(src)); 移动文件 fs.renameSync(src,dst) #!/usr/bin/node const fs = require('fs'); var src = process.argv[2], dst = process.argv[3]; fs.renameSync(src,dst);// 移动的过程中可以进行重命名 删除文件 fs.unlinkSync（file） #!/usr/bin/node const fs = require('fs'); var file = process.argv[2]; fs.unlinkSync(file);// rm == unlike 创建空文件 fs.appendFileSync(file) #!/usr/bin/node const fs = require('fs'); var file = process.argv[2]; fs.appendFileSync(file);// 或者通过fs.writeFileSync(file,''); 目录操作 查看目录内容 fs.readdirSync(dir) #!/usr/bin/node const fs = require('fs'); var dir = process.argv[2]; console.log(fs.readdirSync(dir));// 返回的是一个数组信息 创建目录 fs.mkdirSync(dir); #!/usr/bin/node const fs = require('fs'); var dir = process.argv[2]; fs.mkdirSync(dir); 删除目录 fs.rmdirSync(dir) #!/usr/bin/node const fs = require('fs'); var dir = process.argv[2]; fs.rmdirSync(dir); 链接操作 创建链接 fs.linkSync(src,lnk) fs.symlinkSync(src,lnk) #!/usr/bin/node const fs = require('fs'); var src = process.argv[2], lnk = process.argv[3]; // 硬链接 fs.linkSync(src,lnk); // 软链接 fs.symlinkSync(src,lnk); 打印链接 fs.readlinkSync(lnk) #!/usr/bin/node const fs = require('fs'); var lnk = process.argv[2]; console.log(fs.readlinkSync(lnk)); 属性操作 修改文件权限 fs.chmodSync(file,mode) #!/usr/bin/node const fs = require('fs'); var file = process.argv[2], mode = process.argv[3]; fs.chmodSync(file,mode); 修改文件所有者 fs.chownSync(file,Number(uid),Number(gid)) #!/usr/bin/node const fs = require('fs'); var file = process.argv[2], uid = process.argv[3], gid = process.argv[4]; fs.chownSync(file,Number(uid),Number(gid)); 文件信息统计 fs.statSync(file) #!/usr/bin/node const fs = require('fs'); var file = process.argv[2]; console.log(fs.statSync(file));// 返回的是一个对象 监视文件变化 #!/usr/bin/node const fs = require('fs'); fs.watch(__filename,(e,r)=>{ console.log(e,r); }) 综合案例：递归删除 要求支持命令行参数，包括：要删除的目录名或文件名 命令行参数不存在的情况下，打印错误信息 命令行参数指定的文件名或者目录名不存在时，打印错误信息 如果命令行参数是合法的文件名，则删除文件 如果命令行参数是合法的目录名，则删除该目录以及该目录下的所有文件以及子目录 #!/usr/bin/node const fs = require('fs'), path = require('path'); var file = process.argv[2]; if(fs.statSync(file).isFile()) fs.unlikeSync(file); if(fs.statSync(file).isDirectory()) deletedir(file); function deletedir(file){ var files = fs.readdirSync(file); for(var i= 0;i 子进程 创建子进程的四种方式exec 、 execFile 、sapwn 、 fork 四种方式的不同 **exec(command, options, callback)** 和 **execFile(file, args, options, callback)** 比较类似，会使用一个 **Buffer** 来存储进程执行后的标准输出结果，他们可以**一次性在callback里面获取到**。**不太适合数据量大的场景。** 　　另外，exec会首先创建一个新的shell进程出来，然后执行command； execFile则是直接将可执行的file创建为新进程执行。 所以，execfile 会比 exec 高效一些（后者多了一个shell步骤，前者是直接拿到execfile就执行了）。 　　exec比较适合来执行 shell 命令， 然后获取输出（比如： exec('ps aux | grep \"node\" ')），但是 execFile 没有这么实用， 因为它实际上只接受了一个可执行的命令，然后执行（没法使用shell里面的管道之类的东西）。 **spawn(command, args, options)适合用在进程的输入、输出数据量比较大的情况（因为它支持steam的方式，而刚才的exec/execFile都是Buffer，而不支持stream的方式）， 可以用于任何命令。** 可以进行管道操作。 **fork(modulePath, args, options)实际上是spawn的一个“特例”， 会创建一个新的V8实例**。新创建的进程只能用来运行node脚本，不能运行其他命令。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0xLDWG8P-1573636223464)(https://github.com/fuziwang/node.js/raw/master/nodejs-course/images/37.png)] 四种方法的用法 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-83x9KpwX-1573636223465)(https://github.com/fuziwang/node.js/raw/master/nodejs-course/images/36.png)] //在app.js中操作child.js文件，以下为app.js中的代码 const cp = require('child_process') //execFile cp.execFile('node',['child.js', 'a', 'b'],(err, out, error)=>{console.log(out)}); //exec cp.exec('node child.js a b',(err, stdout, stderr)=>{console.log(stdout)}) //spawn var cmd=cp.spawn( 'node', // 需要执行的命令 ['child.js', 'a', 'b'], // 传递的参数 ); cmd.stdout.pipe(process.stdout) //frok cp.fork( 'child.js', // 需要执行的脚本路径 ['a', 'b'], // 传递的参数 ); nodejs网络编程 http网络爬虫（模拟客户端） 模拟浏览器去访问服务器并获取到数据 //实例 const http = require('http'), cheerio = require('cheerio'); for(var i = 1;i{ var html = ''; res.on('data',(data)=>{ html +=data; console.log(data.toString(\"utf8\")) }); res.on('end',()=>{ // 沿用JQuery风格，定义$ var $ = cheerio.load(html); $('body').find('div.main').each(function(){ var cName = $(this).find('a').text(), cTime = $(this).find('p.fl').text(), cTarget = $(this).find('div.course_target').text(), cUrl = $(this).find('a').attr('href'); if(cTime === '') return; console.log('课程名称：',cName); console.log('课程时长：',cTime); console.log('课程目标：',cTarget); console.log('课程地址：',cUrl); }); }); }); } //架构 http.get(url,(res)=>{ res.on('data',(data)=>{}) res.on('end',()=>{}) }) 此处用的是http的get()做的请求，在实际情况中发请求的方式有很多，还可以用http的request方法，甚至可以用其他模块，如got模块，request模块。 http前端渲染（前后端分离） //服务器架构 const http = require('http'); http.createServer((req,res)=>{ console.log('HTTP Method:',req.method); switch(req.method){ case 'GET': switch(req.url){ case '/': select1(req,res); break; case '/login': select1(req,res); break; } break; case 'POST': add(req,res); break; case 'PUT': update(req,res); break; case 'DELETE': del(req,res); break; default: res.end('Something Wrong!'); } }).listen(8080); 在前后端分离时，每个方法若有返回，基本为json数据串，此时成为接口。有时也会提供返回html文件的路径。前后端分离是浏览器负责解析、渲染的文件，因为后台服务器无法解析html文件，若果要在服务器解析渲染文件，则需要用后端所提供的渲染模板。 //前端渲染--直接传html文件 function showHomePage(res) { var html = fs.readFileSync('./template.html').toString('utf8'); res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Length': Buffer.byteLength(html), 'Cache-Control': 'public,max-age=600', 'Access-Control-Allow-Origin': '*' }); res.end(html); } res的常用方法 方法名 描述 end() end() 中的内容必须是字符串，否则会报错 write() res.write(chunk[, encoding][, callback])发送一块响应主体，可以多次调用该方法以提供连续的响应主体片段。 writeHead() res.writeHead(200,{\"Content-Type\":\"text/html;charset=UTF-8\"}); statusCode() res.statusCode = 200 setHeader() res.setHeader(\"Content-Type\":\"text/html;charset=UTF-8\")为隐式响应头设置单个响应头的值，如果此响应头已存在于待发送的响应头中，则其值将被替换。 在这里可以使用字符串数组来发送具有相同名称的多个响应头。 res.sendfile（） 向浏览器发送文件 在html中如果引入外部资源，'/' 即表示根目录，如请求与html统计的bg.png可直接在src中写src='/bg.png' http后台模板渲染 常见渲染模板，耗时结果比较 Jade 287ms > ejs 43ms > Handlebars 28ms jade 模板 (express demo) 就看起来干净，引入缩进，丧失了html该有的灵活性 html head title #{title} meta(charset=\"UTF-8\") body div.description #{description} ul - each data in datas li.item(id='item_'+data.index) span= data.time a.art(href=data.url)= data.title handlebars 模版 (express -hbs demo) {{title}} - Page Test {{description}} {{#datas}} {{time}}{{title}} {{/datas}} ejs 模版 (node -e demo) - Page Test \">\" class=\"art\"> 以上为模板的代码，然后再在创建的服务器中将其返回给浏览器 function showpage(req,res){ var html = fs.readFileSync('./template.html'); html = html.replace('%',item.map(function(item){ //yong %tihuan return '' + item + ''; }).join('\\n')); res.end(html); } 后台模板渲染与前后端分离的比较 后端渲染： 页面呈现速度：快，受限于用户的带宽 流量消耗：少一点点（可以省去前端框架部分的代码） 可维护性：差（前后端东西放一起，掐架多年，早就在闹分手啦） seo友好度：好 编码效率：低（这个跟不同的团队不同，可能不对） 前端渲染： 页面呈现速度：主要受限于带宽和客户端机器的好坏，优化的好，可以逐步动态展开内容，感觉上会更快一点。 流量消耗：多一点点（一个前端框架大概50KB）当然，有的用后端渲染的项目前端部分也有在用框架。 度可维护性：好，前后端分离，各施其职，代码一目明了。 SEO友好度：差，大量使用ajax，多数浏览器不能抓取ajax数据。 编码效率：高，前后端各自只做自己擅长的东西，后端最后只输出接口，不用管页面呈现，只要前后端人员能力不错，效率不会低。 http高级编程用法 获取文件 //将上传的文件输出到同级目录下 getFile(){ req.setEncoding('binary'); //设置编码 var file; req.on('data', (data)=>{ file += data; }); req.on('end', ()=>{ log(file.split('\\r\\n')); var buf = file.split('\\r\\n')[4]; var files = file.split('\\r\\n')[1].split(';'); var fileName = qs.parse(files[2].trim())['filename']; fileName = fileName.slice(1, fileName.length-1); fs.writeFileSync(fileName, buf, {'encoding': 'binary'}); }); } //此方法不能用于所有图片，具体split截取的内容要根据图片不同类型或大小做出调整，统一式获取下文中有介绍，此处介绍的为底层方法 图片操作 //上传图片 function writePic(file) { var data = file.split('\\r\\n'); var fileName = qs.parse(data[1].split(';')[2].trim())['filename'], start = data[0].length + data[1].length + data[2].length + data[3].length + 8, end = file.indexOf('------WebKitFormBoundary', start), buf = file.slice(start, end); fileName = fileName.slice(1, fileName.length-1); if(fileName === '') return false; fileName = path.join(__dirname, 'images', fileName); fs.writeFileSync(fileName, buf, {'encoding': 'binary'}); return true; } //向浏览器发送图片 function sendPic(req, res) { var info = req.url.split('/'), pic = path.join(__dirname, req.url), ext = info[2].split('.')[1]; if(info.length !== 3 || !fs.existsSync(pic)) { show(res, errorPage); return; } res.statusCode = 200; res.setHeader('Content-Type', 'image/' + ext); res.setHeader('Content-length', fs.statSync(pic).size); res.end(fs.readFileSync(pic)); } cookie使用 //查看cookie log(req.headers['cookie']); //a=1; b=2 log(req.headers['cookie'].split(';')); //[ 'a=1', ' b=2' ] //设置cookie res.setHeader('Set-cookie', ['name=wangding; Httponly', 'age=42; max-age=1000']); /* *有的网站会默认请求favicon.ico，所以当你用cookie记录增量时会成双倍增加 *此时须添加if(req.url === '/favicon.ico') return; */ 其他一些功能如session辅助登录、服务器代理等功能将在express中介绍，此处将不再使用原生去写。 express框架 使用express框架既可以写后台模板渲染的服务器也可以写前端渲染的服务器。 前端渲染（即使用模板） 使用生成器 $ npm install express-generator -g //全局下载生成器 $ express --view=ejs myapp //创建叫做myapp的项目，使用ejs模板 $ cd myapp //进入项目中 $ npm install //安装全部依赖 $ DEBUG=myapp:* npm start //mac或linux中的打开项目 > set DEBUG=myapp:* & npm start //windows中的打开项目 . ├── app.js ├── bin │ └── www （入口文件） ├── package.json ├── public │ ├── images │ ├── javascripts │ └── stylesheets │ └── style.css ├── routes │ ├── index.js │ └── users.js └── views ├── error.pug ├── index.pug └── layout.pug //此项目为mvc架构，routes为C，views为V，此后手动添加数据存储（文件存储或数据库）作为M。 后端渲染（即提供接口） 通常我们将创建两个服务器，一个提供静态资源，一个提供接口服务 基本路由 (var app = express();) const express = require(\"express\"); const path = require(\"path\"); const bodyParser = require(\"body-parser\"); const data = require(\"./data.json\"); var app = express(); app.use(express.static(path.join(__dirname, 'public'))); //设置静态资源，html中的资源会自动将public当作根目录去查询资源 app.use(bodyParser.json()); //设置post请求的中间件，与下面一行同时使用后app方可使用post()方法 app.use(bodyParser.urlencoded({ extended: false })); //与上一句同时使用设置post请求 app.use('/list/', (req, res, next) => { loginOK = false; for (let i = 0; i { res.type('text/html'); res.status(200); res.sendfile(`${__dirname}/public/login.html`) }) app.post('/list/', (req, res) => { var query = req.body; //post请求的数据存在此处 console.log(req.body); res.type('text/html'); res.status(200); res.sendfile(`${__dirname}/public/list.html`) }) app.get('/listDetil/', (req, res) => { console.log(\"ok\"); res.type('text/html'); res.status(200); res.json(data.chapterList); // res.end(\"neirong\"); }) app.listen(8080); 模块化路由 (var router = express.Router();) //将路由模块化，通过模块引入到app.js //app.js const express = require('express'); const app = express(); const books = require('./router/books.js'); app.get('/', function(req, res) { res.end('hello world'); }); app.use('/books', books); app.listen(8080); //books.js const express = require('express'); const router = express.Router(); router.use(function(req, res, next) { console.log(Date.now()); next(); }); router.get('/', function(req, res) { res.end('books'); }); router.get('/list', function(req, res) { res.end('books-list'); }); module.exports = router; 常用功能 实现代理（解决跨域问题） //当前后端分离的时候，常开启两个服务器，一个提供静态资源，一个提供接口服务。 //当一个服务器开启两个服务的时候，必须打开两个接口（例如3000和5000），拿在3000端口返回的html文件就无法请求到5000端口中的接口，也就是所谓的跨域问题 //在提供静态服务的服务器中（假设静态服务打开的是3000端口），加入一下代码 //使用到的中间件 http-proxy-middleware var proxy=require(\"http-proxy-middleware\"); app.use('/api',proxy({ target:'http://localhost:5000', //要转接到的地址 changeOrigin:false, pathRewrite:{ \"^/api\":\"\" } })) //这样在3000端口的静态资源中请求接口可直接写为src='/api' 图片上传 //使用到中间件 multer let fs = require('fs'); let express = require('express'); let multer = require('multer'); let app = express(); /** * 多文件上传 * 设置文件名 filename() * 设置存储图片路径 destination() * 图片信息 req.files * 其他非图片数据 req.body */ const storage = multer.diskStorage({ destination: function (req, file, cb) { //设置存放位置 cb(null, './datadb/upload-multer/') }, filename(req, file, cb) { //设置文件名字，此处设为时间戳 const filenameArr = file.originalname.split('.'); cb(null, Date.now() + '.' + filenameArr[filenameArr.length - 1]); } }); let uploadMulti = multer({ storage }) //uploadMulti.array中参数第一个为图片名字，第二个参数为上传图片个数 app.post('/upload-multi', uploadMulti.array('logos', 1), (req, res, next) => { var files = req.files; var fileInfos = []; // 获取文件信息 for (let i in files) { var file = files[i]; var fileInfo = {}; fileInfo.mimetype = file.mimetype; fileInfo.originalname = file.originalname; fileInfo.size = file.size; fileInfo.path = file.path; fileInfos.push(fileInfo); } // 设置响应类型及编码 res.set({ 'content-type': 'application/json; charset=utf-8' }); console.log(req.body); res.end(JSON.stringify(fileInfos), 'utf8'); }); /** * http服务 */ app.get('/', (req, res, next) => { let form = ` 多文件上传 上传 ` //此处两个表单name名字相同 res.send(form); }); app.listen(8080); cooike使用 const express = require('express'), cookieParser = require('cookie-parser'), app = express(); app.use(cookieParser()); //设置中间件 app.get('/', (req, res) => { if(typeof req.cookies.login === 'undefined') { //cookie存储在req.cookies中 res.render('login'); } else if(req.cookies.login === 'true') { res.render('index'); } else { res.render('login'); } console.log('cookie:', req.cookies); res.cookie('name', 'wangding', {maxAge: 100000, httpOnly: true});//设置cookie res.cookie('age', 41, {maxAge: 100000}); res.send('OK!'); }); app.listen(8080); session会话 //服务器端生成了一个sessionn-id，客户端使用了cookie保存了session-id这个加密的请求信息，而将用户请求的数据保存在服务器端，但是它也可以实现将用户的数据加密后保存在客户端。 //session记录的是客户端与服务端之间的会话状态，该状态用来确定客户端的身份。可以存放在cookie中，也可以存放在内存中，或者是redis、mongodb等第三方服务器中。session默认存放在内存中，存放在cookie中安全性太低，存放在非redis数据库中查询速度太慢，一般项目开发中都是存放在redis中(缓存数据库)。 //cookie保存session //session信息是不可见的，同时也是不可改的，而且在客户端关闭浏览器后数据消失。 var path = require('path'); var express = require('express'); var session = require('express-session'); var app = express(); app.use(session({ name: 'session-name', // 这里是cookie的name，默认是connect.sid secret: 'my_session_secret', // 建议使用 128 个字符的随机字符串 resave: true, saveUninitialized: false, cookie: { maxAge: 60 * 1000, httpOnly: true } })); app.get('/', function(req, res, next) { if(req.session.isFirst || req.cookies.isFirst) { res.send(\"欢迎再一次访问\"); } else { req.session.isFirst = 1; res.cookie('isFirst', 1, { maxAge: 60 * 1000, singed: true}); res.send(\"欢迎第一次访问。\"); } }); app.listen(3030, function() { console.log('express start on: ' + 3030) }); //数据库保存session //用数据库保存session，我们一般使用redis，因为它是缓存数据库，查询速度相较于非缓存的速度更快。 //使用数据库保存session数据，在浏览器端的session-id会随着浏览器的关闭而消失，下次打开浏览器发送请求时，服务器依然不能识别请求者的身份。 var path = require('path'); var express = require('express'); var redisStore = require('connect-redis')(session); var session = require('express-session'); var app = express(); app.use(session({ name: 'session-name', // 这里是cookie的name，默认是connect.sid secret: 'my_session_secret', // 建议使用 128 个字符的随机字符串 resave: true, saveUninitialized: false, store: new redisStore({ host: '127.0.0.1', port: '6379', db: 0, pass: '', }) })); app.get('/', function(req, res) { if (req.session.isFirst) { res.send(\"欢迎再一次访问。\"); console.log(req.session) } else { req.session.isFirst = 1; res.send(\"欢迎第一次访问。\"); } }); app.listen(3030, function() { console.log('express start on: ' + 3030) }); //cookie和数据库同时保存session var path = require('path'); var express = require('express'); var cookieParser = require('cookie-parser'); var redisStore = require('connect-redis')(session); var session = require('express-session'); var app = express(); app.use(cookieParser()); app.use(session({ name: 'session-name', // 这里是cookie的name，默认是connect.sid secret: 'my_session_secret', // 建议使用 128 个字符的随机字符串 resave: true, saveUninitialized: false, // cookie: { maxAge: 60 * 1000, httpOnly: true }, store: new redisStore({ host: '127.0.0.1', port: '6379', db: 0, pass: '', }) })); app.get('/', function(req, res, next) { if(req.session.isFirst || req.cookies.isFirst) { res.send(\"欢迎再一次访问\"); } else { req.session.isFirst = 1; res.cookie('isFirst', 1, { maxAge: 60 * 1000, singed: true}); res.send(\"欢迎第一次访问。\"); } }); app.listen(3030, function() { console.log('express start on: ' + 3030) }); res方法总结 express封装后res的常用方法 描述 res.end() 快速结束响应，可传数据，但不建议 res.json() 发送json相应 res.sendFile() 在给定的位置传输文件 res.send() 发送http相应可以是buf对象可以是String对象 res.render() 可发送html文件 res.sendStatus() 返回状态码 res.set() 设置请求头 ({ 'content-type': 'application/json; charset=utf-8' }); 数据库编程（以mysql为例） 数据存储的方式一共有三种：内存存储、文件存储、数据库存储 配置mysql 运行配置命令 mysql_secure_installation 配置MySQL支持中文 # 打开my.cnf配置文件进行编辑 sudo vi /etc/my.cnf # 修改对应的代码文件 [mysqld] character-set-server=utf8 [client] default-character-set=utf8 [mysql] default-character-set=utf8 # 重新启动服务 sudo systemctl restart mariadb MySql操作（此命令为在centos上下载mysql） su # 切换到root用户 yum install -y mariadb mariadb-server # 安装MySQL服务器 systemctl start mariadb # 启动MySQL服务 eg：若安装mysql后无法启动，可参考本篇文章解决问题 数据库操作 mysql -u root -p #使用root用户登录数据库 ##数据库 #查看所有数据库 show databases; #创建数据库 create database nodejs; #删除数据库 drop database nodejs; #连接数据库 use nodejs; ##表 #创建表 create table MyClass( > id int(4) not null primary key auto_increment, > name char(20) not null, > sex int(4) not null default '0', > degree double(16,2)); #删除表 drop table MyClass; ##数据 #增 insert into MyClass values(1,'Tom',1,96.45),(2,'Joan',1,82.99), (3,'Wang',1, 96.59); #删 delete from MyClass where id=1; #改 update MyClass set name='Mary' where id=1; #查 select * from MyClass; 在nodejs中使用数据库 const mysql = require('mysql'); //引入第三方库 const con = mysql.createConnection({ host:'localhost', user:'root', password:'123456', database:'MyClass' }); con.conent(); //连接数据库 // database operation // 查 const sql = 'select * from books'; // 增 const sql = 'insert into books where book_id = ?'; // 改 const sql = 'update books set status = ? where book_id = ?'; // 删 const sql = 'delete from books where book_id = ?'; con.query(sql,[1],(err,result)=>{ if(err){ console.error(err); process.exit(1000); } console.log(result); }); con.end(); 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/js异步编程.html":{"url":"js/js异步编程.html","title":"js异步编程","keywords":"","body":"js的异步发展 js是单线程，也就是所有的工作将按顺序完成，这也就是正常的同步执行，但是如果有一个任务加载时间较长，后面的任务将始终得不到加载，即发生堵塞，所以，异步执行对js的意义非凡。 此处所讲的，也可是说是es的异步发展史。除此之外，仍有一些模式可以解决异步问题。 JS的异步发展史，可以认为是从 callback -> promise -> generator -> async/await。 回调函数callback 被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数。如setTimeOut，ajax请求，readFile等。 function greeting(name){ console.log(\"Hello,\"+name); } function processUserInput(callback){ let name = prompt(\"请输入你的名字\"); callback(name); } processUserInput(greeting); 优点： 解决了异步的问题。 缺点： 回调地狱：多个回调函数嵌套的情况，使代码看起来很混乱，不易于维护。 Promise Promise是es6提出的异步编程的一种解决方案。 Promise 对象有三种状态： pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 promise的状态只能从pending变成fulfilled，和pending变成rejected，状态一旦改变，就不会再改变，且只有异步操作的结果才能改变promise的状态。 例： function read(url){ return new Promise((resolve,reject) => { fs.readFile(url,'utf-8',(err, data) => { if(err) reject(err); resolve(data); }) }) } read(A).then(data => { return read(B); }).catch(reason => { console.log(reason); }) 优点：解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。 缺点：无法取消promise。如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。当执行多个Promise时，一堆then看起来也很不友好。 Generator Generator是es6提出的另一种异步编程解决方案，需要在函数名之前加一个*号，函数内部使用yield语句。Generaotr函数会返回一个遍历器，可以进行遍历操作执行每个中断点yield。 function *count(){ yield 1; yield 2; return 3; } let c = count(); console.log(c.next()); // { value: 1, done: false } console.log(c.next()); // { value: 2, done: false } console.log(c.next()); // { value: 3, done: true } console.log(c.next()); // { value: undefined, done: true } 优点：没有了Promise的一堆then(),异步操作更像同步操作，代码更加清晰。 缺点：不能自动执行异步操作，需要写多个next()方法，需要配合使用Thunk函数和Co模块才能做到自动执行。 async/await async function自动将常规函数转换成Promise，返回值也是一个Promise对象, 只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数, 异步函数内部可以使用await. await 放置在Promise调用之前，await 强制后面点代码等待，直到Promise对象resolve，得到resolve的值作为await表达式的运算结果 //实例一 async function read() { let readA = await readFile('data/a.txt') //readFile是异步发开文件 console.log(readA) } read() //实例二 function pm(){ return new Promise((res,rej)=>{ res('1') }) } async function test(){ let a=await pm(); let b=await `2`; return a+b; } test() //12 优点：内置执行器，比Generator操作更简单。async/await比*/yield语义更清晰。返回值是Promise对象，可以用then指定下一步操作。代码更整洁。可以捕获同步和异步的错误。 缺点：暂时没有人提及这种写法的缺点，目前前端圈一致推荐的异步操作的写法。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/js模块化.html":{"url":"js/js模块化.html","title":"js模块化","keywords":"","body":"js模块化发展 渐渐js开始发展到服务器端，而作为服务端语言，所必备的一个条件就是模块化，于是各个社区开始指定js相关的模块规范。而到es6的时候，es官方也给出了模块机制。 模块化演变 全局function模式==>namespace模式==>IIFE模式==>IIFE模式增强==>模块模式 全局function模式 function m1(){ //... } 问题：污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系 namespace模式 let myModule = { data: 'www.baidu.com', foo() { console.log(`foo() ${this.data}`) }, bar() { console.log(`bar() ${this.data}`) } } myModule.data = 'other data' //能直接修改模块内部的数据 myModule.foo() // foo() other data 问题: 数据不安全(外部可以直接修改模块内部的数据) IIFE模式：匿名函数自调用(闭包) // module.js文件 (function(window) { let data = 'www.baidu.com' //操作数据的函数 function foo() { //用于暴露有函数 console.log(`foo() ${data}`) } function bar() { //用于暴露有函数 console.log(`bar() ${data}`) otherFun() //内部调用 } function otherFun() { //内部私有的函数 console.log('otherFun()') } //暴露行为 window.myModule = { foo, bar } //ES6写法 })(window) // index.html文件 myModule.foo() myModule.bar() console.log(myModule.data) //undefined 不能访问模块内部数据 myModule.data = 'xxxx' //不是修改的模块内部的data myModule.foo() //没有改变 问题:无法在该模块引入另外一个模块 IIFE模式增强 : 引入依赖 // module.js文件 (function(window, $) { let data = 'www.baidu.com' //操作数据的函数 function foo() { //用于暴露有函数 console.log(`foo() ${data}`) $('body').css('background', 'red') } function bar() { //用于暴露有函数 console.log(`bar() ${data}`) otherFun() //内部调用 } function otherFun() { //内部私有的函数 console.log('otherFun()') } //暴露行为 window.myModule = { foo, bar } })(window, jQuery) // index.html文件 myModule.foo() 问题：过多的script标签导致请求过多、依赖模糊（不清楚谁依赖谁）、 难以维护 。所以在此基础上，js便开始了产生了模块化的规范。 常见的模块规范 AMD（require.js库使用）非同步 //定义没有依赖的模块 define(function(){ return 模块 }) //定义有依赖的模块 define(['module1', 'module2'], function(m1, m2){ return 模块 }) //引入使用模块 require(['module1', 'module2'], function(m1, m2){ //使用m1/m2 }) CMD（sea.js库使用）异步 //定义没有依赖的模块 define(function(require, exports, module){ exports.xxx = value module.exports = value }) //定义有依赖的模块 define(function(require, exports, module){ //引入依赖模块(同步) var module2 = require('./module2') //引入依赖模块(异步) require.async('./module3', function (m3) { }) //暴露模块 exports.xxx = value }) //引入使用模块 define(function (require) { var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show() }) CommonJs （node.js中使用）同步 //一个一个 导出 module.exports.foo = function(){} module.exports.age = 1 exports.a = 'hello' //使用exports导出后不能修改此变量，作为静态变量 //整体导出，不能使用exports导出 module.exports = { age: 1, a: 'hello', foo:function(){} } //导入 const foo = require('./foo.js'); es6 module （react等框架）异步 //导出 export { name1, name2, …, nameN }; // 与之前声明的变量名绑定 命名导出 export default expression; // 默认导出 //导入 import defaultExport from 'module'; //与commonjs的区别 //1、CommonJs导出的是变量的一份拷贝，ES6 Module导出的是变量的绑定（引用）； //2、CommonJs是单个值导出，ES6 Module可以导出多个； //3、CommonJs是动态语法可以写在判断里，ES6 Module静态语法只能写在顶层； //4、CommonJs的 this 是当前模块，ES6 Module的 this 是 undefined。 以及组合型的模块规范 UMD通用模块 （ 就是AMD+CommonJs+全局变量的组合规范 ） (function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global.libName = factory());//在原生js情况下，此处的global就是指的window对象 }(this, (function () { 'use strict';}))); 在实际的情况中，各个类库基本都是将某个规范细微改动后使用，例如node也是将commonjs的模块机制调动后使用的。react也是将自行编译了es6的模块机制。 语法 commonJS ES6 AMD CMD 导出 module.exports = {}exports = {} export default {}export var a = 10 define(id?: String, dependencies?: String[], factory: Function(Object); define(function(require, exports, module) {}); 导入 require(‘module’) import module from ‘module’ require([‘myModule’], function(myModule) {}); var a = require(‘./a’);require.async(‘./b’, function(b) {}); 加载 动态 – 同步 静态 动态-异步 动态-同步或异步 导出的对象 副本 引用 多次导出 同一个对象 模块作用域 文件 文件 文件 循环加载时 加载已执行的部分 浏览器支持 是 否 是 是 node支持 是 否 是 典型环境 nodejs babel，vue requirejs seajs 引用目录时 找package.json定义的main,或index 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/对于js事件的解析.html":{"url":"js/对于js事件的解析.html","title":"对于js事件的解析","keywords":"","body":"事件大致分为pc端和移动端，其事件对象有部分属性不同，但他们都有一些相同的且基础的属性和方法 事件对象的基本属性和方法 此处需要说明的是，target和currentTarget属性。 document.getElementById('a').addEventListener('click', function(e) { console.log('target:' + e.target.id + '&currentTarget:' + e.currentTarget.id); }); document.getElementById('b').addEventListener('click', function(e) { console.log('target:' + e.target.id + '&currentTarget:' + e.currentTarget.id); }); document.getElementById('c').addEventListener('click', function(e) { console.log('target:' + e.target.id + '&currentTarget:' + e.currentTarget.id); }); document.getElementById('d').addEventListener('click', function(e) { console.log('target:' + e.target.id + '&currentTarget:' + e.currentTarget.id); }); 上面事件的绑定都是在冒泡阶段的，当我们点击最里层的元素d的时候，会依次输出: target:d&currentTarget:d target:d&currentTarget:c target:d&currentTarget:b target:d&currentTarget:a 上面事件的绑定都是在捕捉阶段的，当我们点击最里层的元素d的时候，会依次输出: target:d&currentTarget:a target:d&currentTarget:b target:d&currentTarget:c target:d&currentTarget:d 移动端特有属性 移动端的事件大致有 1、touchstart 当手指放在屏幕上触发。 2、touchmove 当手指在屏幕上滑动时，连续地触发。 3、touchend 当手指从屏幕上离开时触发。 4、touchcancel 当系统停止跟踪时触发。 除了常用的DOM属性，触摸事件还包含下列三个用于跟踪触摸的属性。 1、touches：表示当前跟踪的触摸操作的touch对象的数组。 当一个手指在触屏上时，event.touches.length=1, 当两个手指在触屏上时，event.touches.length=2，以此类推。 2、targetTouches：特定于事件目标的touch对象数组。 因为touch事件是会冒泡的，所以利用这个属性指出目标对象。 3、changedTouches：表示自上次触摸以来发生了什么改变的touch对象的数组。 每个touch对象都包含下列几个属性： 4、clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier：标识触摸的唯一ID。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：触摸目标在屏幕中的x坐标。 screenY：触摸目标在屏幕中的y坐标。 target：触摸的DOM节点目标。 相关知识 移动端双击放大 触屏设备不支持双击事件。双击浏览器窗口，会放大画面。 可以通过在head标签内加上这么一行： 使用addEventListener时切换上下文 当使用addEventListener时，上下文自动切换为html元素 new function(){ this.appName=\"wem\"; document.body.addEventListener(\"click\",function(e){ alert(this.appName)//发生上下文切换，此处为undined }) } 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/ts笔记.html":{"url":"js/ts笔记.html","title":"ts笔记","keywords":"","body":"基础知识 类型 基本类型：number、string、boolean、symbol、null、undefined 还有Object， 除了上了的类型，ts还添加了下面一些类型：数组、元组、枚举、Ang、void、Never 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 let someValue: any = \"this is a string\"; let strLength: number = (someValue).length;//使用<> let someValue: any = \"this is a string\"; let strLength: number = (someValue as string).length;//使用as 一些特点 默认情况下null和undefined是所有类型的子类型。是说你可以把 null和undefined赋值给number类型的变量。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 接口 interface 定义一种数据结构，它可以去声明一个变量，也可以作为类型检验。接口可以是类接口，函数接口，索引接口。 interface ：描述一个对象的取值规范 interface User { name: string; age?: number; } const user1: User = { name: \"lili\", age: 18 }; interface SearchFunc { (source: string, subString: string): boolean; } let myFunc: SearchFunc = function(source: string, subString: string){ ... return true; } 类 他与js的区别在于在声明变量的时候需要指明数据类型 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } let greeter = new Greeter(\"world\"); 还可以通过继承来拓展类。通过extends关键字来进行继承。 派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(\"Slithering...\"); super.move(distanceInMeters); } } class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) {//重写基类方法 console.log(\"Galloping...\"); super.move(distanceInMeters);//调用基类方法 } } let sam = new Snake(\"Sammy the Python\"); let tom: Animal = new Horse(\"Tommy the Palomino\"); sam.move(); tom.move(34); 函数 在ts中，函数也可以定义类型 function add(x: number, y: number): number { return x + y; } let myAdd = function(x: number, y: number): number { return x + y; }; 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 arguments来访问所有传入的参数。 function buildName(firstName: string, ...restOfName: string[]) { return firstName + \" \" + restOfName.join(\" \"); } let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); 泛型 使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 //使用泛型声明的函数 function identity(arg: T): T {//T可以为number等任何数据类型 return arg; } //使用泛型函数 let output = identity(\"myString\"); let output = identity(\"myString\");//编辑器会自动查询myString的类型，然后做声明的 泛型与接口连用方法基本相同 interface Human { name: string age: number } interface Animal { category: string } function create(what: T): T { return what } create({ name: 'Jack', age: 18 }) create({ category: 'dog' }) //注意下面 interface JJ { jjSize: string jjLength: number } interface Human { name: string age: number } function create(what: T): T { return what } create({ name: 'Jack', age: 18, jjSize: 'large', jjLength: 18 }) create({ name: 'Jack', age: 18 }) // 报错：没有 jjSize 和 jjLength 泛型与类的合用 function create(c: { new (): T }): T { return new c() } //两个括号里写的是 new () 说明传入的 C 是可以用 new C() 的。然后为new ()添加类型，为函数输出添加类型 注解（装饰器） 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 对于不同类型的修饰器具有不同的参数。 // 定义 function zsq(params?:string) { return (target:any) => { console.log(target) } } function logAttr(params?:string){ return (target:any, attrName:any)=>{ console.log(target,attrName) } } function logMethod(params?:string) { return function(target:any, methodName:any, desc:any) { console.log(target,methodName,desc) } } function logParam(params?:any) { return function(target:any, methodName:any, paramIndex:any) { console.log(target,methodName,paramIndex) } } // 使用 @zsq() class HttpClient { @logAttr() public url:string|undefined='123'; @logMethod() actions(@logParam() p:any) { console.log(p) } } 类型映射 类型映射： 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 type Readonly = { readonly [P in keyof T]: T[P] } type Partial = { [P in keyof T]?: T[P] } interface Person { name: string } type PersonPartial = Partial // {name: string} type ReadonlyPerson = Readonly // { readonly name?: string } ts内置类型 Partial // 实现 type Partial = { [P in keyof T]?: T[P]; }; // 例如 interface Person { name: string; age: number; } Partial = { name?: string; age?: number; } 这个类型的用处就是可以将某个类型里的属性加上 ? 这个 modifier ，加了这个 modifier 之后那些属性就可以为 undefined 了。 Required 和上面相反，去掉所有的？属性。当然除了 // 实现 type Required = { [P in keyof T]-?: T[P]; }; Pick 可以讲某个类型中的子属性调出来 // 实现 type Pick = { [P in K]: T[P]; }; // 示例 type NewPerson = Pick; // { name: string; } Record 获取根据K中的所有可能值来设置key和value的类型 // 实现 type Record = { [P in K]: T; }; // 示例 type T11 = Record; // { a: Person; b: Person; c: Person; } Exclude 将 T 中的某些属于 U 的类型移除掉 // 实现 type Exclude = T extends U ? never : T; //示例 type T00 = Exclude; // \"b\" | \"d\" 这个类型可以结合Pick使用 // 例如Chicken类型如下 interface Chicken { name: string; age: number; egg: number; } // NewChicken类型除了name想变为number其他不变，我们可以这样 interface NewChicken extends Pick { name: number; } // 但是上面我们要把除了name的其他属性都写一遍，很麻烦，所以我们可以这样写 interface NewChicken extends Pick> { name: number; } // 我们还可以封装一下上面 type FilterPick = Pick>; interface NewChicken extends FilterPick { name: number; } ReturnType 获取某个方法的返回类型 // 实现 type ReturnType any> = T extends (...args: any[]) => infer R ? R : any; // 示例 function TestFn() { return '123123'; } type T01 = ReturnType; // string ThisType 指定上下文类型。可以看到声明中只有一个接口，没有任何的实现，说明这个类型是在 ts 源码层面支持的，而不是通过类型变换，那这个类型有啥用呢，是用于指定上下文对象类型的。 // 实现 interface ThisType { } // 示例 interface Person { name: string; age: number; } const obj = { dosth(this: Person) { this.name // string } } // 有了ThisType可改为 const obj: ThisType = { dosth() { this.name // string } } NonNullable 去掉某个类型中的null属性 // 实现 type NonNullable = T extends null | undefined ? never : T; // 示例 type T22 = '123' | '222' | null; type T23 = NonNullable; // '123' | '222'; 操作技巧 类型体操实现字段禁用 类型系统的优势 开发体验：代码补全、类型即文档 程序运行优化：动态类型不利于编译器输出优化代码。比如在JavaScript/Python中做加法，必须考虑到操作对象的类型转换或者不同类型的运算符重载。弱类型的语言（如C，或者一部分C++），是无法做出安全的垃圾回收器的。比如一个结构体中包含了一个特定类型的指针，在类型强转后变成了整型或者其他类型的指针。那么在访问对象数据或类型的时候就会出现内存访问错误或者回收了错误的对象。 错误检查、程序验证 类型解决问题的实际场景： 在To C业务中，我们需要时刻注意，绝对不能把用户敏感信息输出到公开的接口上，比如：打印到日志、存储到非保密数据库、明文做数据请求。我们将在代码编写上多加一层保护，使得敏感数据不会应用在公开的接口或日志中。 类型交叉，这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 我们可以给所有数据都加上一个字段来代表它是敏感的，但是这个字段在运行时不存在。这个技巧就叫幻影类型（Phantom type）。在理解幻影类型的之前，我们要理解下运行时和编译时的差异。 type Sensitive = T & { readonly '@@sensitive': unique symbol } 当 S 类型是 T 类型的子集，或者 T 类型是 S 类型的子集时，S 能被成功断言成 T。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用 any。 function makeSensitive(t: T): Sensitive { return t as any as Sensitive // cast } //生产一条敏感数据 let password = makeSensitive('1145141919810') password = '123456' // error, string is not 如果A extend B，那么A类型的变量可以赋值给B类型的变量 如果a是禁用字段，那么a不能赋值给b，b也不能赋值给a。但a是交叉类型，它包括了一个T类型，所以如果b是T类型，那么b=a是可以通过的 条件类型：它能够表示非统一的类型。条件类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一： T extends U ? X : Y 上面的类型意思是，若T能够赋值给U，那么类型是X，否则为Y。 declare function f(x: T): T extends true ? string : number; f(true) // string f(false) // number type TypeName = T extends string ? \"string\" : T extends number ? \"number\" : T extends boolean ? \"boolean\" : T extends undefined ? \"undefined\" : T extends Function ? \"function\" : \"object\"; type T0 = TypeName; // \"string\" type T1 = TypeName; // \"string\" type T2 = TypeName; // \"boolean\" type T3 = TypeName void>; // \"function\" type T4 = TypeName; // \"object\" 回到刚才的例子中，我们可以判断下，一个类型是不是敏感类型，如果是的话，那么就用条件类型解析成一个不可能存在的类型，否则的话就返回类型本身。 type NoSensitive = T extends Sensitive // if type T is Sensitive ? never // then it will `never` be`NoSensitive` : T // type UserAge = Sensitive type Loggable = NoSensitive // number type Secret = NoSensitive // never 但是，这个判别只会针对敏感类型本身，如果一个类型本身不敏感，但是它的字段里，或者嵌套的字段里有敏感数据怎么办呢？我们可以用映射类型(Mapping type)! 我们可以对嵌套的对象类型进行去敏感数据的操作 type NoSensitive = { [K in keyof T]: NoSensitive } 这里我们判断，对类型T的所有字段，如果一个字段是本身就敏感类型的话返回never，否则递归去掉那个字段上的敏感信息。 但是要注意，对于JS的原生数据类型我们需要直接返回。于是整合条件类型和映射类型就得到了如下。 type Primitives = number | string | boolean | null | undefined | symbol | Date | RegExp type NoSensitive = T extends Sensitive ? 'No Leak' : T extends Primitives ? T : { [K in keyof T]: NoSensitive } interface UserData { name: string ageGroup: Sensitive } function usePublic(t: NoSensitive) {} // error // ageGroup is never, Sensitive cannot be assigned to never usePublic({ name: 'Sheep', ageGroup: makeSensitive('middle aged man') }) 通过上面的思路可以实现如下 type Sensitive=T&{ readonly '@@sensitive':unique symbol } type Primitives=number | string | boolean | null | undefined | symbol | Date | RegExp type NoSensitive = T extends Sensitive ? never : T extends Primitives ? T : { [K in keyof T]:NoSensitive } type Sanitized={ [K in keyof T]:NoSensitive } & { readonly '@@sensitive'?:never } //uasge declare function makeSensitive(t:T):Sensitive //guard data declare function logToStdout>(t:T):T const data=makeSensitive('lalala') logToStdout(data) logToStdout({ data }) 不确定参数类型 interface A { a: number }; interface B { b: string }; function foo(x: A | B) { if (\"a\" in x) { return x.a; } return x.b; } 类型判断 type num = 1; type str = 'hello world'; type IsNumber = N extends number ? 'yes, is a number' : 'no, not a number'; type result1 = IsNumber; // \"yes, is a number\" type result2 = IsNumber; // \"no, not a number\" never的使用 never：never类型表示值的类型从不出现。 never是所有类型的子类型并且可以赋值给所有类型。 没有类型是never的子类型或能赋值给never（never类型本身除外）。 在有明确never返回类型注解的函数中，所有return语句（如果有的话）必须有never类型的表达式并且函数的终点必须是不可执行的。 // 函数返回never必须无法执行到终点 function error(message: string): never { throw new Error(message); } let a: never a = 123 // error, nothing else can be assigned to never a = error('never here') // ok, only never can be assigned 那never的具体使用场景呢？ 举个具体点的例子，当你有一个 union type: interface Foo { type: 'foo' } interface Bar { type: 'bar' } type All = Foo | Bar 在 switch 当中判断 type，TS 是可以收窄类型的 (discriminated union)： function handleValue(val: All) { switch (val.type) { case 'foo': // 这里 val 被收窄为 Foo break case 'bar': // val 在这里是 Bar break default: // val 在这里是 never const exhaustiveCheck: never = val break } }。 注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型： type All = Foo | Bar | Baz 然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。 never的作用： never 代表空集。 常用于用于校验 \"类型收窄\" 是否符合预期，就是写出类型绝对安全的代码。 never 常被用来作 \"类型兜底\"。 keyof、in、infer // keyof的示例 interface API { '/user': { name: string }, '/menu': { foods: Food[] }, } const get = (url: URL): Promise => { return fetch(url).then(res => res.json()) } get('/usr').then(usr => user.name) // in的示例 type DeepReadonly = { readonly [P in keyof T]: DeepReadonly; } // 巧用显式泛型 function $(id: string):T { return document.getElementById(id) } $('input').value // infer type ParamType = T extends (param: infer P) => any ? P : T; interface User { name: string; age: number; } type Func = (user: User) => void; type Param = ParamType; // Param = User type AA = ParamType; // string 类型推导 过滤与分流 //过滤 type Exclude = T extends U ? never : T; //分流（类型守卫 // 注意这里需要返回 boolean 类型 function isA(x): x is A { return true; } // 注意这里需要返回 boolean 类型 function isB(x): x is B { return x instanceof B; } function foo2(x: unknown) { if (isA(x)) { // x is A } else { // x is B } } 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/ES6.html":{"url":"js/ES6.html","title":"ES6","keywords":"","body":"es每年发布一版，如2017年发布的就叫es2017也叫es8。 除此之外，以es2015为分割线，前面的内容统称为es5，而包括es2015以后的版本被称为es6。 es2015 1、箭头函数 在没有箭头函数情况下，this的指向有以下几种情况 在全局执行环境中（在任何函数体外部），this都是指向全局对象 在函数环境中，严格模式下无指向，一般模式下，在一层函数中指向window 在对象的方法中，指向对象 在构造函数中，指向实例化对象 在函数中，当函数被用作事件处理函数时，它的this指向触发事件的元素 对于this的理解，我认为this是指向对象的一个属性，他将函数视为透明，当初现在函数中，他会不断地向上级寻找，直至找到一个对象，并指向它。 在箭头函数中，箭头函数的this被设置为封闭的词法环境的，换句话说，箭头函数中的this取决于该函数被创建时的环境（即箭头函数与包围他的代码共享一个this）。 2、函数参数 为函数参数添加默认的值 const test = (a='a',b='b',c='c')=>{ return a+b+c } console.log(test('A','B','C')) //ABC console.log(test('A','B')) //ABc console.log(test('A')) //Abc 多参数 function fuc(...arg){ console.log(arg) } fuc(1,2,3) //[1,2,3] 函数尾调用，在函数最后调用其他函数或者自己 let fun1=(x,y)=>x+y let fun2=()=>{ return fn1(1,2) } console.log(fun2) 以上是一个尾调用，在执行fun2的时候，也执行了fun1，当fun1执行完成后，由于再无牵连，会将fun1的内存给fun2继续使用，这样减少了内存占用。 以下情况不是尾调用： let fun3=()=>{ let n=fun1(2,3) return n; } 由于不是在最后一步调用所以不是尾调用 let fun4=()=>{ return fun1(2,3)+1 } return fun1(2,3)+1他其实是先执行的fun1(2,3)+1再执行return，所以此处也不是在最后一步调用，所以也不是尾调用 递归的尾调用优化 以下是一个递归函数 let factorial=(n)=>{ if(n 由于函数参与了运算，所以不是尾调用，每次调用开辟内存，耗费资源，我们将其改为尾递归 let factorial=(n,p=1)=>{ if(n 3、模板字符串 //常见写法 var name = `Your name is ${first} ${last}.` //函数参数写法 function fuc(a,b,c,d){ //b,c,d分别为第一、二、三个变量 //a为被变量分割的字符串['name=','age=','logo='] return b+c+d } let name=\"xwx\" let age=21 let logo=\"1.png\" let result=fuc`name=${name}age=${age}logo=${logo}` 4、解构赋值 数组中 var foo = [\"one\", \"two\", \"three\", \"four\"]; var [one, two, three] = foo; console.log(one); // \"one\" console.log(two); // \"two\" console.log(three); // \"three\" //如果你要忽略某些值，你可以按照下面的写法获取你想要的值 var [first, , , last] = foo; console.log(first); // \"one\" console.log(last); // \"four\" //你也可以这样写 var a, b; //先声明变量 [a, b] = [1, 2]; console.log(a); // 1 console.log(b); // 2 对象中 const student = { name:'Ming', age:'18', city:'Shanghai' }; const {name,age,city} = student; console.log(name); // \"Ming\" console.log(age); // \"18\" console.log(city); // \"Shanghai\" 5、延展操作 展开数组 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; var arr3 = [...arr1, ...arr2];// 将 arr2 中所有元素附加到 arr1 后面并返回 //等同于 var arr4 = arr1.concat(arr2); 展开对象 var obj1 = { foo: 'bar', x: 42 }; var obj2 = { foo: 'baz', y: 13 }; var clonedObj = { ...obj1 }; // 克隆后的对象: { foo: \"bar\", x: 42 } var mergedObj = { ...obj1, ...obj2 }; // 合并后的对象: { foo: \"baz\", x: 42, y: 13 } react中应用 const params = { name: 'Jine', age: 21 } var params = { name: '123', title: '456', type: 'aaa' } var { type, ...other } = params; //等同于 6、promise 用于处理异步操作 var test = (a,b)=>{ return new Promise((reslove,reject)=>{ //异步操作例如setTimeout //... reslove(resoult)//返回正确结果 //... reject(err) //出错时的结果 }) } //使用 test(a,b).then(res=>{ //此处是reslove，即成功后执行的函数 }).catch(err=>{ //此处是reject，即失败后执行的函数 }) //或者 try{ var resoult = await test(a,b) //... }catch(er){ //... } 7、类 使用class声明的类，方法等价于写在原型上的。 class Animal { // 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数. constructor(name,color) { this.name = name; this.color = color; } // toString 是原型对象上的属性 toString() { console.log('name:' + this.name + ',color:' + this.color); } } var animal = new Animal('dog','white');//实例化Animal animal.toString(); console.log(animal.hasOwnProperty('name')); //true console.log(animal.hasOwnProperty('toString')); // false console.log(animal.__proto__.hasOwnProperty('toString')); // true class Cat extends Animal { constructor(action) { // 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错. // 如果没有置顶consructor,默认带super函数的constructor将会被添加、 super('cat','white'); this.action = action; } toString() { console.log(super.toString()); } } var cat = new Cat('catch') cat.toString(); // 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。 console.log(cat instanceof Cat); // true console.log(cat instanceof Animal); // true 8、模块化 es6虽然自己定义了模块的概念及方法，但通常在使用中，会使用到其他的规范，如nodejs使用的是commonjs规范去定义模块。 9、Iterator 一个统一的接口来遍历所有的数据类型 Array.prototype[Symbol.iterator]().next() //返回下一个值 10、循环方式 let list=[3,4,5,6] for(let i in list){ console.log(list[i]) } for(let n of list){ console.log(n) } list.forEach((n,i)=>{ console.log(n) }) 11、filter 过滤器 let num1=[1,2,3,4] let num2=num1.filter(x=>x!=1)//过滤掉1 console.log(num2) //[2,3,4] 12、Set 主要作用常用操作数组来去重、添加删除成员变量、交并差集 //去重 let arr1=[1,2,3,2] let arr2=new Set(arr1)//[1,2,3] //添加删除成员 let arr3=[1,2,3,2] let arr4=new Set(arr3) arr4.add(0) arr4.delete(1) //并集 let arr5=[1,2,3,4] let arr6=[3,4,5,6] let set1=new Set([...arr5,...arr6]) //交集 let arr7=[1,2,3,4] let arr8=[3,4,5,6] let set2=new Set([...arr7].filter(x=>arr8.has(x))) //差集 let arr9=[1,2,3,4] let arr10=[3,4,5,6] let set3=new Set([...arr9].filter(x=>!arr10.has(x))) 13、Map 通过键值对来存储的数据结构，他与对象的区别是他的key值可以是任意数据类型 let num=123 let arr=[1,2,3] let fun=function(){} let obj={} const map1=new Map(); map1.set(num,\"abc\")//赋值 map1.set(arr,\"abc\")//赋值 map1.set(fun,\"abc\")//赋值 map1.set(obj,\"abc\")//赋值 map1.keys()//key值得数组 map1.values()//value值得数组 map1.entries()//以Array的格式输出所有项 //直接创建对象 const map2=new Map( [ [\"s1\",\"as1\"], [\"s2\",\"as2\"], [\"s3\",\"as3\"], [\"s4\",\"as4\"] ] ) map2.detele(\"s3\") map2.has(\"s3\")//false ES2016 1、includes()、startsWith()、endsWidth() 用来判断一个数组或字符串是否包含某一个值 用来判断字符串的前n位中是否以一个值开头 用来判断字符串的前n位中是否以一个值结尾 let arr = ['react', 'angular', 'vue']; let str = \"abc\" console.log(arr.includes('react')) console.log(str.includes('a')) console.log(str.startsWith('a',2)) console.log(str.endsWith('c',3)) 2、**指数运算符 它的作用与Math.pow(..)等效的计算结果 console.log(2**10);// 输出1024 es2017 1、async/await await使得后面的异步方法执行完后再向下执行 async function process(array) { for await (let i of array) { doSomething(i); } } 2、Object.values(obj) 返回一个给定对象自身的所有可枚举属性值的数组。 用于将对象转化为数组。 const obj = {a: 1, b: 2, c: 3}; const values=Object.values(obj); console.log(values);//[1, 2, 3] 3、Object.entries() Object.entries()函数返回一个给定对象自身可枚举属性的键值对的数组。 常用于遍历对象 const obj = {a: 1, b: 2, c: 3}; console.log(Object.entries(obj)) //(3) [[\"a\", 1], [\"b\", 2], [\"c\", 3]] for(let [key,value] of Object.entries(obj1)){ console.log(`key: ${key} value:${value}`) } //key:a value:1 //key:b value:2 //key:c value:3 4、String padding String.prototype.padStart(targetLength,[padString]) String.prototype.padEnd(targetLength,padString]) targetLength:当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString:(可选)填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 \" \"。 console.log('0.0'.padStart(4,'*'))//*0.0 console.log('0.0'.padStart(20))// 0.0 console.log('0.0'.padEnd(4,'*'))//0.0* console.log('0.0'.padEnd(10,'*'))//0.0******* 5、Object.getOwnPropertyDescriptors() 返回对象所有属性的属性（如可遍历、可操作性） const obj2 = { name: 'Jine', get age() { return '18' } }; console.log(Object.getOwnPropertyDescriptors(obj2)) // { // age: { // configurable: true, // enumerable: true, // get: function age(){}, //the getter function // set: undefined // }, // name: { // configurable: true, // enumerable: true, // value:\"Jine\", // writable:true // } // } 6、ArrayBuffer、SharedArrayBuffer 关于内存的知识，可以通过这篇文章来进行一个了解： https://hacks.mozilla.org/2017/06/a-crash-course-in-memory-management/ es2018 1、Promise.finally 一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。 function doSomething() { doSomething1() .then(doSomething2) .then(doSomething3) .catch(err => { console.log(err); }) .finally(() => { // finish here! }); } 2、正则表达式命名捕获组 通过添加组在一个正则式子中选择多个字符串。 const reDate = /(?[0-9]{4})-(?[0-9]{2})-(?[0-9]{2})/, match = reDate.exec('2018-04-30'), year = match.groups.year, // 2018 month = match.groups.month, // 04 day = match.groups.day; // 30 const reDate = /(?[0-9]{4})-(?[0-9]{2})-(?[0-9]{2})/, d = '2018-04-30', usDate = d.replace(reDate, '$-$-$'); 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/js函数高阶应用.html":{"url":"js/js函数高阶应用.html","title":"js函数高阶应用","keywords":"","body":"高阶函数 高阶函数，接受函数作为输入或者输出一个函数 emmitter.on('data',function(){}) 偏函数 为了调用函数A，但为了应对不同情景，需要对函数A根据不同场景做出细微改变，于是创建创建函数B去返回根据不同场景更改后的函数A（函数A的参数或者变量是预置的），函数B即为偏函数。 简单来说就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 //例如我们要封装sum函数，现在要锁定a=1 function sum(a, b) { return a + b; } sum_add_1(2); // 3 sum_add_1(3); // 4 //最简单的实现，sum_add_1为偏函数 const sum_add_1 = sum.bind(null, 1); //当然，我们也可以做一个函数来产生偏函数 /* 我们预期做一个函数partial 使得const sum_add_1 = partial(sum, 1); */ const partial = (func, ...args) => { return (...rest) => { return func.apply(this, [...args, ...rest]) } } 柯里化 可以自由选择操作，如加减乘除 var curry = function(fn) { var _args = []; return function() { if(arguments.length === 0) { return fn.apply(fn, _args); } [].push.apply(_args, arguments); return arguments.callee; } } var multi = function() { return [].reduce.call(arguments, function(a, b) { return a + b; }) } var add = curry(multi); add(100, 200, 300)(400); add(1000); add(); // 2000 无需最后通过空参数调用来求职 var curry = function(fn) { var len = fn.length, args = []; return function() { Array.prototype.push.apply(args, arguments) var argsLen = args.length; if(argsLen 以上的方式太过于依赖参数数量 var curry = function(fn) { var func = function() { var _args = [].slice.call(arguments, 0); var func1 = function() { [].push.apply(_args, arguments) return func1; } func1.toString = func1.valueOf = function() { return fn.apply(fn, _args); } return func1; } return func; } var add = function() { return [].reduce.call(arguments, function(a, b) { return a + b; }) } var adder = curry(add) adder(1)(2)(3) 柯里化进行预加载 有时候，我们多次调用一个函数，而每次调用的而一部分参数相同，我们可以用柯里化进行预加载。 例如 //简单封装一下match var match = curry(function(what, str) { return str.match(what); }); match(/\\s+/g, \"hello world\"); match(/\\s+/g)(\"hello world\"); match(/\\s+/g)(\"spaceless\"); //参数都一样，我们进行改造 var hasSpaces = match(/\\s+/g); hasSpaces(\"hello world\"); hasSpaces(\"spaceless\"); 动态创建函数 if在创建出addEvent实例之前进行if判断保证只判断一回，不会每次使用都进行if判断，判断后将addEvent重新赋值而不是直接返回一个函数，解决了内存。 var addEvent = function(el, sType, fn, capture){ if (window.addEventListener) { addEvent = function(el, sType, fn, capture) { el.addEventListener(sType, function(e) { fn.call(el, e); }, (capture)); }; } else if (window.attachEvent) { addEvent = function(el, sType, fn, capture) { el.attachEvent(\"on\" + sType, function(e) { fn.call(el, e); }); }; } } var addEvent = addEventHandler(); addEvent(document.body, \"click\", function() {}, false); addEvent(document.getElementById(\"test\"), \"click\", function() {}, false); 反柯里化 反柯里化恰恰和柯里化相反，是为了扩大适用范围，创建一个应用范围更广的函数。使本来只有特定对象才适用的方法，扩展到更多的对象。 通过反柯里化，让对象也可以使用数组的方法。 const unCurry= function(fn) { return function(target, ...rest) { return fn.apply(target, rest); } }; const obj = {}; const push = unCurry(Array.prototype.push); push(obj, 1, 2, 3); console.log(obj); // { 0: 1, 1: 2, 2: 3} 我们在开发中，经常会借用 Object.prototype.toString 来检测一个变量的类型，这也是反柯里化的用法之一。 const num = 1, str = '2', obj = {}, arr = [], nul = null; const toString = unCurry(Object.prototype.toString.call); toString.call(nul); // \"[object Null]\" toString.call(num); // \"[object Number]\" toString.call(str); // \"[object String]\" toString.call(arr); // \"[object Array]\" 防抖 在最后一次触发事件后n秒后执行。 最简单的防抖 function debounce(func, wait) { var timeout; return function () { clearTimeout(timeout) timeout = setTimeout(func, wait); } } 存在的问题 在传入的func中，如果使用了this，他会指向window 无法传入事件对象event 以下是优化的 function debounce(func, wait) { var timeout; return function () { var context = this; var args = arguments; clearTimeout(timeout) timeout = setTimeout(function(){ func.apply(context, args) }, wait); } } 当我们改变需求后，需要立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。我们添加一个参数来判断是否立刻执行 function debounce(func, wait, immediate) { var timeout; return function () { var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) { // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function(){ timeout = null; }, wait) if (callNow) func.apply(context, args) } else { timeout = setTimeout(function(){ func.apply(context, args) }, wait); } } } 节流 如果你持续触发事件，每隔一段时间，只执行一次事件。 时间戳实现 function throttle(func, wait) { var context, args; var previous = 0; return function() { var now = +new Date(); context = this; args = arguments; if (now - previous > wait) { func.apply(context, args); previous = now; } } } 计时器实现 // 第二版 function throttle(func, wait) { var timeout; var previous = 0; return function() { context = this; args = arguments; if (!timeout) { timeout = setTimeout(function(){ timeout = null; func.apply(context, args) }, wait) } } } 数组去重 使用indexOf var array = [1, 2, 1, 1, '1']; function unique(array) { var res = array.filter(function(item, index, array){ return array.indexOf(item) === index; }) return res; } console.log(unique(array)); 先排序，后去重。如果给出的是一个排列好的数组，那次方法效率更高。当然两种方法可以结合，通过参数一个参数制定数组是不是有序来选择return的内容 var array = [1, 2, 1, 1, '1']; function unique(array) { return array.concat().sort().filter(function(item, index, array){ return !index || item !== array[index - 1] }) } console.log(unique(array)); ES6中骚操作 //使用set var unique = (a) => [...new Set(a)] //使用map function unique (arr) { const seen = new Map() return arr.filter((a) => !seen.has(a) && seen.set(a, 1)) } 类型判断 由于Error、array等都属于对象，所以为了区分它们，就不能使用typeOf了，我们引出Object.prototype.toString 当 toString 方法被调用的时候，下面的步骤会被执行： 如果 this 值是 undefined，就返回 [object Undefined] 如果 this 的值是 null，就返回 [object Null] 让 O 成为ToObject(this)的结果 让 class 成为 O 的内部属性 [[Class]] 的值 最后返回由 \"[object \" 和 class 和 \"]\" 三个部分组成的字符串 所以 var date = new Date(); console.log(Object.prototype.toString.call(date)) // [object Date] 利用这个特性我们进行以下函数的封装 var class2type = {}; // 生成class2type映射 \"Boolean Number String Function Array Date RegExp Object Error Null Undefined\".split(\" \").map(function(item, index) { class2type[\"[object \" + item + \"]\"] = item.toLowerCase(); }) function type(obj) { return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] || \"object\" : typeof obj; } 深拷贝、浅拷贝 当我们想复制一个数组，通过concat等一些方法就可以产生一个新的对象，但是这仅限于数组的元素全部为基本元素，如果元素是对象，那么改变就数组，新数组也会变，这就是浅拷贝，也就几十克隆不彻底。（所以concat 和 slice 是一种浅拷贝） 有很多技巧类方法例如concat 和 slice 可以实现浅拷贝JSON.stringify可以实现深拷贝，以下是原理实现方面 浅拷贝实现 var shallowCopy = function(obj) { // 只拷贝对象 if (typeof obj !== 'object') return; // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : {}; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj; } 深拷贝的实现 var deepCopy = function(obj) { if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : {}; for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; } } return newObj; } 数组的最大值 很多方法如最基础的循环、reduce、排序、eval等 //循环 var arr = [6, 4, 1, 8, 2, 11, 23]; var result = arr[0]; for (var i = 1; i 惰性函数 我们现在需要写一个foo函数，这个函数返回首次调用时的 Date 对象，注意是首次。 首先想到的方法是定义一个变量，第一次调用函数的时候赋值，之后每次调用直接请求 var foo = (function() { var t; return function() { if (t) return t; t = new Date(); return t; } })() 而惰性函数就是解决每次都要进行判断这个问题 var foo = function() { var t = new Date(); foo = function() { return t; }; return foo(); }; 应用场景，DOM 事件添加中，为了兼容现代浏览器和 IE 浏览器，我们需要对浏览器环境进行一次判断： function addEvent (type, el, fn) { if (window.addEventListener) { el.addEventListener(type, fn, false); } else if(window.attachEvent){ el.attachEvent('on' + type, fn); } } //写成惰性函数的形式 function addEvent (type, el, fn) { if (window.addEventListener) { addEvent = function (type, el, fn) { el.addEventListener(type, fn, false); } } else if(window.attachEvent){ addEvent = function (type, el, fn) { el.attachEvent('on' + type, fn); } } } 函数组合 当我们要完成一套业务时，需要完成多个功能，利用函数去做大概是这样fn3(fn2(fn1(fn0(x))))。然而这样嵌套多层，我们的理想化是这样var greet=compose(fn0,fn1,fn2,fn3);greet(x) function compose() { var args = arguments; var start = args.length - 1; return function() { var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; }; }; 当我们使用业务的时候 // 需求：输入 'kevin'，返回 'HELLO, KEVIN'。 // 非 pointfree，因为提到了数据：name var greet = function(name) { return ('hello ' + name).toUpperCase(); } // pointfree // 先定义基本运算，这些可以封装起来复用 var toUpperCase = function(x) { return x.toUpperCase(); }; var hello = function(x) { return 'HELLO, ' + x; }; var greet = compose(hello, toUpperCase); greet('kevin'); 这种写法属于pointfree思想。指的是函数无须提及将要操作的数据是什么样的。 记忆函数 函数记忆是指将上次的计算结果缓存起来，当下次调用时，如果遇到相同的参数，就直接返回缓存中的数据。函数记忆只是一种编程技巧，本质上是牺牲算法的空间复杂度以换取更优的时间复杂度 使用起来如下 function add(a, b) { return a + b; } // 假设 memoize 可以实现函数记忆 var memoizedAdd = memoize(add); memoizedAdd(1, 2) // 3 memoizedAdd(1, 2) // 相同的参数，第二次调用时，从缓存中取出数据，而非重新计算一次 下面是他的实现 function memoize(f) { var cache = {}; return function(){ var key = arguments.length + Array.prototype.join.call(arguments, \",\"); if (key in cache) { return cache[key] } else { return cache[key] = f.apply(this, arguments) } } } 乱序 将一个数组打乱顺序，通常的实现 var values = [1, 2, 3, 4, 5]; values.sort(function(){ return Math.random() - 0.5; }); console.log(values) 但是此处并不是真正的乱序，我们乱序十万次得到统计，1为最后一次的次数大约为5的五倍，那原因是什么呢？ 这和sort有关，由于这是es的规范，每个浏览器的实现不同，这里以v8为准。v8处理sort方法时，当数组长度小于10时，使用插入排序，反之使用快速排序和插入排序的混合排序。 当我们处理[1,2,3]时，使用插入排序。 插入排序原理，从第二位（i位）开始，依次按顺序插入到[1,i-1]的数组中，直到最后一位。 所以，在插入排序的算法中，当待排序元素跟有序元素进行比较时，一旦确定了位置，就不会再跟位置前面的有序元素进行比较，所以就乱序的不彻底。 所以真正做到乱序，用到了Fisher–Yates算法，他的实现如下 function shuffle(a) { for (let i = a.length; i; i--) { let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; } return a; } 插入排序的实现，时间复杂度最好O(n)，最坏o(n*2) function insertionSort(arr) { for (var i = 1; i = 0; j--) { var tmp = arr[j]; var order = tmp - element; if (order > 0) { arr[j + 1] = tmp; } else { break; } } arr[j + 1] = element; } return arr; } var arr = [6, 5, 4, 3, 2, 1]; console.log(insertionSort(arr)); 快速排序，他的原理步骤 选择一个元素作为\"基准\" 小于\"基准\"的元素，都移到\"基准\"的左边；大于\"基准\"的元素，都移到\"基准\"的右边。 对\"基准\"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 实现如下 var quickSort = function(arr) { 　　if (arr.length 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/js常用api总结.html":{"url":"js/js常用api总结.html","title":"js常用api总结","keywords":"","body":"数组方法 改变自身的方法(可看作队列) push()和pop()：把内容填到末尾返回长度，删除末尾元素并返回 shift() 和 unshift()：把内容填到首位返回长度，删除首位元素并返回 sort()：排序 reverse()：反转 splice()：删除、插入、替换。参数表示1、要删除的第一项2、要删除的位数3、要插入的项 indexOf()和 lastIndexOf()：从正反向查找某一项 forEach()：遍历，传入函数的参数为遍历数组内容、对应数组索引、数组本身 map() ：映射 filter() ：过滤器 every() ：判断每一项是否满足返回的条件，满足返回true some() ：判断是否有一项满足返回条件，满足返回true 生成新数组 join()：数组转化为字符串 concat()：将参数的数字或数组添加到源数组中 slice()：截取起始项和结束位置（不包括结束位置） 其他方法 reduce ```javascript //arr.reduce(callback,[initialValue]) //callback （执行数组中每个值的函数，包含四个参数） //1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue）） //2、currentValue （数组中当前被处理的元素） //3、index （当前元素在数组中的索引） //4、array （调用 reduce 的数组） //initialValue （作为第一次调用 callback 的第一个参数。） ``` 字符串方法 toLowerCase(): 把字符串转为小写，返回新的字符串。 toUpperCase(): 把字符串转为大写，返回新的字符串。 charAt(): 返回指定下标位置的字符 indexOf(): 返回某个指定的子字符串在字符串中第一次出现的位置 lastIndexOf(): 返回某个指定的子字符串在字符串中最后出现的位置。 slice(): 返回字符串中提取的子字符串。 substring(): 提取字符串中介于两个指定下标之间的字符。 split(): 把字符串分割成字符串数组。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/babel.html":{"url":"js/babel.html","title":"babel","keywords":"","body":"环境搭建和配置 需要的依赖@babel/cli、@babel/core、@babel/preset-env 配置.babelrc { \"presets\": [\"@babel/preset-env\"], \"plugins\": [] } 通过命令npx babel src/index.js来进行编译 presets为预设，plugins为插件 babel实则为一个空壳，它通过各种plugins来配置自己的编译，当经常使用的plugins过多，我们把它们打包成一个预设，在presets中设置 除此之外，我们可以在plugins中拓展自己想用的其他插件 常见的preset @babel/preset-env @babel/preset-react @babel/preset-typescript babel-polyfill 首先来了解一下，Polyfill，它是不定的意思。例如我们在使用indexOf方法。但在有些低版本浏览器中不支持此方法，所以它的polyfill就是一个他的补丁，即在不支持他的时候所作的代码处理 而任何人都可以写补丁，但是以谁的为准呢？所以便出现了一个官方的补丁集和，即为core-js。它里面包含所有的高级语法补丁（除了generator函数），它可以处理env中无法处理的es6特性。如果象处理generator函数，需要引用regenerator包。 而babel-polyfill就是core-js和regenerator的一个集合（现在已经不推荐使用） 注意，babel他的工作是编译语法例如箭头函数，而要解决新特性，例如使用数组新增includes方法或者promise等，就要使用core去进行兼容 我们可以这样配置core { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\":\"usage\", \"corejs\":3 } ] ], \"plugins\": [] } 这样配置后，编译后，他会为你自动添加require(\"core0js/modules/es.promise.js\")语句，他只是帮你添加了一个引入（按需引入），然后再通过打包工具将他们打包后，即可交给浏览器运行 babel-runtime babel-polyfill的实质无非是定义一个全局变量，例如 promise.resolve(100).then(data=>data) 它被编译完，只是在window上添加一个promise的方法 但是这样就污染了全局变量，所以为了避免污染全局变量，便有了babel-runtime { \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"usage\", \"corejs\": 3 } ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", { \"absoluteRuntime\": false, \"corejs\": 3, \"helpers\": true, \"regenerator\": true, \"useESModules\": false } ] ] } 它编译完是会把代码变为这样 _promise[\"default\"].resolve(100).then(function(data){return data})) 即不会污染全局变量 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"js/常见方法封装.html":{"url":"js/常见方法封装.html","title":"常见方法封装","keywords":"","body":"防抖、节流 const throttle = function (func, delay) { var timer = null; return function () { var context = this; var args = arguments; if (!timer) { timer = setTimeout(function () { func.apply(context, args); timer = null; }, delay); } } } function handle() { console.log(Math.random()); } window.addEventListener('scroll', throttle(handle, 1000)); function debounce(fn, wait) { // 使用闭包保存持久变量 var timeout = null; return function() { if(timeout !== null) // 如果持续触发，就把前面的定时器取消掉，这样来保证只有不触发事件时才开始计时 clearTimeout(timeout); timeout = setTimeout(fn, wait); } } // 处理函数 function handle() { console.log(Math.random()); } // 滚动事件 window.addEventListener('scroll', debounce(handle, 1000)); jsonp function msg(content){ alert(content) } function jsonp(req){ var script = document.createElement('script'); var url = req.url + '?callback=' + req.callbackName; script.src = url; document.getElementsByTagName('head')[0].appendChild(script); } jsonp({url:'http://www.domain.com/say', callbackName:msg}) // server.js let express = require('express') let app = express() app.get('/say', function(req, res) { let { callback } = req.query // 返回的内容是脚本的内容 res.end(`${callback}('I am server data')`) }) app.listen(3000) axios import loading from \"\" import error from \"\" let http=axios.create({ baseURL:'http://localhost:8080',//基本地址 timeout:1000,//超时时长 }) http.interceptors.request.use(config=>{ config.headers.token='' loading.show() return config },err=>{ error.show()//提示框提示请求错误 setTime(()=>{ error.hide() },2000) return Promise.reject(err) }) http.interceptors.response.use(res=>{ //操作 loading.hide() return res },err=>{ loading.hide() error.show() setTime(()=>{ error.hide() },2000) return Promise.reject(err) }) export default http 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"css/css布局.html":{"url":"css/css布局.html","title":"css布局","keywords":"","body":"居中布局 水平居中布局 text-align+inline-block .parent{ width:100%; height:200px; text-align:center; } .child{ width:200px; height:200px; display:inline-block; /* block:块级元素 inline:内联元素 width与height无效 inline-block:结合体 */ } table+margin .parent{ width:100%; height:200px; } .child{ width:100px; height:200px; display:table;/*block也可*/ margin:0 auto; } absolute+transform .parent{ width:100%; height:200px; position:relative; } .child{ width:100px; height:200px; position:absolute; left:50%; transform:translateX(-50%) } 垂直居中布局 table-cell+vertical-align .parent{ width:200px; height:600px; display:table-cell; vertical-align:middle; /*设置文本对齐方式top middle bottom*/ } .child{ width:200px; } absolute+transform .parent{ width:200px; height:600px; position:relative; } .child{ width:200px; position:absolute; /* 如果父元素开启定位，则相对父元素进行定位 如果父元素未开启定位，则相对底页面进行定位 */ top:50%; transform:translateY(-50%) } 居中布局 table-cell+margin+vertical-align .parent{ width:200px; height:600px; display:table-cell; vertical-align:middle; } .child{ width:100px; height:100px; display:block; margin:0 auto; } absolute+translate .parent{ width:200px; height:600px; position:relative; } .child{ width:100px; height:100px; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); } 多列布局 两列布局 左定宽，右面自适应 float+margin .right,.left{ height:300px; } .left{ width:300px; float:left; /*使用浮动以后，元素将脱离文档流*/ } .right{ margin-left:300px; } .right,.left{ height:300px; } .left{ width:300px; float:left; position:relative; /*有定位的元素显示层级高于一般元素*/ } .right-fix{ float:right; /*在设置float以后，默认宽度为0,且可以由子元素所撑起*/ width:100%; margin-left:-300px; } float+overflow .right,.left{ height:300px; } .left{ width:300px; float:left; } .right{ overflow:hidden; /* overflow将开启BFC模式，当前元素内部环境与外界完全隔离 在不加overflow属性时，right与left在一行，但right会覆盖left且长度为100%; */ } table+table-cell .parent{ width:100%; display:table; table-layout:fixed; /*列宽由表格宽度和列宽度设定*/ } .left,.right{ display:table-cell; } .left{ width:300px; } 三列布局 |-----------------| |-----------------| | | | | | | | | |-----------------| |-----------------| #left,#right,#center{height:300px} #left{float:left;width:200px} #center{float:left;width:200px} #right{margin-left:400px;} 圣杯布局 |-----------------| |-----------------| | | | | | | | | |-----------------| |-----------------| #left,#right,#center{height:300px} #left{float:left;width:200px} #right{float:right;width:200px} #center{margin-left:200px;margin-right:200px} #parent{height:300px;margin-left:300px;margin-right:300px} /*如果子代全是浮动元素，父级元素会出现高度坍塌现象*/ #left,#right,#center{ height:300px; float:left; } #left{ width:300px; margin-left:-100%; position:relative; left:-300px; } /*margin-left后移动到上一行的相同位置，开启定位，使用left纠正位置*/ #right{ width:300px; margin-left:-300px; position:relative; right:-300px; } #center{width:100%} 双飞翼布局 #parent{height:300px} /*如果子代全是浮动元素，父级元素会出现高度坍塌现象*/ #left,#right,#center{height:300px;float:left;} #left{width:300px;margin-left:-100%;} /*margin-left后移动到上一行的相同位置，开启定位，使用left纠正位置*/ #right{width:300px;margin-left:-300px;} #center{width:100%} #inner{margin-left:300px;margin-right:300px;} /*center虽然占满全行，但inner元素为真正使用的中间元素*/ 等分布局 将一行分为若干列，每一列占比相同 float实现 #parent{height:300px;} #col1,#col2,#col3,#col4{ height:300px; width:25%; float:left; } #parent{height:300px;margin-left:-10px;} #col1,#col2,#col3,#col4{ height:300px; width:25%; float:left; /*box-sizing:border-box使得padding的空隙为向内扩展，而非向外扩展*/ box-sizing:border-box; padding-left:10px; } table实现 #parent{display:table;width:100%} /*设置为table，默认width为0*/ #col1,#col2,#col3,#col4{ height:300px; display:table-cell; } #parent-fix{ overflow:hidden; } #parent{ display:table; width:1424;/*宽度为100%+10px*/ margin-left:-10px; } /*设置为table，默认width为0*/ #col1,#col2,#col3,#col4{ height:300px; display:table-cell; box-sizing:border-box; padding-left:10px } 等高布局 一行划分为若干列，每列高度相同 使用table dhkadhwkjhdkahwdkhkawj ewrqewrdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjwer /*基于table的默认设置，单元格默认是等高的*/ #parent{display:table} #left,#right{width:300px;display:table-cell;} 使用padding+margin (伪等高布局) dhkadhwkjhdkahwdkhkawj ewrqewrdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjdhkadhwkjhdkahwdkhkawjwer #parent{overflow:hidden;} #left,#right{ width:300px; float:left; padding-bottom:9999px; margin-bottom:-9999px; } 多列布局 一行多列，每列元素等宽 #parent,#parent2{ column-count:4;/*有多少个子元素*/ column-width:300px;/*子元素宽度*/ /*column:4 300px;*/ column-gap:15px;/*设置间隙大小*/ column-rule:5px red double;/*设置间隙边框效果 */ } #col1,#col2,#col3,#col4{ column-fill:balance/*设置高度 auto根据内容自适应，balance根据内容最多的一列为准*/ } #col5{ column-span:all;/*横跨所有列*/ } 全屏布局 全屏布局 html页面铺满整个浏览器窗口，有滚动条 |-----------------------------| -->定长自适应宽 |-----------------------------| | | | | | | -->（左）自适应长定宽、 | | | （右）自适应长自适应款 | | | |-----------------------------| |-----------------------------| -->定长自适应宽 html,body{margin:0;overflow:hidden;} header{ height:100px; position:fixed; top:0; left:0; right:0; } .content{ position:fixed; top:100px; bottom:100px; left:0; right:0; overflow:auto; } .content .left{ width:300px; height:100%; position:fixed; left:0; top:100px; bottom:100px; } .content .right{ margin-left:300px; } footer{ height:100px; position:fixed; bottom:0; left:0; right:0; } 视觉差布局 什么是视差滚动效果，如何给每页做不同的动画？ 视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验 一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的 实现原理 以 “页面滚动条” 作为 “视差动画进度条” 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果 css实现图片不滚动 css视差滚动 body, html { height: 100%; margin: 0; padding: 0 } .box { height: 100%; position: relative; z-index: 1; } .flowImage { position: relative; height: 500px; background-size: cover; background-repeat: no-repeat; background-position: center center; z-index: 1; background-attachment: fixed; } .flowImage>p { margin: 0; /* position: absolute; */ position: relative; top: 50%; left: 10%; color: #31202f; font-size: 30px; transform: translate(-10%, -50%); } .bg1 { background-image: url(images/4.png); } .bg2:nth-child(2) { background-image: url(images/1.png); } .bg3:nth-child(3) { background-image: url(images/3.png); } .bg4:nth-child(4) { background-image: url(images/4.png); } .bg5:nth-child(5) { background-image: url(images/2.png); } .bg6:nth-child(6) { background-image: url(images/1.png); } lalal lalal lalal lalal lalal lalal 元素岁鼠标方向轻微移动 网格布局 容器本身的属性 display grid：块级盒子 grid-inline：行级盒子 grid-template-cloumns,grid-template-rows 100px 1fr：fr可以自适应剩下的空间 repeat()：重复次数repeat(3, 33.33%) auto-fill：单元格固定大小，容器不确定，但尽可能容纳多的单元repeat(auto-fill, 100px) minmax()：长度范围的最小值和最大值minmax(100px, 1fr) auto：由浏览器自己决定长度 grid-gap 行间距、列间距 grid-template-areas 自行设定位置 .contain{ grid-template-areas: \"fw . . . .\" \"dz rz yyr zs jl\" \"lx rz yyr zs jl\" \"cc . . . .\"; } .fw { grid-area: fw; color: gray; } .dz { grid-area: dz; } .lx { grid-area: lx; } .cc { grid-area: cc; } .rz { grid-area: rz; } .yyr { grid-area: yyr; } .zs { grid-area: zs; } .jl { grid-area: jl; } grid-auto-flow 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是\"先行后列\"，即先填满第一行，再开始放入第二行。 column：先列后行 row ：先行后列 row dense：紧密填满，尽量不出现空格 justify-items(水平),align-item(垂直),place-items(结合) 项目的子元素在项目这个容器的位置 start：项目的内容对齐起始边缘 end：项目内容对齐结尾边缘 center：项目内容居中 stretch：项目内容拉伸 justify-content,align-content,palce-content 所有项目占容器的位置 start：对齐容器的起始边框 end：对齐容器末尾边框 center：容器内部居中 stretch：拉伸占满 space-around：每个项目两侧间隔相等，项目之间的间隔比项目容器的间隔大一倍 space-between：项目之间间隔相等，项目与容器无间隔 space-evenly：项目之间、项目与容器之间间隔相等 grid-auto-columns,grid-auto-rows 一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。该属性指定多出来项目的大小 设置项目属性 grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性 项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 .item-1 { grid-column-start: 2; grid-column-end: 4; } grid-column,grid-row grid-column:1/3等同于grid-column-start:1,grid-clumn-end:3 justify-self 属性， align-self 属性， place-self 属性 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 弹性盒子 容器属性 flex-direction —— 定义子元素在主轴的排列方式 row：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap —— 定义子元素在一条轴线排不下时如何换行 nowrap ：默认值。规定灵活的项目不拆行或不拆列。 wrap ： 规定灵活的项目在必要的时候拆行或拆列。 wrap-reverse ： 规定项目在必要的时候以相反的顺序拆行或拆列。 justify-content —— 定义子元素在主轴的对齐方式 align-items —— 定义子元素在纵轴上的对齐方式 项目属性 flex-grow ——定义项目的放大比例 flex-grow: number ; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间。 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink ——定义了项目的缩小比例 flex-shrink: number flex 元素仅在默认宽度之和大于容器的时候才会发生收缩。 如所有项目的 flex-shrink 属性都为1，当空间不足时，将等比例缩小。如一个项目的 flex-shrink 属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis ——定义了在分配多余空间之前，项目占据的主轴空间 flex-basis: number | auto ; number：长度单位或者百分比，规定灵活项目的初始长度。 auto：默认值。长度等于灵活项目的长度。如果该项目未指定长度，则长度将根据内容决定。 flex —— flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，后两个属性可选 flex-basis: number | auto 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 flex: 1 ; 所有项目等分剩余空间。 css相关知识 实用属性 { width:calc(100%-120px); /*使用计算的方式得到宽*/ background-attachment: fixed;/*是背景图不随滚轮滑动而滚动*/ } 常见尺寸 px：最常用的也是最基本的单位就是px，表示占多少像素值。页面默认是16像素。 em：em也是经常用到的单位，一般用在字体上。它的大小由父元素决定。如果父元素的字体大小是20px，那么子元素中1em = 20px。 rem：rem是做移动端适配必不可少的。它是根据html根元素的大小决定的。例如在html{font-size:12px}的前提下，div设置font-size{1.5rem}此时div的下字体的大小为12*1.5=1818px。 fr：css fr 单位是一个自适应单位，fr单位被用于在一系列长度值中分配剩余空间，如果多个已指定了多个部分，则剩下的空间根据各自的数字按比例分配。例如 .grid { display: grid; grid-template-columns: repeat(4, 1fr); grid-column-gap: 10px; } 这样写后，实际格子的宽度占比为总宽度减去间隔的10px后进行一比一分配 vh/vw：用来做适配也是非常的方便。1vw就等于/页面宽度的1%。高度也是如此。 vmin/vmax：1vmin是获取页面宽度和高度中较小的一个值的1%，1vmax则是获取较大的一个值的1%。 ch/ex：ch表示当前字体下，0字符的高度。ex表示当前字体下x字符的高度。所以这两个单位的大小由字体大小和字体类型决定。 盒子模型 content-box：默认值，总宽度 = margin + border + padding + width border-box：盒子宽度包含 padding 和 border，总宽度 = margin + width inherit：从父元素继承 box-sizing 属性 格式化上下文（Formatting Contexts即FC） 例如一个ifc并不是指的是一个行内元素，而是只可能由很多个行内级元素共同组成的一个上下文。 BFC 块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 BFC)。产生 BFC 方式如下： float 的值不为 none。 overflow 的值不为 visible。 position 的值不为 relative 和 static。 display 的值为 table-cell, table-caption, inline-block中的任何一个 BFC的布局规则如下： 内部的盒子会在垂直方向，一个个地放置； 盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠； BFC的区域不会与float重叠； BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此； 计算BFC的高度时，浮动元素也参与计算 常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行 IFC 内联格式化上下文，IFC 的 line box（无形的线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。 IFC中的line box一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同。 IFC中是不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个p与 div 分隔开，即产生两个 IFC ，每个 IFC 对外表现为块级元素，与 div 垂直排列。 用处如下： 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中 布局规则： 在一个IFC中，从父级元素的顶部开始，盒子一个接一个横向排列 一个line box总是足够高对于包含在它内的所有盒子。然后，它也许比包含在它内最高的盒子高 当盒子的高度比包含它的line box的高度低，在line box内的盒子的垂直对齐线通过'vertical align'属性决定 当在一行中行内级盒子的总宽度比包含他们的line box的宽度小，他们的在line box中的水平放置位置由'text align'属性决定 当一个行内盒子超过了line box的宽度，则它被分割成几个盒子并且这些盒子被分配成几个横穿过的line boxs GFC 网格布局格式化上下文 display: grid FFC 自适应格式化上下文 display: flex 区分概念 块级元素： 块级元素是那些视觉上会被格式化成块状的元素，通俗一点来说就是那些会换新行的元素。例例如：display属性为block, list-item, table, flex, grid 块元素： 块元素是 display 属性值为 block 的元素，它应该是 块级元素 的一个子集 行内级元素： 行内级元素是那些不会为自身内容形成新的块，而让内容分布在多行中的元素。 例如：display属性为inline, inline-table, inline-block, inline-flex, inline-grid。 行内元素： 行内元素仅仅是display属性值为inline的元素。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"css/sass介绍与使用方法.html":{"url":"css/sass介绍与使用方法.html","title":"sass介绍与使用方法","keywords":"","body":"sass笔记总结 安装sass 为了在我们的电脑上能够使用sass，我们首先需要安装ruby（ 一种简单快捷的面向对象（面向对象程序设计）脚本语言 ），通过ruby中所带的gem去安装sass。 ruby在官网即可下载，但下载速度极慢，请耐心等待，也可以私信笔者以分享网盘。（以window为例）ruby下载完成后我们，我们可以再终端输入ruby -v来查看版本信息。 由于gem默认下载太慢，我们修改为淘宝镜像下载，gem -d https://gems.ruby-china.com/ 然后我们通过gem来下载，gem install sass 以上用到的命令，总结如下 ruby -v ##查看ruby的版本 gem -v ##查看gem的版本 gem souces --remove https://rubygems.org/ ##删除默认的下载路径 gem souces -d https://gems.ruby-china.com/ ##添加淘宝的下载路径 gem souces -l ##查看目前添加的下载路径 gem updata ##更新新版本的ruby内容 gem install sass ##下载sass gem install sass --version=3.3 ##下载3.3版本的sass gem uninstall sass --version=3.3 ##删除3.3版本的sass gem list ##查看所有下载的ruby包 sass -v ##查看sass版本信息 使用sass 在文件夹下创建一个.sass文件，通过`sass .sass *.css`可以将其转变为css文件。 当然我们在真正项目开发中，我们不会直接使用sass，而是通过工具来创建并使用sass，这里我们介绍一个工具叫compass。 通过gem install compass来下载compass。我们通过compass create project-name来创建一个项目目录。 目录下有三个文件或目录，sass文件为你书写sass文件的地方，stylesheets文件为生成的css文件的地方，config.rb是一些配置信息。 进入sass目录，我们将在screen.sass文件中进行编码。 在此之间，我们在项目目录下的终端执行compass watch来实时监听文件变化，当你在sass目录下书写代码时，代码会自动转为css样式并存储到stylesheets文件中。 scss与sass作用相似，而且可以相互转换，为了方便，我们一下统一以scss的语法来教学。 以上用到的命令，总结如下 sass a.sass a.css ##将a.sass文件转为a.css文件并输出 sass-convert a.sass a.scss ##相互转化sass格式与scss格式 compass create project_name ##常见compass项目目录 compass watch ##监听项目目录 scss语法与使用 scss基本用法 注释：/**/与//皆可以 变量：$headline-ff 引入文件：import “file_path” if语句：@if 条件 {执行体} 函数：@functions name(parms) {}; @mixin name(parms) {} 常用方法：@at-root 代码展示 _variables.scss文件 加了下划线，声明为局部文件，在生成css文件时会忽略此文件 //演示声明变量 $headline-ff : Arial; _mixin.scss文件 //演示函数定义 @mixin col($width:30%) { width:$width; } @mixin col-6() {//函数中有类名的，在调用后会直接生成里面的类 .col-6{ width:30%; } } @mixin col-sm($width:50%) { @if type-of($width)!=number{ @error \"输入的不是数值类型\" } @if not unitless($width){ @if unit($width)!=\"%\" { @error \"输入的单位不是百分值\"; } } @else { @warn \"输入得不是百分值\"; $width:(percentage($width)/100); } @media(min-width:768px){ width:$width; float:left; } } screen.scss文件 宿主文件 //文件简单文档 /** *CONTENTS * *SETTINGS *variables-----------变量几种存储文件 *mixin---------------mixin几种存储文件 * *TOOLS * *COMPONENTS *reset----------------component内置浏览器重置样式文件 * *BUSINESS * *BASE *screen.scss-----------针对当前站点主页的样式修饰 */ /*! *加一个叹号可以不被压缩 */ //引入文件 @import \"variables\",\"mixin\"; //演示变量的使用 .main{ font-family:$headline-ff; } //样式可以嵌套,在main-sec中headline的样式 .headline{ font-family:$headline-ff; } .main-sec{ .headline{ font-family:$headline-ee; color:blue; } &:hover{ color:red; } } //内置函数的使用 p{ color:hsl(270,100%,50%)//在转化css文件时，转化为#加十六进制的格式，解决了有些浏览器不支持hsl格式的问题 } //使用自定义函数@include @include col-6() div{ @include col(70%); } //继承代码块@extend .err{ color:red; } .serious-err{ @extend .err; border:1px blue; } 注意点 @import 此处的import是将css中的import重新定义的，与其有所差异 css中的@import中的弊端有如下： 1、必须放在最前面否则不起作用 2、对性能不理，例如A引入了B，只有当加载A时，读取到了import时，才会去读取B，这样浏览器处于堵塞状态，延长了渲染时间。 scss中，@import可以写在任何地方，且会在转化成css文件是将引入文件合并到主文件中。 但是在scss中仍可以使用css3定义的import，在以下情况时会选择使用c3的import： 1、当@import后面跟的文件名以css结尾时 2、当@import后面跟的是http：//开头的时候 3、当@import后面跟的是一个url（）函数的时候 4、当@import后面带有media queries的时候 注释 以/**/注释的还会显示在生成的css文件中 而//注释的不会 &:hover a{ &:hover{ color:red; } } 如果不加&，转化完是为a所有字标签添加了这个伪类选择器。 函数 scss分为两种函数： 1、functions，与代码块无关的函数，多是自己的内置函数 2、mixin，可重用的代码块，一部分通过@include的方式调用，一部分通过@extend的方式调用 @extend 1、extend不可以继承选择器序列 //该写法为错 .A .B{ color:red } .C{ @extend .A .B } 2、用%制作只用于继承的代码块 %err{ color:red; } .serious-err{ @extend .err; border:1px blue; } 这样在转化为css后没有.err这个类及其样式 media scss中的media与css中的media也有一同，scss中的media可以内嵌在css规则中在生成css的时候，media才会提至最外层 输出格式的样式 设置config.rb配置文件 output_style=:expanded默认输出演示 output_style=:compressed输出压缩样式 at-root scss中有很强大的嵌套功能，例如 .a{ .b{} } 而他在转化为css文件时的输出为 .a .b{} 浏览器解析css的方式是从右向左的，拿上述例子为例，浏览器会先去找到类名为b的元素，然后一层一层遍历看看有没有叫c的父元素，这样使得性能变差。 所以，最佳的办法为如下 .a{ @at-root{ .b{} } } 这样转化为的css文件为 .a{} .b{} compass简介 compass可以理解为，他为你预先定义好了很多样式，你可以直接通过函数调用的方式来去设置一个类的样式。 compass在sass基础上，构建了一下几大模块。 reset浏览器样式重置模块 Layout提供页面布局样式 css3跨浏览器的css3能力 Helpers与Utilities不同的是他的函数多为mixin函数 Utilities其他 Typography主要修饰文本样式，垂直韵律 browser设置默认支持哪个浏览器甚至版本 当然，除了这 内置的几大模块外，我们还可以下载第三方模块，例如normalize gem install compass-normalize 下载完成后，我们可以直接在config文件中配置引入。例如 require 'compass-normalize' 然后再scss文件中引入使用 @import 'normalize' 每个模块都用很多用法，在这里不一一列举，可以通过去查文档去使用 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"HTML/使用canvas画多边形.html":{"url":"HTML/使用canvas画多边形.html","title":"使用canvas画多边形","keywords":"","body":"使用canvas画三角形、多边形、五角星 canvas { border: 1px solid red; } 你的浏览器不支持canvas (function () { CanvasRenderingContext2D.prototype.triangle = function (x1, y1, x2, y2, x3, y3) { this.moveTo(x1, y1); this.lineTo(x2, y2); this.lineTo(x3, y3); this.closePath(); this.stroke(); // console.log(this); }; CanvasRenderingContext2D.prototype.polygon = function (x, y, r, n) { //补全代码实现多边形的绘制 //其中x为中心点x坐标，y为中心点y坐标，r为半径，n为多边形边的数量 var XCoordinate = [];//存储所有点的x坐标 var YCoordinate = [];//存储所有点的y坐标 var xc1,xc2; this.beginPath(); for (let i = 0; i 复制请改变量~ 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"git/git版本回溯.html":{"url":"git/git版本回溯.html","title":"git版本回溯","keywords":"","body":"当我们从远程仓库将master下载到本地后，你每使用一次commit将代码提交到版本库后，你的文档就会被记录、保存。比如我写了一个a.txt文件，内容为‘111’，然后git add，git commit后修改了它，内容为‘222’，然后又 git add，git commit，随后又把内容修改了，改为‘333’。 某一时刻，我突然想到，我真正想要的内容是‘111’，那么，我可以通过git log命令查看我所有的提交命令。 commit d840a16c0a3819d3da16c16ac75aa5abfe06afa9 Author: xwx Date: Tue Sep 10 15:51:05 2019 +0800 ok commit b1156ffd26a5413a2cde0c704717b7a1f5954cd0 Author: xwx Date: Tue Sep 10 15:50:52 2019 +0800 ok commit 03469dcb1904fadacbd48de5171bf5249a9e6319 Author: xwx Date: Tue Sep 10 15:50:17 2019 +0800 ok 能看到我提交了三次，并在commit后面对应着一个码，我想退回第一次提交那么 git reset --hard 03469dcb1904fadacbd48de5171bf5249a9e6319 那么文件内容就变回‘aaa’了。 当然git所记录的不只是你的文件内容，也包括目录，比如你第一次提交时，库中还有两个文件目录，之后删除了，当退回版本时，这两个被删除的文件目录也会回来。 通过上面的例子，我们了解了git每一次的提交，都是被记录下来的，我们也可以随时回到某一个版本。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"git/更改git账号时无法上传文件.html":{"url":"git/更改git账号时无法上传文件.html","title":"更改git账号时无法上传文件","keywords":"","body":"更改git账号时可无法上传文件（git commit之前操作正常，git push就报错） 最近新注册了一个git账号，在原来电脑上使用时，每当到了git push是就显示 Fatal: HttpRequestException encountered. ▒▒▒▒▒▒▒▒ʱ▒▒▒▒ remote: Permission to 7badggb/7badggb.io.git denied to xiaweixuan. fatal: unable to access 'https://github.com/7badggb/7badggb.io.git/': The requested URL returned error: 403 xiaweixuan是我之前的git账号 始终没搞明白为什么会被之前账号拒绝，翻阅众多资料后突然明白，在最早的时候，当时设置了保存密码，所以每次git push时，他会自动输入之前保存的密码，我们要做的是删除之前电脑保存的密码。 git通常有两种模式，cache模式和store。 store模式会将密码写入磁盘，永远不会过期。而cache模式则是将密码写入内存，15分钟后自动清除。 所以我们只需要将其改回cache模式，只需输入 git config --global credential.helper cache 稍等片刻，重新git push即可 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"git/如何使用git分支团队合作解决问题.html":{"url":"git/如何使用git分支团队合作解决问题.html","title":"如何使用git分支团队合作解决问题","keywords":"","body":"git分支的理解 git之所有受广大开发人员欢迎，其原因之一就是因为他强大的分支功能，那么分支到底是怎样一个功能呢，接下来向大家介绍。 首先大家可以了解一下git的版本回溯这一功能，在此基础上，接下来我们来说分支。 我们常常使用的master就是一个默认分支，只不过我们每次在创建的时候没有改名字，都使用‘master’这个默认的名字。大家可以以平行宇宙的概念去理解分支，刚刚进入了分支，他的东西和主干的上的东西是完全一样的，但是你在分支中的操作却完全不会影响主干的东西。直到某一刻，你把分支合并到主干中，这样主干就会和分支的内容完全相同了。所以，分支常常是我们探索未知的好途径。 分支是如何实现的呢 比如我们发布一个项目，项目要不断的优化，我们将它上传到github上面，每提交一次，github都会记录下来你的提交，例如我们最早开发了版本v1，之后完善了一下再次提交称为v1.1版本，再完善、上传作为v1.2版本，每次上传后，git所呈现给我们的都是最新的，但其实，每一次上传的记录都被保存，我们随时可以调出来看，只不过git默认把最新一次展现给我们。我们将上述描述画成图像来呈现给大家： 这个时候我们先要开发v2版本了，但是github是开源社区，任何人都可以下载你的代码，如果这个时候别人在使用你的代码，你如果将为完成的代码上传就会造成别人用了你错误的代码。那么怎么办呢，可以用git的分支解决。 别人会默认下载你主分支上的代码，所以你可以创建一个分支去修改你的代码，当代码彻底修改好以后，在合并到主分支。这样在你眼中，代码是在不断修改的，但在其他人眼中，只有每次修改完善后的代码。 所以我们创建一个分支比如叫foo，我们在他的上面提交，直至修改完成。 这个时候我们可以发现，每个版本依旧会存储在github上面，只不过每个分支的指向不同，master分支始终指向v1.2版本，但是foo已经指向了版本v2.2，这个时候修改完后，我们在将foo合并到master，这样master呈现的也变成了v2.2 这个时候再把foo删除，我们就可以再不影响他人使用的情况下，完成了项目的修改与上传。 团队如何使用git分支开发项目 git有四种常见的工作模式，也就是四种工作流。他们分别是==集中式工作流==，==功能分支工作流==，==gitflow工作流==，==forking工作流==。 其中==功能分支工作流==是在==集中式工作流==基础上加以丰富，==gitflow工作流==又是在==功能分支工作流==基础上加以丰富的，前三种多用于某一集体的一个项目，而==forking工作流==多用于开源社区上的项目研发。所以，在本章文章中，主要详细介绍一下==集中式工作流==，和==功能分支工作流==的流程。（gitflow和forking工作流笔者会在后续文章中说明） 集中式工作流 集中式工作流比较简单，他只有一条分支。开始，队伍的所有成员将远程库clone下载到本地，假设有p1和p2两个人分别是队中的成员，之后他们分别对库中的文件作出了更改，如图： 假设p1对项目增加了一个文件a.txt，然后push到了远程仓库,p2也对其更改了两回。第一次增加了文件b.txt，第二次增加了c.txt。当p2想要push到远程仓库的时候，是会报错的，因为远程仓库现在的内容已经和你刚刚clone下来的内容不一样了（因为p1对其提交了a.txt），这个时候如果你能提交上去，那将会覆盖p1的提交。那么这个时候我们要先将远程上的东西git pull下来，再进行git push。如果中途出现vim文档可直接输入:wq退出就好。 当然如果说p1和p2下载到本地后修改的是同一个文件，那这个时候就是不单纯的git pull能解决的了，那个我们还在稍后的冲突问题中讲解 功能分支工作流 这个是在前一个工作流的基础上的，功能分支工作流是将整个项目放在主分支上，每当你想要为你的项目增加一个功能，那么开出一个分支，在分支上去做，等功能写好以后，在合并到主分支上。在这个过程中在功能分支上做任何事情是不会干扰到主分支的，与此同时其他人可以同时更改项目的其他内容而互不干扰。 接下来展示一下具体的工作流程。 1）每个人下载全部的远程仓库 2）下载后在本地创建一个功能分支，将分支提交到远程 3）修改分支内容，提交 4）将分支内容合并到主分支 git分支的操作指令 以功能分支工作流为例，给大家介绍一下全程的指令。 第一步将远程仓库的库克隆大本地 $ git clone https://github.com/xiaweixuan/test.git Cloning into 'test'... remote: Enumerating objects: 6, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 6 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. 下载后可以查看一下文件，这时候用linux的命令进入文件并查看就可以，也可以直接在文件夹中点击 $ cd test $ ls a.txt b.txt 可以看到有a.txt b.txt两个文件，假设这就是我们的一个项目。记下来我们要对项目进行操作，要注意的是如果你没有使用上述命令进入test文件夹，那么你要关掉git bash窗口，去test文件夹里重新git bash here 假设现在的项目需要我们添加一个新功能，因为新功能我不知道写完能不能用，如果在原先的代码上写，写完后发现写的不对，那么原来的代码就相当于也被毁了，所以这个时候我们创建分支 $ git branch foo $ git checkout foo Switched to branch 'foo' 上面分别是创建分支foo和进入分支foo，可以用git branch查看当前分支 $ git branch * foo master 上图显示了本库所有分分支，并在当前分支上用*标记上了。 现在我们所在的就是foo分支了，也就可以大胆的去写代码了。我们在b.txt文件中加上几句话表示我们写了一个新功能，这个时候我们可能中途有事，需要把这个分支保存并上传到远程仓库，以免代码丢失。 $ git add . $ git commit -m 'foo分支的第一次上传' [foo 6709aa1] foo分支的第一次上传 1 file changed, 4 insertions(+), 1 deletion(-) $ git push -u origin foo Fatal: HttpRequestException encountered. ▒▒▒▒▒▒▒▒ʱ▒▒▒▒ git: 'credential-cache' is not a git command. See 'git --help'. Username for 'https://github.com': xiaweixuan git: 'credential-cache' is not a git command. See 'git --help'. Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 311 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for 'foo' on GitHub by visiting: remote: https://github.com/xiaweixuan/test/pull/new/foo remote: To https://github.com/xiaweixuan/test.git * [new branch] foo -> foo Branch foo set up to track remote branch foo from origin. 这样就把你在本地的分支上传到了远程仓库，可以再github上查看。 接下来我们可以继续修改本地项目，比如再加一个c.txt，然后上传。 $ git add . $ git commit -m '再一次修改' [foo c05004a] 再一次修改 1 file changed, 1 insertion(+) create mode 100644 c.txt $ git push Fatal: HttpRequestException encountered. ▒▒▒▒▒▒▒▒ʱ▒▒▒▒ git: 'credential-cache' is not a git command. See 'git --help'. Username for 'https://github.com': xiaweixuan git: 'credential-cache' is not a git command. See 'git --help'. Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 327 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/xiaweixuan/test.git 6709aa1..c05004a foo -> foo 终于我们的项目写完了，并且没有任何错误，那么现在面临的问题就是将foo分支合并到主分支，然后删除foo分支。 因为github是多人合作平台，合并后，主分支将会被分支内容覆盖，所以要谨慎，必须经过小组中所有人批准 点击foo分支后面的 Compare&pull request 的绿色按钮，然后出现下图 在里面写上对本次分支的描述，然后点击 create pull request 接下来就是等待其他人的同意，同意后就会自动将foo分支合并到主分支上。 然后再github上删除foo分支。 然后在本地切换到master删除foo分支 $ git checkout master Switched to branch 'master' Your branch is up-to-date with 'origin/master'. $ git branch -d foo warning: deleting branch 'foo' that has been merged to 'refs/remotes/origin/foo', but not yet merged to HEAD. Deleted branch foo (was c05004a). 利用 git pull将远程上主分支的内容拉取下来 $ git pull remote: Enumerating objects: 1, done. remote: Counting objects: 100% (1/1), done. remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (1/1), done. From https://github.com/xiaweixuan/test 43fb1df..d475bb4 master -> origin/master Updating 43fb1df..d475bb4 Fast-forward b.txt | 5 ++++- c.txt | 1 + 2 files changed, 5 insertions(+), 1 deletion(-) create mode 100644 c.txt 这样利用分支去写功能块就结束了。 git冲突问题的讲解 在团队合作的时候难免会有pull不下来或者push不上去的情况，这个时候证明你遇到了冲突问题。 举个例子，你们团队在使用集中式工作流的时候，还是这个图 假设两个人把仓库下载下来时，就有一个文件a.txt。这个时候p1的任务是修改a.txt（内容修改为‘p1的修改’）,修改后上传了，p2的任务是写b.txt，写完后，p2突然发现，a.txt写的有点不对吧，于是p2也修改了a.txt（修改内容为‘发现了bug’），然后git push，结果发现报错无法上传。和之前一样，我们要先pull一下，但是这个时候，就不会像之前那样简单了。因为同样是a.txt文件，远程的是一个内容，而本地的已经被p2修改成另一个内容了，这个时候a.txt的内容就发生了冲突，那要怎么办呢，接下来，我们实施一下。 $ git push Fatal: HttpRequestException encountered. ▒▒▒▒▒▒▒▒ʱ▒▒▒▒ git: 'credential-cache' is not a git command. See 'git --help'. Username for 'https://github.com': xiaweixuan git: 'credential-cache' is not a git command. See 'git --help'. To https://github.com/xiaweixuan/test.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'https://github.com/xiaweixuan/test.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 作为p2，我们发现自己push的时候报错了，这个时候我们已经知道是因为p1修改了a.txt文件，这个时候我们这么输入 $ git pull --rebase remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From https://github.com/xiaweixuan/test 9ce584b..939bb69 master -> origin/master First, rewinding head to replay your work on top of it... Applying: ok Using index info to reconstruct a base tree... M a.txt Falling back to patching base and 3-way merge... Auto-merging a.txt CONFLICT (content): Merge conflict in a.txt error: Failed to merge in the changes. Patch failed at 0001 ok The copy of the patch that failed is found in: .git/rebase-apply/patch When you have resolved this problem, run \"git rebase --continue\". If you prefer to skip this patch, run \"git rebase --skip\" instead. To check out the original branch and stop rebasing, run \"git rebase --abort\". 这个时候我们进入了修复模式，我们去文件夹里打开a.txt发现内容改变为这样 git用>>区分开了文件不同的地方，你要自己去修改，比如我们只想让‘发现了bug’这句话保留，就他其他的都删掉，操作完以后我们继续去命令行 $ git add . $ git rebase --continue Applying: ok 这样就退出了修复模式，然后git push $ git push Fatal: HttpRequestException encountered. ▒▒▒▒▒▒▒▒ʱ▒▒▒▒ git: 'credential-cache' is not a git command. See 'git --help'. Username for 'https://github.com': xiaweixuan git: 'credential-cache' is not a git command. See 'git --help'. Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 266 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/xiaweixuan/test.git 939bb69..3b584f7 master -> master 至此，冲突修复完成 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"git/github仓库关联及常用命令.html":{"url":"git/github仓库关联及常用命令.html","title":"github仓库关联及常用命令","keywords":"","body":"git 本文会介绍两种创建git项目的情况： 1、你在本地有一个文件，你想要把他定义为git仓库并上传 2、即在github创建一个新仓库并关联到本地。 此外还会向git初学者介绍一些常用命令。我会在代码的旁边注释，帮助一些新手更好的去理解这些命令。。 开篇：在此之前大家需要对git有一定的了解 github是一个远程仓库，你可以将你的代码寄存到上面，可以让大家看到或下载，也可以起到保存代码的作用。那么如何实现这些呢？当你在github创建一个仓库后，你需要在本地也创建一个与其对应的仓库，然后将这两个仓库关联，之后在本地仓库操作，结束后再将本地仓库同步到远程仓库就ok了。那么首先大家面临的第一个问题就是，如何将两个库同步呢？一些初学者会搞不清，是先在本地创建库还是必须现在gibhub上创建呢，其实是都可以的，本片文章就对其问题进行详细解读。 首先了解一些小知识点， 要保证远程库与本地库一对一关联，git支持https和git两种传输协议。https传输需要传输时输入你的密码和账号（也可以设置记住密码），而git传输则不用，他需要你生成对应的公钥和秘钥，通过对接秘钥来确保库的一对一传输，而这种方法，并不需要你每次输入密码。 最一开始，我们要做的便是将本地的文件夹与远程库关联起来 一、关联库（将本地已写文件定义为git库并上传） 1）通过https关联 如果你在本地已经写好了一个文件夹demo，想把名为demo中的文件上传到远程仓库，但远程仓库中并没有名为demo这个文件，那么如何在远程仓库新建一个文件夹（在远程仓库创建文件夹不再教学，要关联的两个库名字可以不同）并与本地的关联呢？ 首先来到你的demo文件夹中，（注意是要进到本文件夹中）右击点击git bush here输入 git init 这样就将改文件夹初始化为一个git库了，然后将它与远程库关联 git remote add origin +远程库地址 注意，在复制地址时，要选择复制https的地址，即链接成功 2）通过ssh关联（只需关联一遍，如果已通过https关联忽略本步骤） 首先同样在你想要作为远程仓库的文件夹中有键打开git bash here，输入 git init 此后你需要创建秘钥在本地 $ ssh-keygen -t rsa -C \"这里输入你的git邮箱\" 中途会有提示，可以一路回车，生成结束后，需要查看生成的公钥 $ cat ~/.ssh/id_rsa.pub 之后会出现以ssh-rsa 开头，你邮箱结尾的一大串字符，把他们全部复制，然后打开你的git点击右上角头像，点击settings，在左面一栏里点击‘ssh and gpg keys’添加ssh，随便起个标题将刚刚复制的黏贴到下面。这样你的本地库就与该账号关联了。 git remote add origin +远程库地址 这个时候要复制你远程库的ssh链接，这样就将你的本地库与远程库链接完成了。 二、关联库（将网上的git库下载到本地） 下载是比较简单的，只需找到想要保存的地方，git bash here，然后输入 git clone +https地址 这样就可以将网上的库下载下来 三、操作 首先如果远程仓库的代码有改动想下载到本地输入（新建库的可以忽略此步骤） git pull 若此时库中的数据不是最新则无法push到远程仓库需要先pull。 git add . 注意 . 和add之间是有空格的，此命令表示，将本文件夹中的所有文件更改到缓存区（所有要上传的文件必须先传到缓存区，再到版本库，最后才能传到远程仓库），也可以将 . 改为具体的文件名，代表只上传某个文件。 ps：空文件夹是无法上传的 然后输入 git commit -m '备注信息' 此时将缓存区的文件传到版本库，' '中填写备注信息，可以为任何内容 git push -u origin master 将版本库中的代码上传到远程仓库 自此git操作结束 四、git操作中遇到的问题 1）多人使用同一个仓库，如果别人上传了数据上去，而我已经在本地修改了我的代码，此时git pull，是否会将我所写的代码覆盖？ 答案肯定是不会的，带文件中，会使用============将新旧代码分割开，来保证代码不会丢失 2）万一我不小心git pull导致我的代码丢失怎么办? git commit 后的代码为什么说在版本库，是因为我们每次git commit提交后，都会保存在我们的电脑中，如有特殊情况，可以将本地退回之前某次git commit提交到版本库的代码 git log 查看版本库，每个版本对应的有一大串字符在commit后面，将它复制， git reset --hard +复制的一大串字符 最后，在git使用中，还是有一大堆坑的，笔者也会在日后对一些常见问题作出解答，如若有误，欢迎指正。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/react复习总结.html":{"url":"web前端/react复习总结.html","title":"react复习总结","keywords":"","body":"框架使用 基本使用 变量表达式 {this.state.data} 在vue中使用：的属性为动态属性，而在react中直接使用{}即可 class style ha'}> 条件判断 render(){ const btn1=1 const btn2=2 return { tag ?btn1:btn2 } } 列表渲染 return { this.state.list.map((item,key)=>{ return {item.title} }) } bind this this.clickhandler=this.clickhandler.bind(this) clickhandle1r=funciton(){ console.log(this)//如果不进行bind绑定，this为undefined } clickhandler2=()=>{ console.log(this)//静态方法中指向正确 } return return event参数 react中的事件对象是封装过的 event是SyntheticEvent示例，模拟出dom事件所有能力 所有事件都被挂在到document上了 return clickhandler3=(e)=>{ console.log(e.target)//指向触发元素 console.log(e.currentTarget)//指向绑定事件的元素 console.log(e.nativeEvent)//原生事件对象 console.log(e.nativeEvent.target)//指向触发元素 console.log(e.nativeEvent.currentTarget)//指向绑定事件的对象 } 表单 受控组件 changeEvent=function(e){ this.setState({ name:e.target.value }) } 非受控组件 见高级特性 组件传值 vue中组件传值，父向子传值，子触发事件，父接受事件 而react中，父向子传值，父向子传函数，在函数中该百年父的值 //props传递值 //父 //子 const {list} = this.props //props传函数 //父 addData=(title)=>{ this.setState({ list:this.state.list.concat({ id:`${Date.now()}`, title }) }) } //子 const {add}=this.state add(\"title\") //props类型检查 import PropTypes from 'prop-types' class Child extends Component{} Child.propTypes={ list:PropTypes.arrayOf(PropTypes.object).isRequired } setState 他的特性如下 不可变值：在setSate修改之前，不可以直接操作state 可能是异步更新： 可能会被合并： 不可变值 //基本类型 this.setState({ //不可以this.state.count++，这样不符合state的不可变特性 count:this.state.count+1 }) //数组 var list=this.state.list5.slice() list.push(100) this.setState({ list1:this.state.list1.concat(100),//追加 list2:[...this.state.list1],//追加 list3:this.state.list1.slice(0,3)，//截取 list4:this.state.list1.filter(item=>item>100)，//筛选 list5:list//其他操作使用副本擦欧总 }) //对象 this.setState({ obj1:Object.assign({},this.state.obj1), obj2:{...this.state.obj2,a:100} }) 同步或异步 //正常使用是异步 this.setState({ count:1 },()=>{console.log(this.state.count)}) //在setTimeout中是同步的 setTimeout(()=>{ this.setState({ count:1 }) console.log(this.state.count) },0) //自定义dom事件中是同步 handle=()=>{ this.setState({ count:1 }) console.log(this.state.count) } componentDidMount(){ document.body.addEventListener('click',this.handle) } 合并与不合并 /*this.state.count===0*/ //传入对象会合并:三个会被合并，最终count的值是1 this.setState({ count:this.state.count+1 }) this.setState({ count:this.state.count+1 }) this.setState({ count:this.state.count+1 }) //传入函数不会和合并:最终将结果为3 this.setState((prevState,props)=>{//参数：设置前的state、props属性 return { count:prevState.count+1 } }) this.setState((prevState,props)=>{//参数：设置前的state、props属性 return { count:prevState.count+1 } }) this.setState((prevState,props)=>{//参数：设置前的state、props属性 return { count:prevState.count+1 } }) 生命周期 render之前为render阶段，纯净且不包含副作用，可能会被react暂停、中止、重启 react更新dom时进入commit阶段，可以使用dom，运行副作用，安排更新 示例 //挂载 constructor | render | react更新dom和refs | componentDidMount //更新 new props/setState/forceUpdate | shouldComponentUpdate | render | react更新dom和refs | componentDidUpdate //卸载 componentWillUnmout 父子组件生命周期和vue相同 高级特性 函数组件 纯函数，输入props输出jsx 没有实例，没有生命周期，没有state 不能拓展其他方法 function List(props){ const {list}=this.props return { list.map(item=>{item.title}) } } 非受控组件 什么时候通常选择非受控组件 文件上传，只能手动操作dom元素 富文本编辑器的实现 this.nameInputRef = React.createRef() return {/* 使用 defaultValue 而不是 value ，使用 ref */} {/* state 并不会随着改变 */} state.name: {this.state.name} alert name alertName = () => { const elem = this.nameInputRef.current // 通过 ref 获取 DOM 节点 alert(elem.value) // 不是 this.state.name } Portals 传送门。组件默认会按照规定层嵌套渲染，传送门可以让组件到负组件外。 使用场景 父组件overflow:hidden 父组件z-index太小 fixed定位时需要放在body第一层级 render() { // // 正常渲染 return {this.props.children} {/* vue slot */} // 使用 Portals 渲染到 body 上。 // fixed 元素要放在 body 上，有更好的浏览器兼容性。 return ReactDOM.createPortal( {this.props.children}, document.body // DOM 节点 ) } context 公共信息利用context传递给每个组件。用props太繁琐，用redux小题大做。 下例中，我们将数据在app组件中赋值，向下传递两层，然后获取 // 1、创建 Context 填入默认值（任何一个 js 变量） const ThemeContext = React.createContext('light') class App extends React.Component { constructor(props) { super(props) this.state = { theme: 'light' } } render() { //2、使用ThemeContext.Provider 设置value return change theme } changeTheme = () => { this.setState({ theme: this.state.theme === 'light' ? 'dark' : 'light' }) } } // 中间的组件再也不必指明往下传递 theme 了。 function Toolbar(props) { return ( ) } // 底层组件 - class 组件 // 3、指定组件的contextType 读取当前的 theme context（变量名）。 ThemedButton.contextType = ThemeContext //指定静态属性 class ThemedButton extends React.Component { render() { // 4、赋值。React 会往上找到最近的 theme Provider，然后使用它的值。 const theme = this.context return button's theme is {theme} } } // 底层组件 - 函数是组件 function ThemeLink (props) { // 3、函数式组件可以使用 Consumer return { value => link's theme is {value} } } 异步组件 变成异步组件的方法如下 import React.lazy React.Suspense const ContextDemo = React.lazy(() => import('./ContextDemo')) class App extends React.Component { constructor(props) { super(props) } render() { return 引入一个动态组件 Loading...}> // 1. 强制刷新，可看到 loading （看不到就限制一下 chrome 网速） // 2. 看 network 的 js 加载 } } 性能优化 性能优化的要点如下 shouldComponentUpdate简称SCU PureComponent和React.memo 不可变值immutable.js //SCU /* 当父组件中有多个子组件，当引起父组件重新渲染的时候，所有子组件都会重新渲染，即使他的内容没有发生改变。所以我们可以手动加入判断，如果内容不变，就略过渲染阶段 */ shouldComponentUpdate(nextProps,nextState){ if(nextSatate.count!==this.state.count){ return true //可以渲染 } return false //不可渲染 } 为什么react不内置本功能，也就是渲染内容相同就停止渲染，不同的时候再渲染？ state的特性之一就是不可变值，我们不可以直接改变他的值，但并不是所有编程者都会遵循，例如要改变的state是一个数组我们用如下方式更改他 this.state.list.push(1) this.setState({ list:this.state.list }) 这是不规范的写法，但并不是错误写法，所以当这个时候使用SCU的时候，会永远判等。所以scu必须配合不可变值一起使用 在SCU中，我们比较某个state是否变化，但通常state是一个对象，这是需要我们进行深比较，但这是非常小号性能的，所以react提供了浅比较的方法 /*PureComponent（只比较第一层属性）类组件中使用*/ class List extends React.PureComponent{} //这样写他会为你默认生成SCU并进行配置 /*memo 函数组件中使用*/ function com(prevProps,nextProps){} export default Rect.memo(myComponent,com) //为你返回一个新组件 如果你想彻底使用不可变值，在SCU中使用深拷贝，但同时会降低性能。而immutable.js解决了这个问题。它基于共享数据而非深拷贝。 HOC和Render Props 关于组件中公共逻辑抽离，react将mixin废弃了，同时引出HOC和render Props。 HOC更像是一种模式，他接收一个组件作为参数，并返回一个新组件，它的作用像是一个工厂或是装饰器。 //例如我们想把同一个功能添加入com1，com2两个组件 const HOCfactory=(Component)=>{ class HOC extends React.Component{ componentDidMount() { conosle.log(\"一个功能\") } render(){ return //透传props } } return HOC } export const app1=HOCfactory(com1) export const app2=HOCfactory(com2) 除了HOC还有render props思想，HOC将需求组件传入公用逻辑组件中，而render Props是将公共逻辑组件传入需求组件中 但是HOC中我们要展现的模板写在需求组件中，公用逻辑组件只需要接受拿过来渲染，可如果需求组件作为父组件，那如何保证在父组件中使用公用的（子组件的）逻辑呢？下面为实现方法 class Factory extends React.Component{ constructor(){ this.state={ //多个组件的公用逻辑数据 a:1 } } render(){ return {this.props.render(this.state)} } } //props.render为从外部传入的要渲染的模板，这样就可以使用子组件中的逻辑或者变量了。也就是说，即使需求组件在外层，渲染模板还是在子组件进行 const App=()=>{ {props.a} } /> } //props.a为公共逻辑组件中定义好的变量a:1 //这里我们将要渲染的东西及要使用的逻辑传入公共逻辑组件中 生态 redux react-router 分为hash和h5 history两种模式 他的传参方式 //params xxx this.props.history.push({pathname:\"/path/\" + name}); 读取参数用:this.props.match.params.name //query this.props.history.push({pathname:\"/query\",query: { name : 'sunny' }}); 读取参数用:this.props.location.query.name //state this.props.history.push({pathname:\"/sort \",state : { name : 'sunny' }}); 读取参数用: this.props.location.query.state //search xxx this.props.history.push({pathname:\"/web/departManange?tenantId\" + row.tenantId}) 读取参数用: this.props.location.search 原理 首次渲染流程 jsx经过babel编译成React.createElement的表达式 React.render(React.createElement())执行 React.createElement()执行生成一个element 执行React.render函数，进行初始化此element 判断element类别，假如是自定义组件 初始化ReactCompositeComponentWrapper类 调用mountComponent方法 实例化自己的组件，例如叫Home类，得到instance componentWillMount renderedElement = instance.render() 初始化renderedElement，得到child componentDidMount child.mountComponent(container) element下面有 element的种类：string、原生DOM节点、React Component - 自定义组件、数组、null等 初始化element不同种类初始化时会用到不同的类 是对象-------原生DOM ReactDOMComponent ​ ---自定义类 ReactCompositeComponentWrapper 不是对象-----string、number ReactDOMTextComponent ​ ----ull、false ReactDOMEmptyComponent 每个类下面都有mountComponent、updateComponent mountComponent(container) { const domElement = document.createElement(this._currentElement.type); const textNode = document.createTextNode(this._currentElement.props.children); domElement.appendChild(textNode); container.appendChild(domElement); return domElement; } 更新渲染流程 useState实现原理 let _state = [], _index = 0; function useState(initialState) { let curIndex = _index; // 记录当前操作的索引 _state[curIndex] = _state[curIndex] === undefined ? initialState : _state[curIndex]; const setState = (newState) => { _state[curIndex] = newState; ReactDOM.render(, rootElement); _index = 0; // 每更新一次都需要将_index归零，才不会不断重复增加_state } _index += 1; // 下一个操作的索引 return [_state[curIndex], setState]; } 加入函数式更新和惰性初始化state，并判断是否需要刷新页面 let _state = [], _index = 0; function useState(initialState) { let curIndex = _index; if (typeof initialState === \"function\") { initialState = initialState(); } _state[curIndex] = _state[curIndex] === undefined ? initialState : _state[curIndex]; const setState = newState => { if (typeof newState === \"function\") { newState = newState(_state[curIndex]); } if (Object.is(_state[curIndex], newState)) return; // 使用Object.is来比较_state[curIndex]是否变化，若无，则跳过更新 _state[curIndex] = newState; ReactDOM.render(, rootElement); _index = 0; }; _index += 1; return [_state[curIndex], setState]; } useEffect实现原理 vnode diff 具体见vue原理 vnode重点概念 h函数 vnode数据结构 patch函数 diff重点概念 只比较同级 tag不相同直接删掉重建，不太深度比较 tag和key，两者都相同，认为相同节点，不再深度比较 jsx 他的样子等同于vue的模板，但vue的模板不是html，jsx也不是js。 vue在编译完模板后返回的是一个render函数体，render函数执行后会返回vnode。 jsx同样会被babel编译 他的编译形式如下 //jsx const el= 标题 内容 //babel编译后 \"use strict\"; var el =React.createElement(\"div\", {id: \"el\"}, React.createElement(\"h2\", null, \"标题\"), React.createElement(Child, null, \"内容\")); //jsx const el= { list.map(item=>{item.title}) } //babel编译后 var el = React.createElement(\"div\", { id: \"el\" }, list.map(function (item) { return React.createElement(\"li\", null, item.title); })); 综上可看React.createElement的用法 React.createElement(元素,属性,child1，child2) React.createElement(元素,属性,[child1，child2]) React.createElement即h函数，返回vnode 第一个参数可以实组件也可以是html的tag 区分是组件名还是tag的方法为组件名首字母必须大写（react规定） 合成事件 react的所有事件都是挂载到document上面的 event不是原生的，是SynctheticEvent合成事件对象 和vue事件不同，和dom事件不同 合成事件过程 元素触发事件 ‘事件冒泡到顶层document 实例化统一的event对象 将事件派发下去 为什么要用合成事件 更好的兼容性和跨平台 全部挂载到document，减少内存消耗，避免频繁解绑 方便事件的统一管理（如事务机制） setState batchUpdate setState主流程 this.setState(newState) newState存入pending队列 是否处于batch update (Y)保存到diryComponents中（即异步执行） (N)遍历所有diryComponents，调用updataComponent更新pendingstate或者props（即同步执行） 解释： 在react中定义函数的时候，会先设置一个状态，函数结束的时候再次设置 //正常情况是异步 class Demo extends Component{ constructor(){} render(){} increase=(){ //isBatchingUpdates=true //逻辑 this.setState({ count:this.state.count+1 }) //isBatchingUpdates=false } } //有时候为同步 class Demo extends Component{ constructor(){} render(){} increase=(){ //isBatchingUpdates=true setTimeout(()=>{ //此时isBatchingUpdates是false this.setSate({ count:this.state.count+1 }) }) //isBatchingUpdates=false } } 所有react控制范围的，都可以被batchUpdate命中，例如生命周期，react注册事件，调用的函数，有些不能被命中，例如自定义事件，一些异步方法 以上这种机制被称为transaction机制，即在函数执行前进行isBatchingUpdates=true，然后执行函数体，在函数执行完成后isBatchingUpdates=false transaction的原理如下 /* * * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|--------> * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ * */ perfirm是一个react定义的接口方法，由途中看到，我们在最初已经定义好了initialize和close方法，当通过perform执行一个方法的时候会一次执行这些方法，我们可以模拟一下这个过程 transaction.initialize=function(){ console.log('initalize') } transaction.initialize=function(){ console.log('close') } function method(){ console.log('method') } transaction.perform(method) //最后的结果为 //initalize //method //close 组件渲染、更新过程及 props state 生成vnode 渲染组件（patch） 将patch可以分为两个阶段 reconsiliation阶段--执行diff计算 commit阶段--将diff结果渲染dom阶段 可能遇到的性能问题： js是单线程，且和dom渲染公用一个线程，当组件足够复杂，组件更i性能时计算压力较大，同时再有dom操作需求（动画、鼠标拖拽事件），这时候页面将卡顿 基于问题，react提出的解决方案fiber： 将reconsiliation阶段进行拆分，当dom需要渲染时，暂停计算，空闲时恢复渲染，这样通过window.requestIdleCallback这个api去实现 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/vue复习总结.html":{"url":"web前端/vue复习总结.html","title":"vue复习总结","keywords":"","body":"框架使用 基本使用 插值、表达式、动态属性 data:(){ msg:true, id:'contain', rawHtml:'hahahah'//富文本，有xss风险 } {{msg?\"\":\"hello\"}} \"id\"> computed和watch computed有缓存，data不变不会重新计算 watch不会深度监听 watch监听引用类型，拿不到oldValue //computed用字啊v-model中是需要写get和set {{msg1}} data:{ num:1 } computed:{ msg1(){ return this.msg }, msg2:{ get(){ return this.num }, set(val){ this.num=val } } } //watch {{msg}} watch:{ msg:{ bandler(oldVal,val){ //深度监听时拿不到oldValue }, deep:true//开启深度监听 } } class、style v-if、v-for v-if是根本不会渲染 v-show只是使用了display属性将他隐藏,但是依然渲染 v-for支持对象和数组，key是必须的 事件 vue中的event是原生对象，且挂在地方与原生相同 methods:{ handle(e){ console.log(e) } } 常见事件修饰符、按键修饰符 v-model双向绑定 //截取空格 //防抖 //转化为数字 父子组件通讯 父--->子 //parent data(){ list0:[1,2,3] } //child props:['list'] props:{ list:{ type:Array, default(){ return [] } } } 子-->父 //parent methods:{ addHandler(title){ console.log(title) } } //child methods:{ clickEvent(){ this.$emit('add',this.title) } } 兄弟组件通讯 //child1发出事件 event.$emit('eve',this.title) //child2接受事件 event.$on('eve',this.handler) deforeDestroy(){//解绑事件、防止内存泄漏 event.$off('eve',this.handler) } //event为自己封装 export default Vue() 生命周期 单个组件中 new Vue beforeCreate 将数据存入内存中 created 模板编译 beforeMount 再网页上绘制 mounted beforeUpdate 更改数据 updated beforeDestory 解除绑定、小蕙子组件、事件监听器 destroyed 多个组件 parent created child created child mounted parent mounted parent before updata child before updata child updata parent updata 高级特性 v-model组件绑定 //parent {{name}} data(){ name:\"xwx\" } //child model:{ props:'text', event:'change' } props:{ text:{ type:String, default(){ return \"\" } } } $nextTick与refs 在data后，数据为异步渲染，dom不会立刻渲染,$nextTick会在dom更新后进行操作 {{item}} data(){ return { list:['a','b','c'] } } methods:{ addItem(){ this.list.push(`${Date.now()}`) const ul=this.$refs.ul console.log(ul)//此时ul为未改变之前的元素 this.$nextTick(()=>{ console.log(ul)//ul为改变后的元素 }) } } slot 基本使用 //parent {{msg}} data(){ return { msg:'haha' } } //child 默认值 作用域插槽，在父组件中使用子组件的数据 //parent {{slotProps.slotData.title}} data(){ return { msg:'xwx' } } //child data(){ return { msg:'haha' } } 具名插槽 //parent haha heiehi luelue //child 动态、异步组件 当不确定组件名字的时候，可以将组件名字动态传入 //使用:is=\"component-name\" components:{ child }, data(){ return { comName:\"Child\" } } 当一个组件过大时，我们可以异步加载他 components:{ Child:()=>import('./child') } data(){ return { showchild:false } } keep-alive 我们可以将某个组件缓存，可以避免重复渲染 mixin 当我们想抽离出多个组建的相同部分 当有相同生命周期时，会合并逻辑，如果有相同数据，则以本页面数据为主 //index {{age}}{{name}} mixins:[myMixin] data(){ return { age:12 } } //mixin export default{ data(){ teturn { name:'xwx' } }, methods:{}, mounted(){} } 自定义指令 全局定义 Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 局部定义 directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 声明周期 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 钩子函数中的参数 el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 周边插件 Vuex mutations为原子操作 action才能做异步操作，可能会整合多个mutations 简单介绍下store的使用方法 在main.js中引入 import Vue from 'vue' import Vuex from 'vuex' import store from './store' Vuew.use(Vuex) new Vue({ store }) store定义 state中是你所需要存储的状态值 mutations中是你的逻辑操作 actions中是你的业务方法，在他里面去调用逻辑操作 getters中是属于计算属性 当我们分模块分别创建多个store的时候将他们最终归入module中 export default new Vuex.Store({ state: { count:0 }, getters:{ myCount(state){ return `数值是${state.count}` } }, mutations: { increment(state,n){ state.count+=n }, decrement(state,n){ state.count-=n } }, actions: { async myIncrement(context,obj){ context.commit('increment',2) await const products=[1,2,3] console.log(obj) //其他业务 return products }, async myDecrement(context){ context.commit('increment',2) await const products=[1,2,3] //其他业务 return products } }, modules: { } }) 在组件中调用 //调用state值 import {mapState,mapGetters} from 'vuex' computed:{ ...mapState(['count']) ...mapGetters(['myCount']) } //改变值 import {mapMutations,mapActions} from 'vuex' methods:{ ...mapMutations(['increment','decrement']) ...mapActions(['myIncrement','myDecrement']) async increase(){ this.$store.state.count+=1//不推荐 this.increment()//直接调用逻辑方法，也不推荐 const prodicts=await this.myIncrement({a:1}) } } 但通常，我们的目录是比较复杂的 在大型项目中。我们的目录通常是这样 ├── index.html ├── main.js ├── api │ └── ... # 抽取出API请求 ├── components │ ├── common │ └── page └── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 其中每个模块中都包括自己的一个store及其自己的state、getters、action等 最终合并后 //index.js export default new Vuex.Store({ //... module:{ } }) //cart.js export default const cart={ state:{}, getters:{}, mutations:{}, actions:{} } //调用state值,调用cart模块中的值 import {mapState,mapGetters} form 'vuex' computed:{ ...mapState({ count:state=>{ return state.app.count } }) } //改变值和之前相同 vue-router 路由模式 hash：http://abc.com/#/user h5 history：http://abc.com/user，且需要后端支持 操作方法 标签转跳 1. 不带参数 //name,path都行, 建议用name // 注意：router-link中链接如果是'/'开始就是从根路由开始，如果开始不带'/'，则从当前路由开始。 2.带参数 // params传参数 (类似post) // 路由配置 path: \"/home/:id\" 或者 path: \"/home:id\" // 不配置path ,第一次可请求,刷新页面id会消失 // 配置path,刷新页面id会保留 // html 取参 $route.params.id // script 取参 this.$route.params.id // query传参数 (类似get,url后面会显示参数) // 路由可不配置 // html 取参 $route.query.id // script 取参 this.$route.query.id push 1. 不带参数 this.$router.push('/home') this.$router.push({name:'home'}) this.$router.push({path:'/home'}) 2. query传参 this.$router.push({name:'home',query: {id:'1'}}) this.$router.push({path:'/home',query: {id:'1'}}) // html 取参 $route.query.id // script 取参 this.$route.query.id 3. params传参 this.$router.push({name:'home',params: {id:'1'}}) // 只能用 name // 路由配置 path: \"/home/:id\" 或者 path: \"/home:id\" , // 不配置path ,第一次可请求,刷新页面id会消失 // 配置path,刷新页面id会保留 // html 取参 $route.params.id // script 取参 this.$route.params.id 4. query和params区别 query类似 get, 跳转之后页面 url后面会拼接参数,类似?id=1, 非重要性的可以这样传, 密码之类还是用params刷新页面id还在 params类似 post, 跳转之后页面 url后面不会拼接参数 , 但是刷新页面id 会消失 replace 使用this.$router.replace() (用法同上,push) go this.$router.go(n) 向前或者向后跳转n个页面，n可为正整数或负整数 区别 push：跳转到指定路径，并想history栈中添加一个记录，点击后退会返回到上一个页面 replace：跳转到指定路径，但是history栈中不会有记录，点击返回会跳转到上上个页面 (就是直接替换了当前页面) go：向前或者向后跳转n个页面，n可为正整数或负整数 框架原理 vue的数据劫持 vue的一大卖点就是他的响应式，即数据一旦变化，会立刻触发视图的更新。 他原理的核心API为Object,defineProperty，接下来我们来模拟实现一下 我们要达到的效果如下 //定义一个数据 const data={ name:'zhangsan', age:20, info:{ address:'北京' }, nums:[10,20,30] } //将数据进行监听 observer(data) //改变变量会驱动渲染或处理替他逻辑 data.name='lisi' //改变属性值 data.info.address='tianjin' 下面我们实现observer函数 // 监听对象属性 function observer(target) { if (typeof target !== 'object' || target === null) { // 不是对象或数组 return target } // 重新定义各个属性（for in 也可以遍历数组） for (let key in target) { defineReactive(target, key, target[key]) } } // 重新定义属性，监听起来 function defineReactive(target, key, value) { // 深度监听 observer(value) // 核心 API Object.defineProperty(target, key, { get() { return value }, set(newValue) { if (newValue !== value) { // 深度监听 observer(newValue) // 监听新值，因为新值可能是对象，所以需要深层监听 // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值 value = newValue // 触发更新视图或者其他逻辑 updateView() } } }) } 这样虽然可以实现，但是仍有一下缺点 通过深层递归监听所有变量，耗费性能 如果删除某个变量或者添加新变量无法触发渲染页面 如果数据是数组，数组的原生方法是无效的 所以在vue中如果要创建或删除变量需要用vue.set或vue.delete方法去进行 对于数组，我们需要另外进行操作，即修改数组原型 // 重新定义数组原型 const oldArrayProperty = Array.prototype // 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型 const arrProto = Object.create(oldArrayProperty); ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName => { arrProto[methodName] = function () { updateView() // 触发视图更新 oldArrayProperty[methodName].call(this, ...arguments) // Array.prototype.push.call(this, ...arguments) } }) // 监听对象属性 function observer(target) { if (typeof target !== 'object' || target === null) { // 不是对象或数组 return target } if (Array.isArray(target)) { //如果师叔祖，重新定义原型 target.__proto__ = arrProto } // 重新定义各个属性（for in 也可以遍历数组） for (let key in target) { defineReactive(target, key, target[key]) } } 这样下来，如果通过push等方法修改数组，也可以进行渲染 当然，此处简单的实现了修改数据重新渲染视图，但实际还要结合观察者模式，在get的时候对该变量进行观察。具体可看mvvm文章 Vnode && diff dom操作时非常消耗性能的通过虚拟dom来减少浏览器性能的消耗 vue通过参考snabbdom实现的vdom与diff，但每种vdom和diff的实现小同大异 首先让我们思考，通过虚拟dom来实现视图渲染的过程是什么 将html转化为js结构体 将js结构体转化为vnode 将vnode渲染到页面 / 比较vnode是否异同后渲染到页面 如果使用snabbdom，我们做这样一个过程是如何用代码实现的呢，它定义了h函数、patch来帮我们实现 //获取容器 const container = document.getElementById('container') // 生成 vnode const vnode = h('ul#list', {}, [ h('li.item', {}, 'Item 1'), h('li.item', {}, 'Item 2') ]) patch(container, vnode) //添加点击改变dom的操作 document.getElementById('btn-change').addEventListener('click', () => { // 生成 newVnode const newVnode = h('ul#list', {}, [ h('li.item', {}, 'Item 1'), h('li.item', {}, 'Item B'), h('li.item', {}, 'Item 3') ]) patch(vnode, newVnode) }) h函数接收我们要渲染到页面的html结构，但是这里可以看到他又固定的格式，但实际开发中，我们不可能将很长的html全部写为这样的格式，所以这个时候会用模板编译器帮助我们将html结构生成这样的格式，然后我们将他传入h函数 h函数用来实现vnode，虽然vnode包括很多东西，但是这个函数的实现逻辑无非是赋值、创建对象，我们主要看patch patch一个作用是渲染，另一个自然是更新，在更新的时候，就用到了diff算法。 diff就是对两棵树进行比较，它是一种思想，因为他有很多实现方式，但他们大同小异。 通常查找两棵树的差异，我们的方法是遍历两棵树完成后还有进行排序，他的时间复杂度大概为n^3,大幅度消耗性能 diff将复杂度变为n，他有如下规则 值比较同级 tag不相同，直接删掉重建 tag和key相同，则认为相同，不在深度比较 模板编译 在写vue的时候，我们通常会写html、指令、插值等，这些不是html的语法，但是浏览器最后还是能识别它，是因为它经历了模板编译。 模板编译过程 将template模板编译为render函数 执行render函数生成vnode（这里的render实际就是对h函数的一个封装和功能补充） 这里我们简单展示一个编译结果 const template = `{{message}}` //编译后 with(this){return createElement('p',[createTextVNode(toString(message))])} 当然这只是针对插值的情况进行的编译，能编译的还例如指令 // 循环 const template = ` {{item.title}} ` //编译后 with(this){return _c('ul',_l((list),function(item){return _c('li',{key:item.id},[_v(_s(item.title))])}),0)} 那么是什么将他们编译的呢，工具也有很多，例如webpack的vue-loader会在开发环境下编译模板 这是，我们回忆一下如何去写一个vue组件，可能你是这么写 Vue.component('heading',{ template:`balabal` }) 然后运行的时候编译器会把template编译生成render函数，当然我们其实可以直接写render函数 Vue.component('heading',{ render: createElement( 'h1', [ createElement('a',{ attrs:{ name:'headerId', href:\"#headerId\" } },'this is a tag') ] ) }) //渲染出来时 组件渲染过程（总结） 模板编译（编译为render） 响应式（数据劫持） 执行render后生成vnode 通过patch去渲染或者更新 首先编译器进行编译，编出render函数。render函数执行产生vnode，进行patch。在render的同时，会触发data数据的getter，他会将当前变量写入观察者。当数据发生改变会触发setter中的动作函数。 vue3 使用ts重写代码，性能提升且代码量更少。 特性 vue3.0重要的特点就是讲之前的option api改为了composition api 也就是组合式api，一个功能就是一个api 在2.0中，我们创建vue对象通常是 var vm = new Vue({ el: '#app', data: data }) 在3.0中，我们可以改变了方式 Vue.createApp({ data:()=>({ tag:true }) }).moute('#app') 优点 没有了this的烦恼 更好的而类型推到能力（ts） 更友好的Tree-shaking支持 更大的代码压缩空间 更灵活的逻辑复用能力 proxy实现响应式 defineProperty的问题 深度监听一次性递归，耗性能 无法监听新增属性删除属性 无法原生监听数组 proxy使用 const data={ name:'xwx', age:21 } const proxyData=new Proxy(data,{ get(target,key,receiver){ const result=Reflect.get(target,key,receiver) return result;//结果 }, set(target,key,val,receiver){ const result=Reflect.set(target,key,val,receiver) return result;//是否设置成功 }, deleteProperty(target,key){ const result=Reflect.deleteProperty(target,key) return result;//时候删除成功 } }) 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/angular复习总结.html":{"url":"web前端/angular复习总结.html","title":"angular复习总结","keywords":"","body":"angular 工程总览 工程创建 npm i @angular/cli ng new project_name ##创建名为project——name的项目 ng new project_name --skip-install --style css --routing false ##只生成文件不下载依赖 ng serve ##启动服务 ng build ##打包 ng lint ##扫描代码 ng g c component/component_name ## 创建新的组件 ng g m Home --routing##创建路由模块 ng add ng-zorro-antd ##ui库 项目目录 --e2e 测试目录 --src 源码目录 ----assets 资源目录（存放图片，音频等） ----environments 环境目录 ----app 主要逻辑代码目录 --editorconfig 编码风格设置 --angular.json 项目的定义文件 --browserslist 浏览器兼容设置(css) --karma.conf.js 测试文件 --tsconfig.* ts配置文件 --tslint.json 静态代码扫描 --polyfills.ts 浏览器兼容设置(js) 项目结构 项目是由一个个模块构成的。每个模块包括该模块内容与相对应的路由模块。模块内容包括一个个组件、指令、管道、服务。 模块分为根模块，普通模块，共享模块。 --根模块---组件一、指令一、管道一、服务一 | |--组件二、指令二、管道二、服务二 |-根路由模块 |-模块一---组件一、指令一、管道一、服务一 | |--组件二、指令二、管道二、服务二 |-负责模块一的路由模块 |-模块二---组件一、指令一、管道一、服务一 | |--组件二、指令二、管道二、服务二 |-负责模块二的路由模块 |-共享模块---公用组件一、公用指令一、公用管道一 |--公用组件二、公用指令二、公用管道二 以下是模块与组件的关系，组件是最小渲染单元。 //在app.module.ts中，配置所有组件 @NgModule({ declarations: [//本模块中含有的组件 AppComponent ], imports: [//依赖的其他模块 BrowserModule ], providers: [],//对内需要暴露的服务 bootstrap: [AppComponent]//启动的根组件，入口组件 }) 而一个项目通常是由多个模板组成的。 脏值检测 定义 脏值检测是angular的一个基本机制，他保证了当angular的数据变化时可以更新视图。 触发脏值检测的条件 浏览器事件，例如click，mouseover，keyup setTimeout和setInterval HTTP请求 如何进行脏值检测 他将组件按照嵌套关系生成以可组件树，递归的查询每棵树上的绑定数据的值，如果有变化则更新视图。 在有父组件和子组件的生命周期中 子组父组件 |---脏值检测（完成后会引发下面的周期） |---AfterViewCheck，AfterViewInit 脏值检测的时候，angular会从跟组件开始循环遍历，查看所有绑定数据的属性值有没有变化，且进行两次。 这也指明了我们不能在AfterViewCheck，AfterViewInit中对绑定的数据进行更改，因为如果在此更改后，脏值检测完成后，触发AfterViewCheck事件更改了值，紧接着触发第二次脏值检测，检测到值不一样了会抛出异常。 默认策略与onpush策略 以上说的为默认政策，默认政策时，脏值检测当出发的时候会递归的查询所有组件，有时候可能会影响性能。onpush政策可以使当触发脏值检测的时候，只检查本组件的input变量有没有变化而忽略其他的改变。而input变量有来自于组件外，所以，将组件设置为onpush政策使得该组件变成了一个笨组件(木偶组件)，只用于单纯的展示。 要设置成onpush策略我们要在组件逻辑ts中加入如下： @Component({ changeDetection:ChangeDetectionStrategy.onpush }) 但需要主义的使，路由的参数变化在默认策略之下，不会销毁这个组件而是重用这个组件，所以ngOnInit（我们默认数据的获取写在这里）只走一遍，这在默认模式下面没有问题，但在onpush模式下会被忽略，从而导致在改变路由参数之后，再改回来的时候，数据会无法获取到。 解决方法，我们将private cd:ChangeDetectorRef引入到类中，通过再函数末尾使用this.cd.markForCheck()来告诉组件此处发生了变化，需要更新数据。 angular基础知识 条件渲染 *ngFor：循环渲染 {{menu.title}} *ngIf：判断渲染 条件为真的内容 条件为真的内容 条件为假的内容 事件绑定 样式绑定 第一种：当后面的表达式成立，.active样式生效。适用于单个样式 第二种：自由度拓展性最强的绑定方法 第三种：嵌入式样式，会覆盖其他样式。常用于动态改变某个css属性。 第四种：js操作dom去绑定(不推荐使用) 第五种：js使用rd2去绑定 (private elr:ElementRef,private rd2:Renderer2)=>{ this.rd2.setStyle(this.elr.nativeElement,'display','grid') } eg： 在组件中有一个伪类:host,他的属性定义会应用到他的宿主（也就是他所在的组件本身），而不是模板中的元素。 依赖注入 当我们定义一个类之后，想要应用这个类中的方法，就比如通过new一个他的实例然后使用。但是如果该类被标记了注入服务，那么我们在声明他的时候就不用在通过new去创建实例，而是可以直接声明类型后去使用。此时该类也变成了单利模式。 @Injectable()//声明可注入 class Product{ constructor(private name:string){} } @Injectable() class PurchaseOrder{ private product:Product; constructor(private product:Product){} } ngOnInit(){ const injector=Injector.create({ //在声明自己函数后，在此将自己的函数创建实例，供别人直接使用 providers:[//依赖池：在此声明所有需要供用的函数 { provide:Product,//标识符 useFactory:()=>{ return newProduct('haha') } },{ provide:PurchaseOrder, useClass:Product,//去new的东西 deps:[Product]本类中依赖的类 } ] }) console.log(this.injector.get(Product))//可以通过js方式获取该类 } //此后如果我想用Product类，可以直接通过private product:Product的方式，而不用new了。 在angular中提供了更为简单的方式，不用我们自己通过Injector.create自行构造的，再将类暴露出去之后，可以直接通过在模块中设置providers属性中设置。 @NgModule({ declarations:[], providers:[ PurchaseOrder,//如果无需工厂设置可以直接只写一个类名 { provide:Product, useFactory:()=>{ return newProduct('haha') } } ], imports:[] }) 除了在模块中自己设置angular6以后的版本中还有一种更简单的设置方法，直接在服务创建的时候自行声明 @Injectable({ providedIn: 'root' //root代表跟模块，也可以指定模块 }) export class Product{ constructor(private name:string){} } 如果我们要提供的不是一个具体的类，而是一个值，我们可以这么写 const injector=Injector.create({ providers:[ { provide:'baseUrl', useValue:'http://localhost' } ] }) this.injector.get('baseUrl') 但是在大型项目中，使用字符串做名字是很危险的，极有可能造成命名重复，所以我们创建一个token来确保他的唯一性 const token=new InjectionToken('baseUrl') const injector=Injector.create({ providers:[ { provide:token, useValue:'http://localhost' } ] }) this.injector.get(token) //此后如果我想用这个字符串，可以这样声明： //@Inject(token) private baseurl:string 组件 组件的封装 通过ng g c component_name生成新的组件 在新生成的组件中创建index.ts并暴露此组件 在使用的组件中引入组件 组件可以使用其ts文件中selector作为名字在其他地方直接使用 结构目录如下 ---component ---index.ts ---scrollable ---index.ts ---scrollable.component.css ---scrollable.component.html ---scrollable.component.ts ---scrollable.component.spec.ts ---app.component.css ---app.component.html ---app.component.ts ---app.component.spec.ts ---app.module.ts 组件的通讯 子组件--->父组件 事件绑定 在子组件中 export class ChildComponent { index:-1; @Output() tabSelected=new EventEmitter(); handleSelect(index){ this.tabSelected.emit(index) } } 在父组件中 export class AppComponent { handleTabSelected(index){ console.log(index) } } 父组件--->子组件 属性绑定 在父组件中 export class AppComponent { menus=[1,2,3] } 在子组件中 export class ChildComponent { @Input() data=[] } {{menu}} 组件的生命周期 组件在使用前需要继承相关接口 export class ScrollableTabComponent implements OnInit {//需要先继承 constructor() { } ngOnInit() { } } 组件的投影 hello 组件类中引用模板的元素 hello export class AppComponent{ @ViewChild('helloDiv') helloDivRef:ElementRef; @ViewChild('ImageSliderComponent') imageSlider:ImageSliderComponent; @ViewChildren(\"img\") imgs:QueryList handleable(){ console.log(helloDivRef.nativeElement) //元素本身 } } 组件的双向绑定 双向绑定最常见的作用就是，在我们更新input输入内容的同时，input的内容会不断更新在另外一处地方。 在此之前我们已经可以达到双向绑定了，通过事件绑定+属性绑定来实现。 在angular中还有更简单的方法。[(ngModel)]=“变量”，这其实就是一个语法糖。 首先需要引入FormsModule模块。 然后可以简写为 模块 服务 管道 内建管道 json管道：a|json 转化为json格式 data管道：a| data: slice:1:3 切割第一位到第三位 date管道：a| date:'MM-dd' 将日期转化为月-日的格式 currency管道：a|currency 'CNY' :'symbol':'4.0-2' 使用￥前缀，小数点前4位小数点后两位保留数 async管道：异步管道，例子如下 自定义管道 通过ng-pipe在vscode中创建模板 //设置倒计时管道 import { Pipe, PipeTransform } from '@angular/core'; @Pipe({ name: 'appAgo' }) export class AgoPipe implements PipeTransform { transform(value: any): any { if (value) { const seconds = Math.floor((+new Date() - +new Date(value)) / 1000); if (seconds 0) { return counter + ' ' + unitName + '前'; } } } } return value; } } 指令 指令分为三种： 组件：特殊的指令，带模板的指令 结构型指令（内建指令）：改变dom结构。例如ngIf、ngFor、ngSwitch 属性型指令（内建指令）：改变宿主行为。例如ngClass、ngStyle、ngModel 除了使用内建指令，我们还可以自己创建一个指令 //创建一个属性指令 import { Directive, HostBinding } from '@angular/core'; /** * 指令可以理解为没有模版的组件，它需要一个宿主元素。 * 推荐使用方括号 [] 指定 Selector，使它变成一个属性。 */ @Directive({ selector: '[appGridItem]' }) export class GridItemDirective implements OnInit{ contructors(private elr: ElementRef, private renderer: Renderer2){} ngOnInit():void {//注意修改属性的方法要放到oninit生命周期里执行 ，而不能放到contructor里面。 this.rd2.setStyle(this.elr.nativeElement,'display','grid') } } 如果单纯使用指令绑定样式和事件，angular提供了更简单的方法。 由于指令没有模板，所以他要寄宿在一个元素之上（宿主），@HostBinding 可以绑定宿主的属性或者样式，@HostListener可以绑定宿主的事件。 export class GridItemDirective { @HostBinding('style.display') display = 'grid'; @HostBinding('style.place-items') align = 'center'; /* 使用hostbinding绑定后，使得宿主的style.display与display变量相关联，同时变化。 */ @HostListener('click',['$event.target']) handleClick(ev){console.log(ev)} /* 使用hostlistener绑定后，第一个参数是事件类型，第二个参数是数组，写入数据依赖，当宿主触发了对一个事件后，会触发指令中的函数方法 */ } 路由 基本形式 通过ng-router-appmodule创建模板 import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { RecommendContainerComponent } from './components'; const routes: Routes = [ {path: '', redirectTo: 'home',pathMatch: 'full'}, {path: 'home',component: RecommendContainerComponent1}, {path: '**', component: RecommendContainerComponent2}, ]; //''路径表示默认，**表示不识别的路径 @NgModule({ imports: [RouterModule.forChild(routes)],//在此处导入模块 exports: [RouterModule] }) export class RecommendRoutingModule {} //应用 // 路由的嵌套 当然路由也可以嵌套，加入home下面还有子路由,我们可以再子路由中设置 import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { HomeContainerComponent, HomeDetailComponent } from './components'; const routes: Routes = [ { path: 'home', component: HomeContainerComponent, children: [ { /** * 路由节点可以没有 component * 一般用于重定向到一个默认子路由 */ path: '', redirectTo: 'hot', pathMatch: 'full' }, { /** * 路径参数，看起来是 URL 的一部分 */ path: ':tabLink', component: HomeDetailComponent } ] } ]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule] }) export class HomeRoutingModule {} 路径参数 拼接在url上面的，叫做路径参数 配置 {path:':tabLink',component:component} 激活 this.router.navigate(['home','/spots']) url http://loaclhost:4200/home/sports 取读 this.route.paramsMap.subcribe(params=>{}) 路径对象参数 形似name=val1的参数 配置 {path:':tabLink',component:component} 激活 this.router.navigate(['home','/spots',{name:'val1'}]) url http://loaclhost:4200/home/sports;name=val1 取读 this.route.paramsMap.subcribe(params=>{}) 路径查询参数 形似?name=val1的参数 配置 {path:':tabLink',component:component} 激活 this.router.navigate(['home'],{queryParms:{name:'val1'}}) url http://loaclhost:4200/home/sports;name=val1 取读 this.route.queryParamsMap.subcribe(params=>{}) 点击触发样式 我们可以通过routerLinkActive属性在标签点击触发路由的时候添加类名 网络接口对接 HttpClient 在根模块导入HttpClientModule 在构造中注入HttpClient 订阅后发送请求 //在根模块引入后，在其他模块中也可以使用 export class HomeService{ constructor(private http:HttpClient){} getData(){ //通过泛型的形式，将他返回的数据进行格式转换，此处可以是string，也可以是其他自行定义的类型 return this.http.get(url,{ params:{icode:123} }) } } //http是一种异步操作 //这个时候getData返回的数据类型是 //在使用他的时候为 export class Home{ constructor(private serve:HomeService){} let _data=''; ngOnInit(){ this.serve.subscribe(tabs=>{ this._data=tabs; }) } } http拦截器 httpInterceptor 在http获取到数据之前，我们先将其进行一步处理，然后再交给httpclient去处理。在请求和访问的时候都可以进行拦截。 在请求中，例如要为很多http请求统一加入一个请求参数而无需一个一个加。 通过ng-http-interceptor在vscode中生成模板 import { Injectable } from '@angular/core'; import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http'; import { environment } from 'src/environments/environment'; @Injectable() export class ParamInterceptor implements HttpInterceptor { intercept(req: HttpRequest, next: HttpHandler) { // 对请求消息进行处理 const modifiedReq = req.clone({ //将原来的req克隆下来，并为他加入查询参数 setParams: { icode: environment.icode } }); //交给下一个拦截器去处理，因为在angular中可能有多个拦截器 return next.handle(modifiedReq); } } 完成设置后，我们要在根模块将它引入 @NgModule({ declarations: [AppComponent], imports: [], providers: [ { provide: HTTP_INTERCEPTORS, useClass: NotificationInterceptor, multi: true } ], bootstrap: [] }) 同理，我们也可以拦截请求到的数据，也就是respond的数据。 例如我们要设置，当请求成功的时候弹出消息。 import { Injectable } from '@angular/core'; import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse } from '@angular/common/http'; import { tap } from 'rxjs/operators'; @Injectable({ providedIn: 'root' }) export class NotificationInterceptor implements HttpInterceptor { intercept(req: HttpRequest, next: HttpHandler) { // 对响应消息进行处理 return next.handle(req).pipe( tap((event: HttpEvent) => { if ( event instanceof HttpResponse && event.status >= 200 && event.status 完成后同样在根模块引入。 rxjs 响应式编程类库 基础概念 rx要把事件或者数据看成一个流，随着事件流中的元素的变化随之做出相应的动作。 流的种类：无线、有限、单个、空 流的状态：next（得到流的数据之后的处理）、error（发生错误的处理）、complete（无论成功与否，最后都要执行的处理） 此外，所有的流都是异步的。 rx中流的类型用observable类型来表示。 rx最强大的地方之一，就是他拥有方便的操作符。 操作符 在路由参数接受的时候，我们运用的就是observable类型，如下例子 paramData; ngOnInit(){ this.route.paramMap.subscribe(params=>{ this.paramData=params.get('tabLink') }) } 使用在模板中 hello 上面的代码中，我们获取到params参数中，获取到tabLink属性，我们也可以添加管道，通过操作符改造。 paramData; ngOnInit(){ this.route.paramMap .pipe( filter(params=>params.has('tabLink')), map(params=>params.get('tabLink')) ) .subscribe(tabLink=>{ this.paramData=tabLink; }) } 应用在模板中同上。 但是在angular中，为了更好的兼容rx，我们可以直接将一个变量声明为流 //当变量作为流的时候，我们习惯在命名上加上一个$用于区分 paramData$:Observable; ngOnInit(){ this.paramData=this.route.paramMap .pipe( filter(params=>params.has('tabLink')), map(params=>params.get('tabLink')) ) } 使用在模板中时，由于这是一部操作，所以在一开始的时候paramData和‘home’的数据类型不同，所以我们通过异步管道实现它。 hello 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/webpack复习总结.html":{"url":"web前端/webpack复习总结.html","title":"webpack复习总结","keywords":"","body":"工作原理 在一个前端项目中，我们会用到很多零散的资源，例如html、css、js、json、png等等，webpack将他们呢每个部分当作一个模块进行操作 它通过loader进行资源整合，通过prugin进行自动化构建 他的工作过程如下 载入 Webpack 核心模块，创建 Compiler 对象； 使用 Compiler 对象开始编译整个项目； 从入口文件开始，解析模块依赖，形成依赖关系树； 递归依赖树，将每个模块交给对应的 Loader 处理； 合并 Loader 处理完的结果，将打包结果输出到 dist 目录。 module、chunk、bundle module：webpack中一切皆模块，源码中，每一个文件（除了html输出模板以外）其他的都是模块 chunk：多模块的合成，例如在entry，import()，splitChunk中都可能产生chunk bandle：最终输出文件，通常每个bandle都对应着一个chunk 资源整合原理 webpack最早的用途是资源打包，在模块化盛行后，我们开始讲项目分为多个模块，而最后讲各个模块整合到一起的任务就可以交给webpack。webpack整合代码的能力源于loader，并且默认的它只具有整合js的能力 整合js 我们的模块文件和入口文件分别如下 //bundle.js function say(){ console.log('hello') } export {say} //main.js import {say} from './hundle.js' say() 在webpack的配置文件中，最基础的设置为下 const path=require('path') module.exports={ mode:'none', entry:'./src/main.js',//所有模块的入口文件 output:{ filename:'bundle.js', path:path.join(__dirname,'dist') } } 如何合并js文件 整体结构如下,是一个闭包结构，每一个传入的参数代表一个js文件，且第一个为入口文件（即main.js） (function(modules){ //... })([ (function(module,__webpack_exports__,__webpack_require__){ //... }), (function(module,__webpack_exports__,__webpack_require__){ //... }) ]) 抛开传入的参数，我们看闭包内的内容,在程序的最后，调用执行函数去执行第一个参数即入口模块 (function(modules){ //缓存所有参数（模块） var installedModules = {}; //用于加载某个模块 function __webpack_require__(moduleId){} //定义了一些方法 __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function(exports, name, getter){} __webpack_require__.r = function(exports){} __webpack_require__.t = function(value, mode){} __webpack_require__.n = function(module){} __webpack_require__.o = function(object, property){} __webpack_require__.p = \"\"; //调用加载，传入参数0即调用第一个参数，即入口文件 return __webpack_require__(__webpack_require__.s = 0); })([...]) 我们来看如何调用 /******/ function __webpack_require__(moduleId) { /******/ /******/ // 查看该模块是否在缓存中 /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].exports; /******/ } /******/ // 创建一个新模块并放入缓存，这个对象中有该模块的导出内容 /******/ var module = installedModules[moduleId] = { /******/ i: moduleId, /******/ l: false, /******/ exports: {} /******/ }; /******/ /******/ // 运行参数函数 /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // 将模块标记为已加载 /******/ module.l = true; /******/ /******/ // 返回模块的导出 /******/ return module.exports; /******/ } 上面步骤来说，他做的只是在里面调用了参数的函数，那么参数的函数到底是什么呢，最开始我们说他是我们写的js文件，但它其实是通过改造的 //由main.js改造的，也就是第一个参数 function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; /*定义导出的esModule*/ __webpack_require__.r(__webpack_exports__); /*这句话便是翻译的import {say} from './hundle.js'*/ var _hundle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1); /*这句话便是翻译的say()*/ Object(_hundle_js__WEBPACK_IMPORTED_MODULE_0__[\"say\"])() }) //由bundle.js改造的 (function(module, __webpack_exports__, __webpack_require__) { \"use strict\"; __webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \"say\", function() { return say; }); function say(){ console.log('hello') } } 这里面用到了__webpack_require__.r和__webpack_require__.d //定义导出的esModule /******/ __webpack_require__.r = function(exports) { /******/ if(typeof Symbol !== 'undefined' && Symbol.toStringTag) { /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' }); /******/ } /******/ Object.defineProperty(exports, '__esModule', { value: true }); /******/ }; //定义和谐输出的getter函数 /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if(!__webpack_require__.o(exports, name)) { /******/ Object.defineProperty(exports, name, { enumerable: true, get: getter }); /******/ } /******/ }; __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; 整合css 在webpack理念中，他将样式或者是图片加载全部放到js文件中，而不是只讲js文件和样式分开引入管理。这样的思想保证了每个模块的独立性。 当我想合并css文件的时候会进行如下设置 const path=require('path') module.exports={ entry:'./src/main.css',//所有模块的入口文件 output:{ filename:'bundle.js', path:path.join(__dirname,'dist') }, module:{ rules:[ { test:/\\.css$/, use:[ 'style-loader', 'css-loader' ] } ] } } 自定义loader loader的实质就是将我们自己写的js文件转化为最终js文件中闭包的参数，即 (function(modules){ //... })([ (function(module,__webpack_exports__,__webpack_require__){ //... }), (function(module,__webpack_exports__,__webpack_require__){ //此处便是将你的模块经过loader操作所return的结果，直接防御此处 }) ]) 我们将自定义一个解析markdown的loader 我们将对下面的模块化项目进行使用 about.md文件 #About hello main.js文件 import about from './about.md' console.log(about) //预想输出 //abouthello webpack.config.js文件 const path=require('path') module.exports={ entry:'./src/main.js',//所有模块的入口文件 output:{ filename:'bundle.js', path:path.join(__dirname,'dist') }, module:{ rules:[ test:/\\.md$/, use:'./markdown-loader' ] } } 现在我们开始编写loader文件,loader返回的结果必须是js语句 //markdown-loader.js const marked=require('marked')//借助第三方模块 module.exports=source=>{ //source是被转化模块输出的东西 var html=marked(source) reutrn `export default${JSON.stringify(html)}` } 更改外如下最后打包出的文件为 (function(modules){ //... })([ (function(module,__webpack_exports__,__webpack_require__){ //... }), (function(module,__webpack_exports__,__webpack_require__){ export default${JSON.stringify('abouthello')}//此处还会被再一次转化 }) ]) 插件机制原理 随着发展，webpack不仅仅局限于资源整合，更有了自动化构建的能力loader的作用是为模块化设计来整合项目中的资源。而plugin做的就是完成一些项目自动化方面的事情 接下来，我们介绍几个常见插件 自动清除dist文件 clean-webpack-plugin 配置方式 const CleanWebpackPlugin=require('clean-webpack-plugin') const path=require('path') module.exports={ entry:'./src/main.js',//所有模块的入口文件 output:{ filename:'bundle.js', path:path.join(__dirname,'dist') }, plugins:[ new CleanWebpackPlugin() ] } 自动生成html html-webpack-plugin 将html自动生成到dist目录中，并且不用再手动修改引入路径 //自动生成html文件 const path=require('path') const HtmlWebpackPlugin=require('html-webpack-plugin') module.exports={ entry:'./src/main.js',//所有模块的入口文件 output:{ filename:'bundle.js', path:path.join(__dirname,'dist') }, plugins:[ new HtmlWebpackPlugin({ title:'页面标题', meta:{ view:'width=device-width' } }) ] } //定义index.html模板 const path=require('path') const HtmlWebpackPlugin=require('html-webpack-plugin') module.exports={ entry:'./src/main.js',//所有模块的入口文件 output:{ filename:'bundle.js', path:path.join(__dirname,'dist') }, plugins:[ new HtmlWebpackPlugin({ filename:'index.html',//如果不写，默认是index.html title:'页面标题', template:'./src/index.html' }) ] } 复制文件 copy-webpack-plugin 我们一般统一将静态文件放到public目录下 const path=require('path') const CopyWebpackPlugin=require('copy-webpack-plugin') module.exports={ entry:'./src/main.js',//所有模块的入口文件 output:{ filename:'bundle.js', path:path.join(__dirname,'dist') }, plugins:[ new CopyWebpackPlugin([ 'public' ]) ] } 自定义插件 插件机制使用的是钩子机制，运行的每个步骤都对应着一个钩子，而我们通过向钩子上添加方法来实现优化 具体有哪些预先定义好的钩子，我们可以参考官方文档的 API： nCompiler Hooks Compilation Hooks JavascriptParser Hooks 我们将实现一个小区文件中注释的插件 Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象，一般我们都会定义一个类型，在这个类型中定义 apply 方法。然后在使用时，再通过这个类型来创建一个实例对象去使用这个插件。 我们这里定义一个 RemoveCommentsPlugin 类型，然后在这个类型中定义一个 apply 方法，这个方法会在 Webpack启动时被调用，它接收一个 compiler 对象参数，这个对象是 Webpack工作过程中最核心的对象，里面包含了我们此次构建的所有配置信息，我们就是通过这个对象去注册钩子函数 // ./remove-comments-plugin.js class RemoveCommentsPlugin { apply (compiler) { console.log('RemoveCommentsPlugin 启动') // compiler => 包含了我们此次构建的所有配置信息 } } 知道这些过后，还需要明确我们这个任务的执行时机，也就是到底应该把这个任务挂载到哪个钩子上。我们的需求是删除 bundle.js 中的注释，也就是说只有当 Webpack 需要生成的 bundle.js 文件内容明确过后才可能实施。emit这个钩子会在 Webpack 即将向输出目录输出文件时执行 // ./remove-comments-plugin.js class RemoveCommentsPlugin { apply (compiler) { compiler.hooks.emit.tap('RemoveCommentsPlugin', compilation => { // compilation => 可以理解为此次打包的上下文 for (const name in compilation.assets) { if (name.endsWith('.js')) { const contents = compilation.assets[name].source() const noComments = contents.replace(/\\/\\*{2,}\\/\\s?/g, '') compilation.assets[name] = { source: () => noComments, size: () => noComments.length } } } }) } } 基本配置 通常，我们会配置三个文件，在开发模式和生产模式种，分别引入共有模块 webpack.common.js webpack.dev.js webpack.prod.js 配置package.json \"devBuild\": \"webpack --config build-optimization/webpack.dev.js\", \"dev\": \"webpack-dev-server --config build-optimization/webpack.dev.js\", \"build\": \"webpack --config build-optimization/webpack.prod.js\" 常见的包 webpack-merge 合并webpack配置 common配置 const path=require('path') const srcPath=path.join(__dirname,'..','src') const distPath=path.join(__dirname,'..','dist') module.exports={ entry:path.join(srcPath,'index'), module:{ rules:[ { test:/\\.js$/, loader:['babel-loader'],//还要配置.babelrc文件 include:srcPath, exclude:/node_modules/ }, { test:/\\.test$/, loader:['style-loader','css-loader','postcss-loader']//postcss处理css的兼容性的,需要配置postcss.config.js },{ test:/\\.less$/, loader:['style-loader','css-loader','less'] } ] }, plugins: [ new HtmlWebpackPlugin({ template: path.join(srcPath, 'index.html'), filename: 'index.html' }) ] } //.babelrc { \"presets\": [\"@babel/preset-env\"], \"plugins\": [] } //postcss.config.js module.exports = { plugins: [require('autoprefixer')] } dev配置 const webpackCommonConf = require('./webpack.common.js') const { smart } = require('webpack-merge') module.exports = smart(webpackCommonConf, { mode: 'development', module: { rules: [ // 直接引入图片 url { test: /\\.(png|jpg|jpeg|gif)$/, use: 'file-loader' } ] }, plugins: [ new webpack.DefinePlugin({ ENV: JSON.stringify('development') }) ], devServer: { port: 8080, progress: true, // 显示打包的进度条 contentBase: distPath, // 根目录 open: true, // 自动打开浏览器 compress: true, // 启动 gzip 压缩 // 设置代理 proxy: { // 将本地 /api/xxx 代理到 localhost:3000/api/xxx '/api': 'http://localhost:3000', // 将本地 /api2/xxx 代理到 localhost:3000/xxx '/api2': { target: 'http://localhost:3000', pathRewrite: { '/api2': '' } } } } }) 打包后文件为什么要用hash命名? 通常根据内容产生的hash名字，内容相同，hash名字相同。这样当再一次打包后，浏览器访问的时候，如果hash名字相同，就可以直接使用缓存，加快打开网页的速度。 prod配置 const webpackCommonConf = require('./webpack.common.js') const { smart } = require('webpack-merge') module.exports = smart(webpackCommonConf, { mode: 'production', output: { filename: 'bundle.[contentHash:8].js', // 打包代码时，加上 hash 戳 path: distPath, }, module: { rules: [ // 图片 - 考虑 base64 编码的情况 { test: /\\.(png|jpg|jpeg|gif)$/, use: { loader: 'url-loader', options: { // 小于 5kb 的图片用 base64 格式产出 // 否则，依然延用 file-loader 的形式，产出 url 格式 limit: 5 * 1024, // 打包到 img 目录下 outputPath: '/img1/', } } }, ] }, plugins: [ new CleanWebpackPlugin(), // 会默认清空 output.path 文件夹 new webpack.DefinePlugin({ // window.ENV = 'production' ENV: JSON.stringify('production') }) ] }) 高级配置 多入口输出 //更改common entry: { index: path.join(srcPath, 'index.js'), other: path.join(srcPath, 'other.js') }, plugins: [ // 为每个文件配置html new HtmlWebpackPlugin({ template: path.join(srcPath, 'index.html'), filename: 'index.html', // chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用 chunks: ['index'] // 只引用 index.js }), new HtmlWebpackPlugin({ template: path.join(srcPath, 'other.html'), filename: 'other.html', chunks: ['other'] // 只引用 other.js }) ] //更改prod output: { filename: '[name].[contentHash:8].js', // name 即多入口时 entry 的 key path: distPath, }, 抽离css文件 之前，我们的方法是将css放到html中变为style标签 module: { rules: [ // 抽离 css { test: /\\.css$/, loader: [ MiniCssExtractPlugin.loader, // 注意，这里不再用 style-loader 'css-loader', 'postcss-loader' ] }, // 抽离 less --> css { test: /\\.less$/, loader: [ MiniCssExtractPlugin.loader, // 注意，这里不再用 style-loader 'css-loader', 'less-loader', 'postcss-loader' ] } ] }, plugins: [ // 抽离 css 文件 new MiniCssExtractPlugin({ filename: 'css/main.[contentHash:8].css' }) ], optimization: { // 压缩 css minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})], } 抽离公共代码 例如当我们在index.js和other.js中都引用了math.js，打包的时候，它会将math.js分别放到index和other 中，所以我们应该在打包的时候将公共代码抽离出来 //prod optimization: { // 分割代码块 splitChunks: { chunks: 'all', /** * initial 入口 chunk，对于异步导入的文件不处理 async 异步 chunk，只对异步导入的文件处理 all 全部 chunk */ // 缓存分组 cacheGroups: { // 第三方模块 vendor: { name: 'vendor', // chunk 名称 priority: 1, // 权限更高，优先抽离，重要！！！ test: /node_modules/, minSize: 0, // 大小限制 minChunks: 1 // 最少复用过几次 }, // 公共的模块 common: { name: 'common', // chunk 名称 priority: 0, // 优先级 minSize: 0, // 公共模块的大小限制 minChunks: 2 // 公共模块最少复用过几次 } } } } //common entry: { index: path.join(srcPath, 'index.js'), other: path.join(srcPath, 'other.js') }, plugins: [ // 多入口 - 生成 index.html new HtmlWebpackPlugin({ template: path.join(srcPath, 'index.html'), filename: 'index.html', // chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用 chunks: ['index', 'vendor', 'common'] // 该出口需要引入的模块，第一个是上面出口名字，后面的为要引入的chunk名字 }), // 多入口 - 生成 other.html new HtmlWebpackPlugin({ template: path.join(srcPath, 'other.html'), filename: 'other.html', chunks: ['other', 'common'] // 考虑代码分割 }) ] 懒加载 通常在业务中，我们可能会懒加载一些模块例如 //index.js setTimeout(()=>{ import('./data.js').then(res=>{ console.log(res.default.msg) }) },1500) 在webpack中本身即支持懒加载，无需配置。 但需要知道的是，异步加载的组件会被webpack单独打成一个chunk,即会被单独打成一个文件。 jsx、vue 处理jsx需要配置.babelrc文件 //.babelrc { \"presets\": [\"@babel/preset-react\"], \"plugins\": [] } vue用到vue-loader插件 module:{ rules:[ { test:/\\.vue$/, loader:['vue-loader'], include:srcPath } ] } 性能优化--优化构建速度 优化babel-loader { test:/\\.js$/, use:['babel-loader?cacheDirsctory'],//开启缓存 include:srcPath//明确范围 } 开启缓存后，会将代码缓存，当再一次打包的时候，没有改变的代码会不再进行es6编译，直接使用缓存 另外一种给方法为明确范围 通常二者使用一个即可 ignorePlugin 避免引用无用模块 例如有一个moment模块，它可以将日期转化为各国语言的格式。我们在模块中使用它 import moment from 'moment' moment.locale('zh-cn') console.log(moment.locale()) 那么实例中，我们只需要用中文的格式，但实际打包中会将整个包即所有国家语言的设置都引入，所以打包速度变慢且包也变大，所以我们可以不引入这个模块，而是手动引入需要的包 import moment from 'moment' import 'moment/locale/zh-cn' moment.locale('zh-cn') console.log(moment.locale()) 然后设置，忽略引入该模块 plugins:[ new webpack.IgnorePlugin(/\\.\\/locale/,/moment/)//忽略moment下的/locale目录 ] noParse 取消对某模块的打包，直接将其引入 例如我们在项目中，引入了react.min.js，这个包本身就是压缩的，无需我们再一次进行压缩处理，可以直接引入，所以我们设置取消对他的打包 module:{ noParse:[/react\\.min\\.js$/] } happyPack 多进程打包编译 因为js是单线程的，但是我们可以开启多进程打包，特别是对于多核cpu。 module: { rules: [ // js { test: /\\.js$/, // 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 use: ['happypack/loader?id=babel'], include: srcPath, // exclude: /node_modules/ } ] } plugins: [ new HappyPack({ // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // 如何处理 .js 文件，用法和 Loader 配置中一样 loaders: ['babel-loader?cacheDirectory'] }) ] ParallelUglifyPlugin 多进程压缩js plugins: [ // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin({ // 传递给 UglifyJS 的参数 // （还是使用 UglifyJS 压缩，只不过帮助开启了多进程） uglifyJS: { output: { beautify: false, // 最紧凑的输出 comments: false, // 删除所有的注释 }, compress: { // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, } } }) ] 关于开启多进程 项目大，开启多进程可以开启速度 项目比较小，开启多进程会降低速度，因为开启进程会有进程开销 自动刷新 保存代码，页面自动刷新，整个网页全部刷新，速度较慢，且状态消失 module.export={ watch:true,//开启监听 } 热更新 保存代码，性能代码自动生效，网页不刷新。状态不丢失 const HotModuleReplacementPlugin = require('webpack/lib/HotModuleReplacementPlugin'); module.export={ entry: { // index: path.join(srcPath, 'index.js'),//之前的写法 index: [ 'webpack-dev-server/client?http://localhost:8080/', 'webpack/hot/dev-server', path.join(srcPath, 'index.js') ], } plugins: [ new HotModuleReplacementPlugin() ], devServer: { hot:true } } 但是在js文件中修改不会出发热更新，一位内他不在范围内，我们需要手动将他添加进监听范围 //添加math.js为监听范围，其内部修改会触发热更新 if (module.hot) { module.hot.accept(['./math'], () => { const sumRes = sum(10, 30) console.log('sumRes in hot', sumRes) }) } DllPlugin 动态链接库插件。这是webpack本身内置实现的功能 通常，在我们使用vue或者react等一些库的时候，打包框架本身的时间是比较慢的，所以，我们可以吧react框架及其用到的依赖于打包一下，然后之后在想打包的时候，利用于大宝出来的内容，会大大加快打包速度。以react框架为例 我们创建新的webpack.dll.js文件 const DllPlugin = require('webpack/lib/DllPlugin') const { srcPath, distPath } = require('./paths') module.exports = { mode: 'development', // JS 执行入口文件 entry: { // 把 React 相关模块的放到一个单独的动态链接库 react: ['react', 'react-dom'] }, output: { // 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称， // 也就是 entry 中配置的 react 和 polyfill filename: '[name].dll.js', // 输出的文件都放到 dist 目录下 path: distPath, // 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react // 之所以在前面加上 _dll_ 是为了防止全局变量冲突 library: '_dll_[name]', }, plugins: [ // 接入 DllPlugin new DllPlugin({ // 动态链接库的全局变量名称，需要和 output.library 中保持一致 // 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值 // 例如 react.manifest.json 中就有 \"name\": \"_dll_react\" name: '_dll_[name]', // 描述动态链接库的 manifest.json 文件输出时的文件名称 path: path.join(distPath, '[name].manifest.json'), }), ], } 然后我们配置命令 \"dll\": \"webpack --config build/webpack.dll.js\" 执行npm run dll后便进行了域打包，在dist目录中生成资源 要使用它，首先修改index.html入口文件，让他引用一下生成的资源 然后我们在dev打包文件中进行配置 // 第一，引入 DllReferencePlugin const DllReferencePlugin = require('webpack/lib/DllReferencePlugin'); { test: /\\.js$/, loader: ['babel-loader'], include: srcPath, exclude: /node_modules/ // 第二，不要再转换 node_modules 的代码 } // 第三，告诉 Webpack 使用了哪些动态链接库 new DllReferencePlugin({ // 描述 react 动态链接库的文件内容 manifest: require(path.join(distPath, 'react.manifest.json')), }), 然后使用npm run dev打包时的速度会大大加快 用于优化构建速度（生产环境） 可用于 ignorePlugin、noParse、happyPack、ParellelUglifyPlugin 不可用于 自动刷新、热更新、DllPlugin 性能优化--优化产出效率 它可以让项目体积更小，合理分配，不重复加载，速度更快，内存使用更小 小图片变为base64 // 图片 - 考虑 base64 编码的情况 { test: /\\.(png|jpg|jpeg|gif)$/, use: { loader: 'url-loader', options: { // 小于 5kb 的图片用 base64 格式产出 // 否则，依然延用 file-loader 的形式，产出 url 格式 limit: 5 * 1024, // 打包到 img 目录下 outputPath: '/img1/', } } bandle加hash filename:'[name].[contentHash:8].js'根据内容计算hash值，并保留8位数字 利用了缓存，加快客户端浏览器访问时加载的速度 懒加载 先加载重要的东西，其余的使用懒加载 抽离公用代码 减少代码重复打包，减小项目体积 ignorePlugin 减少我们打包体积 使用cdn加速 在图片资源、js资源、css资源添加publicPath:'http://cdn.ab.com' 然后将打包后的资源放到cdn服务器上 production 使用production模式的好处 自动开启代码压缩 vue、react等会自动删除调试代码（如开发环境的warning） 自动启动tree-shaking 开启方法如下 //prod module.exports = smart(webpackCommonConf, { mode: 'production', }) 关于tree-Shaking 例如在一个模块中，我们对外输出了两个函数fn1、fn2 但实际上，我们只用了第一个函数，但在普通情况下两个函数都会被打包进去 tree-Shaking则会使得未使用的函数不打包进去 tree-shaking的要求 必须使用es6的模块语法，不可以使用commonjs语法 因为es6的module是静态引入即编译时引用，commonjs是动态引入，执行时引入 打包的时候还没有执行，所以必须使用静态引入的 自定义插件 Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象，一般我们都会定义一个类型，在这个类型中定义 apply 方法。然后在使用时，再通过这个类型来创建一个实例对象去使用这个插件。 常见的生命钩子 entryOption：在处理完webpack选项的entry配置后调用。 afterPlugins：在设置初始内部插件集之后调用。 afterResolvers：解析器设置完成后触发。 environment：在初始化配置文件中的插件之后，在准备编译器环境时调用。 afterEnvironment：编译器环境设置完成后，在挂钩之后立即调用。 beforeRun：在运行编译器之前添加一个挂钩。 beforeCompile：创建编译参数后执行插件。 compile：beforeCompile之后执行 afterCompile：在完成并密封编译后调用。 emit：在将资产释放到输出目录之前立即执行。 afterEmit：在将资产释放到输出目录后调用。 选择合适的生命周期，添加需要挂载的方法和函数操作 compiler 对象参数，里面包含了我们此次构建的所有配置信息，我们就是通过这个对象去注册钩子函数 compilation 对象参数，这个对象可以理解为此次运行打包的上下文，所有打包过程中产生的结果，都会放到这个对象中。 class RemoveCommentsPlugin { apply (compiler) { compiler.hooks.emit.tap('RemoveCommentsPlugin', compilation => { // compilation => 可以理解为此次打包的上下文 for (const name in compilation.assets) { if (name.endsWith('.js')) { const contents = compilation.assets[name].source() const noComments = contents.replace(/\\/\\*{2,}\\/\\s?/g, '') compilation.assets[name] = { source: () => noComments, size: () => noComments.length } } } }) } } 常见问题 前端为什么打包 代码方面 体积更小（tree-shaking、压缩、合并）、加载更快 编译高级语言和语法（ts、es6、模块化、scss） 兼容性和错误检查(polyfill、postcss、eslint) 研发流程方面 统一、高效的开发环境 统一的构建流程和产出标准 继承公司构建规范（提测、上线等） 如何产出一个lib output:{ //lib文件名 filename:'lodash.js', //输出到dist目录下 path:disPath, //lib全局变量名 library:'lodash' } 为何proxy不能被polyfill 例如class可以用function模拟，promise可以用callback来模拟，但proxy无法被任何语法可以模拟取代 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/mvvm.html":{"url":"web前端/mvvm.html","title":"mvvm","keywords":"","body":" {{name}} 重置 class Wvue { constructor(option) { this.$option = option this.$data = option.data this.$methods = option.methods let that=this; Object.keys(option.data).forEach(function (key) { that.proxy(key); }); //数据劫持 this.observer(this.$data) //模板解析 this.$compile = new Compile(option.el, this) } observer(obj) { if (!obj || typeof obj !== \"object\") { return; } Object.keys(obj).forEach(key => { this.defineProperty(obj, key, obj[key]) }) } defineProperty(obj, key, val) { this.observer(val) const dep = new Dep() Object.defineProperty(obj, key, { get() { // 每次访问name 都会创建一个watcher，并加入到Dep中 Dep.target !== null && dep.addDep(Dep.target) return val }, set(newVal) { val = newVal dep.notify() } }) } proxy(key) { //使得读写vm的方法编程读写vm.data的 var that = this; Object.defineProperty(that, key, { configurable: false, enumerable: true, get() { return that.$data[key]; }, set(newVal) { that.$data[key] = newVal; } }); } } class Dep { constructor() { this.dep = [] } addDep(dep) { this.dep.push(dep) } notify() { // 通知所有的watcher执行更新 this.dep.forEach(watcher => { watcher.update() }) } } class Watcher { constructor(vm, key, cb) { this.$vm = vm this.$key = key this.$cb = cb // 用一个全局变量来指代当前watch Dep.target = this // 实际是访问了this.name，触发了当前变量的get， // 当前变量的get会收集当前Dep.target指向的watcher,即当前watcher this.$vm.$data[this.$key] Dep.target = null } update() { // 执行 // console.log(his.$vm[this.$key]) this.$cb.call(this.$vm, this.$vm[this.$key]) } } class Compile { constructor(el, vm) { this.$vm = vm // $el挂载的就是需要处理的DOM this.$el = document.querySelector(el) // 将真实的DOM元素拷贝一份作为文档片段，之后进行分析 const fragment = this.node2Fragment(this.$el) // 解析文档片段 this.compileNode(fragment) // 将文档片段加入到真实的DOM中去 this.$el.appendChild(fragment) } node2Fragment(el) { // 创建空白文档片段 const fragment = document.createDocumentFragment() let child // appendChild会把原来的child给移动到新的文档中，当el.firstChild为空时， // while也会结束 a = undefined => 返回 undefined while ((child = el.firstChild)) { fragment.appendChild(child); } return fragment } // 通过迭代循环来找出{{}}中的内容，v-xxx与@xxx的内容，并且单独处理 compileNode(node) { const nodes = node.childNodes // 类数组的循环 Array.from(nodes).forEach(node => { if (this.isElement(node)) { this.compileElement(node) } else if (this.isInterpolation(node)) { this.compileText(node) } node.childNodes.length > 0 && this.compileNode(node) }); } isElement(node) { return node.nodeType === 1; } isInterpolation(node) { return node.nodeType === 3 && /\\{\\{(.*)\\}\\}/.test(node.textContent) } compileText(node) { const reg = /\\{\\{(.*?)\\}\\}/g const string = node.textContent.match(reg) // RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个 子匹配(以括号为标志)字符串 // 以此类推，RegExp.$2，RegExp.$3，..RegExp.$99总共可以有99个匹配 this.text(node, RegExp.$1) } compileElement(node) { const nodeAttrs = node.attributes; Array.from(nodeAttrs).forEach(arr => { if (arr.name.indexOf('v-') > -1) { this[`${arr.name.substring(2)}`](node, arr.value) } if (arr.name.indexOf('@') > -1) { // console.log(node, arr.value) this.eventHandle(node, arr.name.substring(1), arr.value) } }) } // 因为是大括号里面的内容，所以沿用之前的逻辑，都加上watcher text(node, key) { new Watcher(this.$vm, key, () => { node.textContent = this.$vm.$data[key] }) // 第一次初始化界面， 不然如果不进行赋值操作， // 就不会触发watcher里面的回调函数 node.textContent = this.$vm.$data[key] } html(node, key) { new Watcher(this.$vm, key, () => { node.innerHTML = this.$vm.$data[key] }) node.innerHTML = this.$vm.$data[key] } // 对@xxx事件的处理 eventHandle(node, eventName, methodName) { node.addEventListener(eventName, () => { this.$vm.$methods[methodName].call(this.$vm) }) } // v-modal的处理 不仅仅当赋值的时候回触发watcher，并且为input添加事件 // input中的值去修改this.$data.$xxx的值，实现双向绑定 modal(node, key) { new Watcher(this.$vm, key, () => { node.value = this.$vm.$data[key] }) node.value = this.$vm.$data[key] node.addEventListener('input', (e) => { this.$vm.$data[key] = e.target.value }) } } const data = { el: '#app', data: { name: '米粒' }, methods: { reset() { this.name = '' } }, } const app = new Wvue(data) 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/redux.html":{"url":"web前端/redux.html","title":"redux","keywords":"","body":"基本形式 基本思路，reducer中创建所有state及其方法，在store中创建store对象，在组件中调用对应方法 //reducer.js import {combineReducers} from 'redux' function Count(state = 0, action){ switch(action.type){ case 'add': return state+action.val case 'del': return state-1 default: return state } } function Str(state = 'str', action){ switch(action.type){ case 'addS': return state+action.val case 'delS': return state-1 default: return state } } const data = combineReducers({ Count, Str }) export default data; //store.js import {createStore} from 'redux' import data from './reducer' const store = createStore(data) export default store; //组件中 store.dispatch({type:'add',val:5}) store.getState() useEffect(()=>{ store.subscribe(()=>{ console.log(store.getState()) }) },[]) 在使用store.dispatch对state进行操作时，我们传入action很麻烦（上例中的{type:'add',val:5}）我们将这个action抽离出来 //actionType.js export const ADD='add' export const DEL='del' export const ADDS='addS' export const DELS='delS' //action.js import * as type from './actionType' export function addNumber(val){ return { type:type.ADD, val } } export function delNumber(val){ return { type:type.DEL, val } } export function addString(val){ return { type:type.ADDS, val } } export function delString(val){ return { type:type.DELS, val } } //reducer.js import {combineReducers} from 'redux' import * as type from './actionType' function Count(state = 0, action){ switch(action.type){ case type.ADD: return state+action.val case type.DEL: return state-1 default: return state } } function Str(state = 'str', action){ switch(action.type){ case type.ADDS: return state+action.val case type.DELS: return state-1 default: return state } } const data = combineReducers({ Count, Str }) export default data; //store.js import {createStore} from 'redux' import Count from './reducer' const store = createStore(Count) export default store; //组件中 store.dispatch(addNumber(5)) redux与react的结合 为了简化某些组件，我们引入了展示组件的概念，在这个组件中，只用来做样式布局，而不进行数据的处理，这样我们只需要在父组件给他传入数据就可以了。相对应的容器组件只是为了处理数据和存放展示组件，redux-react可以协助你生成这样一个组件。 connect：用来创建容器组件 Provider：用来让子组件都可以拿到state mapStateToProps、mapDispatchToProps protoTypes： 对某个组件接受的props进行类型检查 我们需要自定义一个展示组件，但是你无需管理状态变量，只需要将他从props中取出使用，利用react-redux生成容器组建时，通过mapStateToProps、mapDispatchToProps定义了接受的state以及改变state的方法。在展示组件中的state他也会自动被检测，在发生变化时重新渲染。 值得注意的是，因为对于展示组件所有重要的操作全部由props传入，所以我们应该对prosp参数进行检查，防止出错 //app.js import Reactfrom 'react'; import {Home} from './component/home' import store from './store/stroe' import { Provider } from 'react-redux' function App() { return ( ); } export default App; //home.js import React from 'react'; import { addNumber } from '../store/action' import {connect} from 'react-redux' import PropTypes from 'prop-types' function HomeMsg(props){ const { value, onIncreaseClick } = props return ( {value} 增加 ) } //对Counter组件接受的props进行类型检查 HomeMsg.propTypes = { value: PropTypes.number.isRequired, //要求数字类型，没有提供会警告 onIncreaseClick: PropTypes.func.isRequired //要求函数类型 } // 将state映射到Counter组件的props function mapStateToProps(state) { return { value: state.Count } } // 将action映射到Counter组件的props function mapDispatchToProps(dispatch) { return { onIncreaseClick: () => dispatch(addNumber(5)) } } export const Home = connect( mapStateToProps, mapDispatchToProps )(HomeMsg) 异步Action action就是我们改变状态的动作，它包括了如何改变动作和改变的值。但是这个值我们通常是通过http请求得到的，而http请求通常又是异步的，所以这要求我们创建异步action applyMiddleware：用于在创建store的时候激活插件 thunk：react-thunk中间件，允许action creator返回一个函数，且接受dispatch和getState为参数 正常的话，我们发出一个动作就可以去改变一个状态，而http是异步请求，这就包含了三种状态，发送中、请求成功、请求失败。所以我们需要分别对这几种请坐创建对应的action动作。这三个动作是对接reducer函数的，我们需要再建立一个整合的与用户对接。 //action.js import * as type from './actionType' /*一个异步请求*/ function fetchAmount() { return fetch('http://xiawx.top/movie') } /*通知 reducer 请求开始的 action*/ function requestPosts() { return { type: type.REQUEST_POSTS, isFetch: true //进度条相关 } } /*通知 reducer 请求成功的 action*/ function receviePostOnSuccess(data) { return { type: type.RECEIVE_POSTS, isFetch: false, amount: data } } /*通知 reducer 请求失败的 action。*/ function receviePostOnError(message) { return { type: type.RECEIVE_POSTS, isFetch: false, errorMsg: message } } /*异步请求action 【将上面3个基础的action整合】*/ export function getAmount() { return dispatch => { // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) //异步请求后端接口 return fetchAmount().then(res=>res.json()).then( data => dispatch(receviePostOnSuccess(data)), error => dispatch(receviePostOnError('error')) ) } } //reducer.js function getData(state=[],action){ switch (action.type) { case type.RECEIVE_POSTS: return state=action.amount.content case type.REQUEST_POSTS: return state default: return state } } export default getData; //store.js import {createStore,applyMiddleware} from 'redux' import getData from './reducer' import thunk from 'redux-thunk'; const store = createStore( getData, applyMiddleware(thunk) ) export default store; 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/前端算法总结.html":{"url":"web前端/前端算法总结.html","title":"前端算法总结","keywords":"","body":"基础 时间复杂度 当前代码块执行了多少遍，多个代码块并排时（O(n)+O(1)=O(n)），去最大的时间复杂度，嵌套时则复杂度x相乘O(n)*O(n)=O(n^2) // 时间复杂度O(logN) // log(2)N 表示2的多少次数为N let i = 1 while(i 空间复杂度 算法在运行过程中临时占用存储空间的大小，也有O来表示 数据结构 栈 特点：后进先出（push，pop） 栈的定义： const stack=[]; stack.push(1); //进栈 const item=stack.pop(); //出栈 队列 特点：先进先出 队列的定义： const queue=[]; queue.push(1); //进队 queue.shift(); //出队 链表 特点：多元素组成，存储不连续，用next指针连在一起 优点：队列在增减非首尾元素时，需要移动过多元素，而链表只需要更改next 链表的定义： const a ={val:'a'} const b ={val:'b'} const c ={val:'c'} const d ={val:'d'} a.next = b; b.next = c; c.next = d; // 遍历 let p = a; while(p){ console.log(p.val); p = p.next; } // 插入e const e = {val:'e'} e.next = d; c.next = e; // 删除e c.next = d;（e被回收） 构造函数形式定义 function ListNode(){ this.val=val; this.next=null; } //node为ListNode的实例 //删除 时间O(1) 空间O(1) var del = node => { node.val=node.next.val; node.next=node.text.next; } //反转 时间O(n) 空间O(1) var reverseList = head => { let p1 = head; let p2 = null; while(p1){ const tmp = p1.next p1.next = p2; p2 = p1; p1 = tmp; } return p2; } 使用场景： // 使用链表指针获取json节点值 const json={ a:{b:{c:1}}, d:{e:2} } const path=['a','b','c'] //获取方式 let p = json; path.forEach(k=>{ p=p[k]; }); console.log(p); 集合 特点：无序且唯一 集合的定义： const set = new Set(); set.add(value) //添加元素 set.clear() //清空集合 set.delete(value) //删除元素 set.has(value) //判断是否存在 set.size() //元素个数 // 迭代 for(let item of set) consle.log(item) for(let item of set.keys()) consle.log(item) for(let item of set.values()) consle.log(item) for(let [key,value] of set.entries()) consle.log(item) // set Array 转换 const arr = [...set] const arr = Array.from(set) const set = new Set(arr) 使用场景： // 去重 const arr=[1,1,2,3]; const arr2 = [...new Set(arr)]; // 判断元素是否在集合中 const set = new Set([1,2,3]); const has = set.has(2) // 求交集 const set1 = new Set([1,2,3]); const set2 = new Set([2,3,4]); const set3 = new Set([...set1].filter(item=>set2.has(item))) 字典 特点：类似集合，通过键值对来存储 字典的定义： const map = new Map(); // 增 map.set('key','value') // 删 map.delete('key') map.clear() // 改 map.set('key','val') // 查 map.get('key') 使用场景： // 求交集 var intersection = function(num1,num2){ const map = new Map(); num1.forEach(n=>{ map.set(n,true) }) const res = []; num2.forEach(n => { if(map.get(n)){ res.push(n) map.delete(n) } }) return res; } // 代替if语句 if(t===\"a\" || t===\"b\" || t===\"c\") return map.set(\"a\",true) map.set(\"b\",true) map.set(\"c\",true) if(map.has(t)) return // 代替二维映射关系 （多组例如“xwx”对应21的数据） if(a===\"xwx\" && b===21) return map.set(\"xwx\",21) if(map.get(\"xwx\")===21) return 树 特点： 深度优先遍历：先遍历到一棵树的最底端，再遍历第二棵 广度优先遍历：现遍历距离当前节点最近的节点 先中后序遍历：先中后指的是什么时候遍历根节点，例如先序遍历指的是先遍历根节点 树的定义： // 数据结构 const tree = { val:'value', children:[], } // 深度优先遍历【1、访问根节点。2、对根节点每个children进行深度优先遍历】 const dfs = (root) => { console.log(root.val); root.children.forEach(dfs) } // 广度优先遍历【1、新建一个队列，把根节点入队。2、把队头出队并访问。3、把队头的children挨个入队。4、重复二、三步，知道队列为空】 const bfs = (root) => { const q = [root]; while(q.length>0){ const n = q.shift(); console.log(v.val); n.children.forEach(child => { q.push(child) }) } } // 二叉树数据结构 const binaryTree = { val: 'value', left: null, right: null, } // 以下遍历分为递归版遍历和非递归版遍历(利用栈的数据结构) // 先序遍历【1、访问根节点。2、对根节点的左子树进行先序遍历。3、对根节点的右子树进行先序遍历】 const preorder = (root) => { if(!root) return; console.log(root.val); preorder(root.left); perorder(root.right); } const preorder = (root) => { if(!root) return; const stack = [root]; while(stack.length){ const n = stack.pop(); console.log(n.val); if (n.right) stack.push(n.right); if (n.left) stack.push(n.left); } } // 中序遍历【1、对根节点的左子树进行中序遍历。2、访问根节点。3、对根节点的右子树进行中序遍历。】 const inorder = (root) => { if(!root) return; inorder(root.left); console.log(root.val); inorder(root.right); } const inorder = (root) => { if(!root) return; const stack = []; let p = root; while(stack.length || p){ while(p){ stack.push(p); p = p.left; } const n = stack.pop(); console.log(n.val); p = n.right; } } // 后序遍历【1、对根节点的左子树进行后序遍历。2、对根节点的右子树进行后序遍历。3、访问根节点。】 const postorder = (root) => { if(!root) return; postorder(root.left); postorder(root.right); console.log(root.val); } const postorder = (root) => { // 利用先序遍历入栈，然后倒着输出 if(!root) return; const outputStack = []; const stack = [root]; while(stack.length){ const n = stack.pop(); outputStack(n); if(n.left) stack.push(n.left) if(n.right) stack.push(n.right) } while(outputStack.length){ const n = outputStack.pop(); console.log(n.val); } } // 二叉树最大深度【利用深度优先遍历】 // 时间复杂度: O(n) // 空间复杂度: 最优O(logN) 最差O(n) const maxDepth = (root) => { let res = 0; const dfs = (n,l) => { if(!n) return; (!n.left && !n.right) && res = Math.max(res,l) dfs(n.left,l++); dfs(n.left,l++) } return res; } // 二叉树的最小深度【利用广度优先遍历】 // 时间复杂度: O(n); // 空间复杂度: O(n) const minDepth = (root) => { if(!root) return 0; const q = [[root,1]; while(q.length){ const n =q.shift(); if(!n.left && !n.right) return l; if(n.left) q.push([n.left,l++]) if(n.right) q.push([n.right,l++]) } } 使用场景： // 渲染Antd中的树组件 const json = [{title:'',key:'',children:[]}]; const Com = () => { const dfs = (n) => ( {n.children.map(dfs)} ) return {json.map(dfs)} } 堆 特点： 堆是一种特殊的完全二叉树，特殊在所有节点都大于等于它的子节点或者都小于等于它的子节点（最大堆、最小堆）。 因为他是完全二叉树，所以在JS中可以用数组来表示堆 左侧子节点的位置是2*index+1（index从0开始计） 右侧子节点的位置是2*index+2 父节点的位置(index-1)/2 因为是数组的原因，所以可以很快的找到某个节点的关系节点。堆可以高效快速的找到最大最小值，即时间复杂度为O(1)。 堆的定义： // 最小堆列及其插入、删除堆顶、获取堆顶、获取堆的大小 class MinHeap{ constructor(){ this.heap = []; } getLeftIndex(i){ return i * 2 + 1 } getRightIndex(i){ return i * 2 + 2 } getParentIndex(i){ return (i - 1) >> 1;// 除2取商 } swap(i1,i2){ const temp = this.heap[i1]; this.heap[i1] = this.heap[i2]; this.heap[i2] = temp; } shiftUp(index){ //上移操作 if(index == 0) return; const parentIndex = this.getParentIndex(index); if(this.heap[parentIndex]>this.heap[index]){ this.swap(parentIndex, index); this.shiftUp(parentIndex); } } shiftDown(index){ //下移操作 const leftIndex = this.getLeftIndex(index); const rightIndex = this.getRightIndex(index); if(this.heap[leftIndex] { // 时间复杂度 O(N*logK) // 空间复杂度 O(K) const h = new MinHeap(); nums.forEach(n => { h.insert(n); h.size>k && h.pop }) return h.peek(); } 排序 冒泡排序 遍历n-1遍，比较相邻元素，将最大的冒泡到最后面 时间复杂度：O(n*2) 空间复杂度：O(1) Array.prototype.bubbleSort = function() { for(let i=0;ithis[j+1]){ const tem=this[j]; this[j]=this[j+1]; this[j+1]=tem; } } } return arr } 选择排序 遍历n-1遍，每一遍遍历完成后将最小的置于最前面 时间复杂度：O(n*2) 空间复杂度：O(1) Array.prototype.selectionSort = function() { for(let i=0;i 插入排序 进行n-1轮，第二个数开始和前面的每个数相比比，比他大就往后排，一次类推进行到最后一个数。 时间复杂度：O(n^2) Array.prototype.insertSort = function(){ for(let i=1;i0){ if(this[j-1]>temp){ this[j]=temp[j-1] }else{ break; } j--; } this[j]=temp; } } 归并排序 （分）把数组劈成两半，再分别对子数组进行分的操作，知道分成一个个单独的数。（合）把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组。 新建一个空数组res，用域存放最终排序后的数组，比骄傲两个有序数组的头部，较小者出队推入 res，如果两个数组还有数值，就重复比较头部的步骤。 时间复杂度：O(n*logN) Array.prototype.mergeSort = function () { const rec = (arr) => { if (arr.length === 1) return arr const mid = Math.floor(arr.length / 2); const left = arr.slice(0,mid); const right = arr.slice(mid,arr.length); const orderLeft = rec(left); const orderRight = rec(right); const res= []; while (orderLeft.length || orderRight.length) { if (orderLeft.length && orderRight.length){ res.push(orderLeft[0] this[i]=n); } 快速排序 数组中任意选择一个“基准”，所有比基准小的放在基准前面，比基准大的放到它的后面。递归实现上述操作。 时间复杂度：O(n*logN) Array.prototype.quickSort = function(){ const rec = () => { if(arr.length === 1){return arr;} const left = []; const right = []; const mid = arr[0]; for(let i = 1;i{this[i]=n}) } 搜索 顺序搜索 遍历数组 时间复杂度：O(n) Array.prototype.sequentialSearch = function (item){ for(let i = 0; i 二分搜索（折半搜索） 搜索数组必须有序，从中间元素开始，如果中概念元素正好是目标值，则搜索结束。如果目标大于或小于中间元素，则在大于或者小于中间元素的那一半继续进行上述过程。 时间复杂度：O(logN) Array.prototype.binarySearch = function(item){ let low = 0; let high = this.length - 1; while(lowitem){ high=mid-1; }else { return mid; } } return -1; } 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/http.html":{"url":"web前端/http.html","title":"http","keywords":"","body":"http http特点 高延迟：对头堵塞 队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。 对于对头堵塞的解决方案： 将同一页面的资源分散到不同域名下，提升连接上限。 Spriting合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。 内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。 拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件 无状态特性--带来的巨大HTTP头部 明文传输--带来的不安全性 http2新特性 谷歌推出SPDY，才算是正式改造HTTP协议本身。降低延迟，压缩header等等，SPDY的实践证明了这些优化的效果，也最终带来HTTP/2的诞生。 SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 SPDY 协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 二进制传输 HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。 header压缩 HTTP/2并没有使用传统的压缩算法，而是开发了专门的\"HPACK”算法， 多路复用 很多浏览器有一个限制，例如chrome，对于同一个域名，默认允许同时建立6个TCP持久连接，使用持久连接时，虽然能公用一个tcp管道，但是在一个管道中同一时刻只能处理一个请求。在当前请求没有结束之前，其他的请求只能处于堵塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。 在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了 同域名下所有通信都在单个连接上完成。 单个连接可以承载任意数量的双向数据流。 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。 server push HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为\"服务器推送\" 提高安全性 互联网上通常所能见到的HTTP/2都是使用\"https”协议名，跑在TLS上面。 https http存在的问题 通信使用明文（不加密），内容可能被窃听：HTTP报文使用明文（指未经过加密的报文）方式发送。 无法证明报文的完整性，所以可能遭篡改：没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。 不验证通信方的身份，因此有可能遭遇伪装：HTTP协议中的请求和响应不会对通信方进行确认 https的解决方案 解决内容被窃听：加密 http直接和tcp通讯，HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。 TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性 对称加密：加密解密使用同一个密钥（获取到密钥即可破解） 非对称加密：使用公钥加密，私钥解密（公钥公开，对于私钥加密信息，黑客后去公钥后即可破解；公钥不包括服务器信息，存在中间人攻击风险；降低传输速率） 对称加密+非对称加密(HTTPS采用这种方式)：发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信。 解决报文被篡改：数字签名 数字签名的功效： 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。 数字签名能确定消息的完整性,证明数据是否未被篡改过。 签名生成： 将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。 校验签名： 接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。 解决通讯身份可能被伪装：数字证书 数字证书认证机构的业务流程： 服务器的运营人员向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证; CA审核; CA会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。 其中签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名; 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件; 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。 https工作流程 1.Client发起一个HTTPS（比如https://juejin.im/user/5a9a9cdcf265da238b7d771c）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。 3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。 5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。 6.Server使用对称密钥加密“明文内容A”，发送给Client。 7.Client使用对称密钥解密响应的密文，得到“明文内容A”。 8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/vue常见插件.html":{"url":"web前端/vue常见插件.html","title":"vue常见插件","keywords":"","body":"axios 基本用法 get 常见的方法有get请求 axios调用http有两种方法，他们是 //get方法 axios.get('/data.json',{ params:{ id:12 } }).then(res=>{ console.log(res) }) 和 //get方法 axios({ method:'get', url:'/data.json', params:{ id:12 } }).then(res=>{ console.log(res) }) post 上面是get的请求，接下来为post请求。对于post请求常常伴随着数据、文件传输。通常格式有form-data是之前表单提交的格式，它常用于图片或者文件的上传。另一种是applicition/json，以json的格式去上传。 首先是表单格式 let formData=new FormData() let data={id:12} for(let key in data){ formData.append(key,data[key]) } axios.post('/post',formData) axios.post('/post',{ method:'post', url:'/post', data:formData }) 然后是json格式 let data={id:12} axios.post('/post',data) axios.post({ method:'post', url:'/post', data:data }) 并发请求 例如我们要同时请求两个接口，将数据一起处理，那么就需要用到并发请求 axios.all( [ axios.get('/data.json'), axios.get('/nav.json') ] ).then(axios.spread((res1,res2)=>{ console.log(res1,res2) })) 深入 实例 实例上有很多可配置的方法和操作，通过使用实例更加的方便便捷 let instance=axios.creat({}) instance.get('/data').then(()=>{ console.log(res) }) 配置 例如我们像设置一个基础超时时长，我们就要设置，配置参数的方法有三种 //优先级顺序 //全局配置 axios.defaults.timeout=1000 //实例配置 let axi=axios.creat({timeout:1000}) //请求配置 axios.get('/api',{ timeout:5000 }) 常见的参数有 let instance=axios.creat({ baseURL:'http://localhost:8080',//基本地址 timeout:1000,//超时时长 url:'/data.json',//请求路径 method:'get',//请求方法 headers:{},//设置请求头 params:{},//将参数拼接url上 data:{},//把请求参数放到请求体里 }) instance.get('/data').then(()=>{ console.log(res) }) 拦截器 在请求或响应处理前拦截他们并做一些处理 请求拦截器 axios.interceptors.request.use//请求前的回调，请求失败后的回调 (config=>{ //操作 return config },err=>{ //请求错误时操作 return Promise.reject(err) }) 响应拦截器 axios.interceptors.response.use//请求成功的回调，响应错误后的回调 (res=>{ //操作 return res },err=>{ return Promise.reject(err) }) 取消拦截器 let interceptors=exios.interceptors.request.use(config=>{ config.headers={ auth:true } return config }) axios.interceptors.request.eject(interceptors) 拦截器的例子 例如当我们需要获取token再进行请求时，我们会用到请求拦截器 let ins=axios.create({})//访问需要登录的接口 ins.interceptors.request.use(config=>{ config.headers.token='' return config }) let ins2=axios.create({})//访问不需要登录的接口 再例如移动端开发时,当我们请求时弹出一个提示框显示正在加载中 let ax=axios.create({}) let ax2=axios.create({}) ax.interceptors.request.use(config=>{ $('#modal').show() return config }) ax.interceptors.response.use(res=>{ $('#modal').hide() return res }) 错误处理 错误处理的三种方式 axios.interceptors.request.use (config=>config,err=>{ $('#modal').show()//提示框提示请求错误 setTime(()=>{ $('#modal').hide() }2000) return Promise.reject(err) }) axios.interceptors.response.use (res=>res,err=>{ $('#modal').show() setTime(()=>{ $('#modal').hide() }2000) return Promise.reject(err) }) axios.get('/data.json').then(res=>{console.log(res)}).catch((res)=>{ //操作 console.log(err) }) 取消请求 用于取消正在进行的http请求 let souce=axios.CancelToken.source() axios.get('/data.json',{ CancelToken:souce.token }).then(res=>{ console.log(res) }).catch(err=>{ console.log(err) }) //取消请求 参数为传入的信息 该信息会被内catch捕捉到 source.cancel('cancel http') 例如，在一个后台管理系统中，用户查询一个数据可能会很慢，达到三秒至五秒，如果用户点击了查询突然不想查了，这时就会需要取消查询 封装 每一个请求我们都要写一遍错误捕捉或者一切成功后调用的方法，如果每写一个就写一遍，会造成代码冗余 封装文件 import axios from 'axios' import {baseURL} from '@/config' import {MessageBox,Message,Loading} from 'element-ui' import router from '@/router/index' class HttpRequest{ //封装axios constructor(baseUrl){ baseUrl = 'http://xiawx.top' this.baseUrl = baseUrl; } getInstdeConfig(){ const config ={ baseUrl:this.baseUrl, headers:{ \"token\":\"\" } } return config } //拦截器 interceptors(instance,url){ instance.interceptors.request.use(config => { if (localStorage.getItem('token')) { // 判断是否存在token config.headers.token = localStorage.getItem('token'); } return config },error => { Message.error({message: '请求超时!'});//ui组件 return Promise.reject(error) }) instance.interceptors.response.use(res => { if(res.data.meta.code == '-2'){ MessageBox('登录超时,请重新登录!','登录超时')//ui组件 } return res },error => { if (error.response) { switch (error.response.status) { case 401: //401 store.commit(types.LOGOUT); router.replace({ path: 'login', query: {redirect: router.currentRoute.fullPath} }) } } return Promise.reject(error.response.data) // 返回接口返回的错误信息 }) } request(options){ //创建一个请求 //创建实例 var _this = this; const instance = axios.create({ baseURL: _this.baseUrl, timeout: 3000, // 携带凭证 withCredentials: true }) options = Object.assign(this.getInstdeConfig(),options) this.interceptors(instance,options.url) return instance(options) } } export default HttpRequest 再创建一个文件把某个模块中所有请求操作放在里面，只暴露方法 export const getLoginInfo = (data) => { return HttpRequest.request({ url: '/login/' + data.username + '/' + data.password + '/' + data.role, method: 'post', data: data }) } bus 基本用法 当项目较小，无需使用vuex但仍然需要组件间通讯时，我们可以选择使用bus 全局的定义（app.js） var eventBus = { install(Vue,options) { Vue.prototype.$bus = vue//bus就是一个vue对象 } }; Vue.use(eventBus); 分发事件的组件 methods: { todo: function () { this.$bus.$emit('todoSth', params); //params是传递的参数 //... } } 监听的组件 // ... created() { this.$bus.$on('todoSth', (params) =&gt; { //获取传递的参数并进行操作 //todo something }) }, // 最好在组件销毁前 // 清除事件监听 beforeDestroy () { this.$bus.$off('todoSth'); } echarts 一个用于创建绘制图表的npm第三方库 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/reactNative.html":{"url":"web前端/reactNative.html","title":"reactNative","keywords":"","body":"react native 项目启动 在电脑装有node10、python2*、sdk、jdk、gradle、nox的环境下 直接使用npx react-native init AwesomeProject,也可以先下载脚手架npm -g install react-native-cli,然后安装项目react-native init AwesomeProject 确保在nox的bin目录下的nox_adb version与全局下的adb version是一个版本，如不是，则复制过去 在命令行输入 nox_adb connect 127.0.01：62001 在命令行输入 adb devices 进入项目中打包，react-native run-android ,并输入npm start 打开nox模拟器，在setting中设置IP为172.17.100.2：8081 重启模拟器 再次启动时，直接运行npm start然后打开模拟器上的apk就可以了 样式 import React, { Component } from 'react'; import { StyleSheet, Text, View } from 'react-native'; export default class LotsOfStyles extends Component { render() { return ( just red just bigBlue bigBlue, then red red, then bigBlue ); } } const styles = StyleSheet.create({ bigBlue: { color: 'blue', fontWeight: 'bold', fontSize: 30, }, red: { color: 'red', }, }); 常见标签 View 创建 UI 时最基础的组件，直接对应一个平台的原生视图，IOS中的 UIView、Android中的android.view和Web中的div等 Text 一个用于显示文本的 RN 组件，支持嵌套、样式，以及触摸处理，可继承样式 元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。 Image 用于显示多种不同类型图片的 React 组件，包括网络图片、静态资源、base64图片等。 export default class DisplayAnImage extends Component { render() { return ( ); } } 属性：resizeMode 决定当组件尺寸和图片尺寸不成比例的时候如何调整图片的大小。默认值为cover。 cover: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸（如果容器有 padding 内衬的话，则相应减去）。 contain: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸（如果容器有 padding 内衬的话，则相应减去）。译注：这样图片完全被包裹在容器中，容器中可能留有空白。 stretch: 拉伸图片且不维持宽高比，直到宽高都刚好填满容器。 repeat: 重复平铺图片直到填满容器。图片会维持原始尺寸，但是当尺寸超过容器时会在保持宽高比的前提下缩放到能被容器包裹。 center: 居中不拉伸。 ImageBackground 添加背景色，必须指定 width 和 height，通过 source 属性指定 背景图片 Inside TextInput 用户在应用中通过键盘输入文本的基本组件,必须通过 onChangeText事件来读取用户的输入 value onChangeText onSubmitEditing onFocus ScrollView 封装了平台的ScrollView（滚动视图）的组件 Button 跨平台的按钮组件 {}} title=\"按钮\" color=\"#841584\" /> TouchableOpacity 不透明度会变化的按钮 FlatList 高性能的简单列表组件 {}} //下拉刷新 refreshing={false} //下拉刷新时的加载样式，此处应手动更改，在触发下拉加载时将值改为true，加载完成后改为false onEndReached={()=>{}} //上拉加载 onEndReachedThreshold:10 //距离底部多少距离触发上拉下载函数 renderItem={({item}) => {item.key}} /> SectionList 高性能的简单列表组件，在每组数据上方可以加一个表头样式（自定义标签） StatusBar 状态栏 路由 安装 yarn add react-native-router-flux 切换路由后，之前的路由在状态会保存。 ## 默认页 Actions.doc({count:1})/> {{this.props.count}} 我们也可以实现tab栏 }> Tabs 功能 ... import { Tabs } from 'react-native-router-flux'; //设置tab选中时的字体颜色和标题 const TabIcon = ({focused , title}) => { return ( {title} ); }; const Root = () => { return ( ) }; Drawer 侧边栏 Lightbox 路由转跳从下方出现 ... Modal 路由转跳以整个新页面的形式 ... Actions [key] : Actions.key( ) or Actions[key].call( ) pop( ) replace( ) refresh( ) reset( ) currentScene: 返回当前的 Scene drawerOpen drawerClose 第三方组件 ActivityIndicator Animated 创建动画 使用组件前加Animated //1. 创建样式初始值 this.state = { opacity: new Animated.Value(0) } //2.定时样式值变化 Animated.timing( // timing方法使动画值随时间变化 this.state.opacity, // 要变化的动画值 { toValue: 1, // 最终的动画值 duration: 500, delay: 0 }, ).start( callback ); // 动画完成后可调用 callback // *timing可以换成spring，有反弹效果动画 WebView yarn add react-native-webview react-native link react-native-webview import { WebView } from 'react-native-webview'; ; react-native-image-picker 打开摄像机功能 安装并 link yarn add react-native-image-picker react-native link react-native-image-picker 在 android\\app\\src\\main\\AndroidManifest.xml 添加 在 android\\app\\src\\main\\Java\\com\\projectname\\MainActivity 中添加 //开头 import com.imagepicker.permissions.OnImagePickerPermissionsCallback; // 使用 import ImagePicker from 'react-native-image-picker'; const options = { title: 'Select Avatar', customButtons: [{ name: 'fb', title: 'Choose Photo from Facebook' }], storageOptions: { skipBackup: true, path: 'images', }, }; ImagePicker.showImagePicker(options, (response) => { if (response.didCancel) { return; } else if (response.error) { console.log('Error:', response.error); } else if (response.customButton) { console.log('custom:', response.customButton); } else { const source = { uri: response.uri }; this.setState({ avatarSource: source, }); } }); react-native-image-crop-picker yarn add react-native-image-crop-picker react-native link react-native-image-crop-picker ImagePicker.openCamera({ width: 300, height: 400, cropping: true, }).then(image => { this.setState({imgUrl:image.path}) }); react-native-button yarn add react-native-button import Button from 'react-native-button'; 文本 react-native-message-bar yarn add react-native-message-bar import React from 'react'; import { MessageBar, MessageBarManager } from 'react-native-message-bar'; export default class extends React.Component { componentDidMount() { MessageBarManager.registerMessageBar(this.refs.alert); } componentWillUnmount() { MessageBarManager.unregisterMessageBar(); } render() { return ; } } react-native-vector-icons 图标地址 //1. 安装 yarn add react-native-vector-icons //2. link，执行完在 项目\\android\\app\\src\\main\\assets\\fonts 文件夹下会多出 ttf 格式的图标文件 react-native link react-native-vector-icons //3. 卸载 App，重新 react-native run-android //4. 引入 Icon 组件，注意后面的 / ,后面是哪个文件，将来就在 图标地址 哪一栏找图标名字 import Icon from 'react-native-vector-icons/FontAwesome'; ; react-native-swiper yarn add react-native-swiper@nightly import Swiper from 'react-native-swiper'; Hello Swiper Beautiful And simple 尺寸 px：图片中最小的一格 dpi（dot per inch）：每英寸上有多少个小格，格越多越清晰 dp：安卓开发中使用的单位。1dp=像素密度为160dpi时1px的大小 const {width,height,scale} = Dimensions.get('window') /* width屏幕宽度 height屏幕高度 scale像素密度与160的比值，例如在320dpi的像素密度下，1dp=2px */ 布局技巧 弹性盒子 /*父组件中*/ { flexDirection:'row', /*使子元素横向布局*/ justifyContent:'space-evenly'/*间隔均分*/ } 元素居中 { alignItems:\"center\"/*垂直居中*/ justifyContent:'space-evenly'/*当空间只有一个元素时，水平居中*/ } 横排元素超出换行 { flexWarp:'wrap' } 返回键设置 BackHandler.addEventListener('back', () => { console.log(tag) if (tag) BackHandler.exitApp();//使用该方法退出app tag = true; setTimeout(() => { tag = false }, 1000) return true;//当返回为true时，按返回键不会退出 }) 本地存储 AsyncStorage组件用法 AsyncStorage.setItem('userName':'helloword',()=>{/*回调函数*/})//存储键值对 AsyncStorage.setItem('userName').then((res)=>console.log(res))//返回一个promise 打包 1、生成一个签名密钥 keytool -genkeypair -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 这条命令会要求你输入密钥库（keystore）和对应密钥的密码，然后设置一些发行相关的信息。最后它会生成一个叫做my-release-key.keystore的密钥库文件。 在运行上面这条语句之后，密钥库里会生成一个单独的密钥，有效期为 10000 天。--alias 参数后面的别名将来为应用签名时需要用到，所以必须记住这个别名。 2、设置 gradle 变量 把my-release-key.keystore文件放到你工程中的android/app文件夹下 编辑项目目录/android/gradle.properties，加上如下代码 MYAPP_RELEASE_STORE_FILE=my-release-key.keystore MYAPP_RELEASE_KEY_ALIAS=my-key-alias MYAPP_RELEASE_STORE_PASSWORD=***** MYAPP_RELEASE_KEY_PASSWORD=***** 3、把签名配置加入到项目的 gradle 配置中 编辑项目目录下的android/app/build.gradle，添加如下签名配置： ... android { ... defaultConfig { ... } signingConfigs { release { if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) { storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD } } } buildTypes { release { ... signingConfig signingConfigs.release } } } ... 4、生成发行APK 包 进到项目的 android 目录，执行如下命令 ./gradlew assembleRelease 5、更换 logo 图标 将项目android\\app\\src\\main\\res下的文件夹中图片都换掉，重新打包即可。 可用如下地址生成各个尺寸的图片。 地址：https://icon.wuruihong.com/ 6、更换项目名称 将项目目录下的 android\\app\\src\\main\\res\\values 中的 strings.xml 中的名称改掉即可 配置ts环境 使用 TypeScript 模板创建新项目 react-native init MyApp --template react-native-template-typescript 现有项目添加 TypeScript yarn add --dev typescript @types/jest @types/react @types/react-native @types/react-test-renderer 在项目根目录下创建一个 TypeScript 配置文件（tsconfig.json） { \"compilerOptions\": { \"allowJs\": true, \"allowSyntheticDefaultImports\": true, \"esModuleInterop\": true, \"isolatedModules\": true, \"jsx\": \"react\", \"lib\": [\"es6\"], \"moduleResolution\": \"node\", \"noEmit\": true, \"strict\": true, \"target\": \"esnext\" }, \"exclude\": [ \"node_modules\", \"babel.config.js\", \"metro.config.js\", \"jest.config.js\" ] } 在项目根目录创建一个jest.config.js文件 module.exports = { preset: 'react-native', moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'], }; 重命名一个 JavaScript 文件为 *.tsx 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/spa富应用开发.html":{"url":"web前端/spa富应用开发.html","title":"spa富应用开发","keywords":"","body":"前端的发展 1993年，出现表单，使得网页中可以有数据的流动 1995年，js出现，可以为网页添加一些动态效果 1996年，flash的出现，使得网页动画等动态效果称为可能 1998年，css产生，将网页的样式抽离出来 1999年，微软在ie5中实现了xmlhttprequest这个API 2005年，Google发布Gmail，采用了ajax技术，标志了前后端分离的产生 2007年，为了在手机端实现良好的网页效果，出现了网格布局等 2011年，h5发布，前端领域逐渐兴起 前端集成的方案 前端行业经历了这么长时间的发展，技术元素非常丰富，这里列举出一般web团队需要用到的技术元素： 开发规范：包括开发、部署的目录规范，编码规范等。不要小瞧规范的威力，可以极大的提升开发效率，真正优秀的规范不会让使用者感到约束，而是能帮助他们快速定位问题，提升效率。 模块化开发：针对js、css，以功能或业务为单元组织代码。js方面解决独立作用域、依赖管理、api暴露、按需加载与执行、安全合并等问题，css方面解决依赖管理、组件内部样式管理等问题。是提升前端开发效率的重要基础。现在流行的模块化框架有requirejs、seajs等。 组件化开发：在模块化基础上，以页面小部件(component)为单位将页面小部件的js、css、html代码片段放在一起进行开发、维护，组件单元是资源独立的，组件在系统内可复用。比如头部(header)、尾部(footer)、搜索框(searchbar)、导航(menu)、对话框(dialog)等，甚至一些复杂的组件比如编辑器(editor)等。通常业务会针对组件化的js部分进行必要的封装，解决一些常见的组件渲染、交互问题。 组件仓库：有了组件化，我们希望将一些非常通用的组件放到一个公共的地方供团队共享，方便新项目复用，这个时候我们就需要引入一个组件仓库的东西，现在流行的组件库有bower、component等。团队发展到一定规模后，组件库的需求会变得非常强烈。 性能优化：这里的性能优化是指能够通过工程手段保证的性能优化点。由于其内容比较丰富，就不在这里展开了，感兴趣的同学可以阅读我的这两篇文章 [1] [2]。性能优化是前端项目发展到一定阶段必须经历的过程。这部分我想强调的一点是 性能优化一定是一个工程问题和统计问题，不能用工程手段保证的性能优化是不靠谱的，优化时只考虑一个页面的首次加载，不考虑全局在宏观统计上的优化提升也是片面的。 项目部署：部署按照现行业界的分工标准，虽然不是前端的工作范畴，但它对性能优化有直接的影响，包括静态资源缓存、cdn、非覆盖式发布等问题。合理的静态资源资源部署可以为前端性能带来较大的优化空间。 开发流程：完整的开发流程包括本地开发调试、视觉效果走查确认、前后端联调、提测、上线等环节。对开发流程的改善可以大幅降低开发的时间成本，工作这些年见过很多独立的系统（cms系统、静态资源推送系统）将开发流程割裂开，对前端开发的效率有严重的阻碍。 开发工具：这里说的工具不是指IDE，而是工程工具，包括构建与优化工具、开发-调试-部署等流程工具，以及组件库获取、提交等相关工具，甚至运营、文档、配置发布等平台工具。前端开发需要工具支持，这个问题的根本原因来自前端领域语言特性（未来我会单独写一篇文章介绍前端领域语言缺陷问题）。前端开发所使用的语言（js、css、html）以及前端工程资源的加载与定位策略决定了前端工程必须要工具支持。由于这些工具通常都是独立的系统，要想把它们串联起来，才有了yeoman这样的封装。前面提到的7项技术元素都直接或间接的对前端开发工具设计产生一定的影响，因此能否串联其他技术要素，使得前端开发形成一个连贯可持续优化的开发体系，工具的设计至关重要。 以上8项，1-3是技术和业务相关的开发需求，4是技术沉淀与共享需求，5-8是工程优化需求。 常用工具 npm i -g htmlhint ##静态代码检查工具 npm i -g csslint ##静态代码检查工具 npm i -g eslint ##静态代码检查工具 npm - -g browser-sync ##热加载工具 自动化构建 github版本控制 创建github仓库,本地创建md笔记以及SUMMARY.md文件作为目录 初始化npm环境，下载gitbooknpm i gitbook-cli -D 上传内容到主分支 打包gitbook build,打包后出现_book目录，进入目录，将此目录与本库的gh-pages关联，并上传。 通过访问https://githubname.github.io/repositories 持续集成 在tarvis CI关联github，并选择要测试的项目，也可以设置环境变量 在主分支，创建.travis.yml，写入配置 上传到远程仓库，github会自动执行配置文件中的过程 总结： master分支中，有文章的md格式文档、summary目录、travis配置文件、依赖配置文件package（包含gitbook-cli模块） gh-pages分支中，即为gitbook build打包后，_book目录下的全部内容 travis配置文件: language: node_js node_js: - \"node\" after_script: - gitbook build - cd ./_book - git init - git config user.name \"${USER_NAME}\" - git config user.email \"${USER_EMAIL}\" - git add . - git commit -m \"publish gitbook\" - git push --force --quiet \"https://${ACC_TOKEN}@${GH_REF}\" master:${BRANCH} branches: only: - master ##ACC_TOKEN:token指令 ##GH_REF:仓库地址 ##BRANCH:分支名 ## 编译预处理 通常我们会使用一些高级语言进行开发，而浏览器只支持html、css、js基本代码，所以我们要在开发结束后，将高级代码预处理为基本代码。例如css的超集有less、sass、scss，js的超集有typescript、coffee script。 与上面相同，我们借助grunt的插件来将代码进行预处理。 以less为例 首先需要下载用到的插件 npm i -g grunt-cli npm i -D grunt grunt-contrib-less 编写Gruntflie.js文件，以下是基本框架 module.exports=function(grunt){ grunt.initConfig(); grunt.loadNpmTasks(); grunt.registerTasks(); } 在本实例中（处理less）写为 module.exports=function(grunt){ grunt.initConfig( less:{ compile:{ files:{'dist/compo;ed.css':\"css/*.less\"} } } ); grunt.loadNpmTasks(\"grunt-contrib-less\"); grunt.registerTask('default',['less:compile']); } 在终端grunt default完成构建 静态代码检查 属于静态的白盒测试。 检查要素：规则、开发工具检验、命令行工具、Grunt插件、配置文件。 html静态代码检查 创建.htmlhintrc配置文件,填写要检测的规则 { \"tagname-lowercase\": true, \"attr-lowercase\": true, \"attr-value-double-quotes\": true, \"attr-value-not-empty\": false, \"attr-no-duplication\": true, \"doctype-first\": true, \"tag-pair\": true, \"empty-tag-not-self-closed\": true, \"spec-char-escape\": true, \"id-unique\": true, \"src-not-empty\": true, \"title-require\": true, \"alt-require\": true, \"doctype-html5\": true, \"id-class-value\": \"dash\", \"style-disabled\": false, \"inline-style-disabled\": false, \"inline-script-disabled\": false, \"space-tab-mixed-disabled\": \"space\", \"id-class-ad-disabled\": false, \"href-abs-or-rel\": false, \"attr-unsafe-chars\": true, \"head-script-disabled\": true } 安装grunt-htmlhint模块，编辑gruntfile.js。 module.exports=function(grunt){ grunt.initConfig( htmlint:{ option:{ htmlintrc:'./.htmlhintrc' }, src:['*.html'] } ); grunt.loadNpmTasks(\"grunt-htmlhint\"); grunt.registerTask('default',['htmlint']); } 在命令行通过执行grunt命令行下进行代码检测。 css静态代码检查 填写.csslintrc配置文件。 安装grunt-contrib-csslint插件，编辑gruntfile.js。 module.exports=function(grunt){ grunt.initConfig( cssint:{ option:{ csslintrc:'./.csslintrc' }, src:['*.css'] } ); grunt.loadNpmTasks(\"grunt-contrib-csslint\"); grunt.registerTask('default',['csslint']); } 在命令行通过执行grunt命令行下进行代码检测。 js静态代码检查 JS下与上面两种同理，用打的是grunt-eslint插件,在命令行使用eslint --init初始化文件.eslintrc.json. 修改配置文件gruntfile.js。 module.exports=function(grunt){ grunt.initConfig( esint:{ option:{ csslintrc:'./.eslintrc.json' }, src:['*.js'] } ); grunt.loadNpmTasks(\"grunt-eslint\"); grunt.registerTask('default',['eslint']); } 在命令行通过执行grunt命令行下进行代码检测。 单元测试 属于动态的白盒测试。 程序中的错误种类，语法错误、逻辑错误、运行时错误。 软件测试主要针对于逻辑错误。 测试框架有很多，本文讲的测试主要基于mocha框架。 后端单元测试 以一个add.js为例，其代码如下 /*add.js*/ if(process.argv.length!=4){ console.log('sum x y'); process.exit(1); } var x=Number(process.argv[2]), y=Number(process.argv[3]) const add=require('./calc.js') console.log(`${add(x,y)}`) /*calc.js*/ function add(x,y){ if((typeof x)==='number' && (typeof y)==='number') return x+y; else return NaN } 在程序中测试的目标是某一个函数，所以我们真正测试的是calc.js 安装环境mocha（测试环境）chai（断言库） npm install -D mocha chai 创建test目录，用于存放测试代码，进入目录创建calc.test.js并编写 const add =require(\"../calc.js\"), expect=require(\"chai\").expect; describe(\"加法描述\",function(){ //测试用例,一个it就是一个测试用例 it(\"0+0=0\",function(){ expect(add(0,0)).to.be.equal(0) }); it(\"1+0=1\",function(){ expect(add(1,0)).to.be.equal(1) }); }); 在命令行下输入一下命令进行测试 node_modules/.bin/mocha 这样就完成了一个测试代码的编写，但是用例写的是否好是测试代码的关键，为了病假单元测试设计的好坏，引入了覆盖率的概念。 覆盖率分为四种：行覆盖率、函数覆盖率、分支覆盖率、语句覆盖率 为了查看测试覆盖率，引入以下依赖 npm -i -D istanbul 在命令行进行如下命令,通过istanbul进行mocha测试，在结果中可显示覆盖率 ./node_modlues/.bin/istanbul cover ./node_modules/.bin/_mocha 当然这是的手动去测试，我们也可以借助grunt的插件去自动化测试。 前端单元测试 对于前端，我们测试的也是js文件中的逻辑部分即方法、函数，以下面的js文件为例 /*reactange.js*/ $(function(){ var $width=$(\"#width\"), $height=$(\"#height\"), $btnCal=$(\"#calculate\"), $perimeter=$(\"#perimeter\"), $area=$(\"#area\"); $btnCal.click(function(){ var w=Number($width.val()), h=Number($height.val); var react=reactangle(); $perimeter.val(react.perimeter(w,h)); $area.val(react.area()); }) }) /*util.js*/ function reactabgle(){ return { 'perimeter':function(w,h){ return 2*(w+h) }, 'area':function(w,h){ return w*h } } } 在前端index.html中引入util.js 接下里要生成前端测试环境，安装mocha chai 使用./node_module/.bin/macha init test生成前端测试环境，生成test目录 创建util.test.js var expect =chai.expect; describe(\"矩形面积测试\",function(){ it(\"area(10,5)=50\",function(){ var r=reactangle(); expect(r.area(10,5).to.be.equal(50)) }) }) 将util.js 和node_module/chai/chai.js引入test目录下的index.html 此时打开页面可查看结果,接下来继续完成自动化测试 下载依赖grunt grunt-mocha(前端插件时grunt-mocha后端是grunt-mocha-cli)其中grunt-mocha要安装^0.4.12版本 配置Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ mocha:{ test:{ src:['test/index.html'] }, option:{ run:true, reportor:'Dot' } } }) grunt.loadNpmTasks('grunt-mocha') grunt.registerTask('default',['mocha']) } 在命令行下运行grunt查看结果 http接口测试 假设我们有一个接口 接口：http://localhost:8080/reatangle?width=20&height=20 返回结果：{'code':200,'reason':'查寻成功'，result:{'area':400,'perimeter':80}} 创建test目录，进入创建app.test.js文件编写测试代码 const http =require(\"http\"), expect=require(\"chai\").expect; describe(\"接口测试\",function(done){//done是引入mocha的异步机制 //测试用例,一个it就是一个测试用例 it(\"正确请求格式测试\",function(){ http.get('http://localhost:8080/reatangle?width=20&height=20',function(res){ var result=\"\"; res.on('data',(chunk)=>{result+=chunk}) res.on('end',()=>{ var rect=JSON.parse(result); expect(rect.area)to.be.equal(42); expect(rect.perimeter).to.be.equal(26); done(); }) }) }); it(\"1+0=1\",function(){ expect(add(1,0)).to.be.equal(1) }); }) 安装mocha chai,通过./node_module/.bin/mocha进行测试 接下来进行自动化改造 安装grunt grunt-mocha-cli grunt-run 编写Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ run:{ api:{ option:{wait:false}, args:['./app.js'] } }, mochacli:{ option:{ reporter:'spec', bail:true }, all:['test/*.js'] } }) grunt.loadNpmTasks('grunt-run') grunt.loadNpmTasks('grunt-mocha-cli') grunt.registerTask('default',['run','mochacli','stop:api']) } 在命令行执行grunt进行测试 性能优化 优化的常用手段是压缩和打包 压缩html 下载插件grunt grunt-contrib-htmlmin 编写Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ htmlmin:{ options:{ removeComments:true, collapseWhitespace:true }, files:{ src:'./index.html', dest:'dist/index.html' } } }) grunt.loadNpmTasks('grunt-contrib-htmlmin') grunt.registerTask('default',['htmlmin']) } 在命令行通过grunt命令进行打包 压缩css 下载插件grunt grunt-contrib-cssmin 编写Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ cssmin:{ 'rectangle.min.css':'rectangle.css' } }) grunt.loadNpmTasks('grunt-contrib-cssmin') grunt.registerTask('default',['cssmin']) } 在命令行通过grunt命令进行打包 压缩js 下载插件grunt grunt-contrib-uglify 编写Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ uglify: { 'dist/index.min.js': 'index.js' } }, }) grunt.loadNpmTasks('grunt-contrib-uglify') grunt.registerTask('default',['uglify']) } 在命令行通过grunt命令进行打包 压缩图片 选择合适的图片格式，不同图片有不同的问题 选择合适的图片尺寸，不要放超过展示尺寸的图片 选择适当的压缩格式 关键性图片设置优先加载（设置延迟加载） 下载插件grunt grunt-contrib-imagemin 编写Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ imagemin:{ files:{ expand:true, src:['images/*.{pmg,jpg,gif}'], dest:'dist/' } } }) grunt.loadNpmTasks('grunt-contrib-imagemin') grunt.registerTask('default',['imagemin']) } 在命令行通过grunt命令进行打包 打包合并 下载grunt grunt-contrib-concat 编写Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ concat:{ js:{ expand:true, src:['index.js','util.js'], dest:'dist/main.js' }, css:{ expand:true, src:['css/*.css'], dest:'dist/main.css' } } }) grunt.loadNpmTasks('grunt-contrib-concat') grunt.registerTask('default',['concat:js','concat:css']) } 在命令行通过grunt命令进行打包 合并子图 下载grunt grunt-spritesmith 编写Gruntfile.js module.exports=function(grunt){ grunt.initConfig({ spritesmith:{ file:{ src:['images/*.png'], dest:'dist/bundle.png', destCss'dist/sprite.css' } } }) grunt.loadNpmTasks('grunt-spritesmith') grunt.registerTask('default',['spritesmith']) } 在命令行通过grunt命令进行打包,sprite.css中写了各个图的用法 自定义一个grunt插件 下载插件grunt 编写Gruntfile.js module.exports=function(grunt){ grunt.registerTask('build','build task',function(){ console.log('build task') }) } 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/内存控制.html":{"url":"web前端/内存控制.html","title":"内存控制","keywords":"","body":"内存控制 V8的内存控制 node通过js使用内存的时候只能使用部分内存（64位系统下约为1.4g），到值node无法直接操作一下大内存对象，如2g的文件。所以，在翻个node进程中，计算机的内存资源无法得到充足的使用。而这个问题主要原因在于node基于V8引擎，所以node中使用js兑现基本上都是通过v8自己的方式进行分配和管理的。 v8中，所有js对象都是通过堆区来进行分配的。 process.memoryUsage可查看内存信息。 ​ ##### 变量的使用 链式作用域使得当使用变量时，如果本作用域没有回自动查找父作用域，顶层作用域为global 销毁全局变量 //通过delete global.foo='hello'; console.log(global.foo)//'hello' delete global.foo //通过重新赋值(通过delete消除可能会干扰v8的优化，所以尽量通过重新赋值的方法销毁变量) global.foo=undefined; 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/web前端常见问题.html":{"url":"web前端/web前端常见问题.html","title":"web前端常见问题","keywords":"","body":"width设置100%水平方向出现滚动条 例如直接设置body为100%会出现滚动条，此时还需要将html设置为100%，滚动条就会消失 使子元素变得透明，露出父元素的背景图 设置子元素css属性 background-color: rgba(0, 0, 0, 0.3)!important; filter: blur(100px); 如何设置选中文字时不出现背景 为span设置如下css样式 span{ -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none; user-select:none; } 如何设置元素大平时横排，小屏时竖排 /*小屏*/ @media screen and (max-width : 419px){ .actionxwx_contain{ display: flex; flex-direction:column; } } /*大屏*/ @media screen and (min-width : 420px){ .actionxwx_contain{ display: flex; } .scroll{ flex-grow: 1; height: 350px; } } 如何使div能滚动但是不显示滚动条 原理就是将滚动条设置为无颜色 div{ overflow-y: auto; } div::-webkit-scrollbar{ background: none; } 在react中引用其他js库 //之后在在组建中引用时，使用window去引用 window.sr = window.ScrollReveal(); window.sr.reveal('.scroll', { distance: '150px' }); react中引用规范 1、尽量如果引用其他的css库，尽量将引用放到最前面，一面第三方库中的样式覆盖自己写的样式 import 'bootstrap/dist/css/bootstrap.min.css'; import 'react-bootstrap' import './index.css'; 鼠标位置的事件 screenY表示距离电脑屏幕顶端的距离 clientY表示到浏览器顶端的距离 offsetY表示距离触发事件的当前组件的顶端距离 添加层z-index 在添加层的时候必须搭配position使用，否则没有效果 react中为使img的src等于变量的写法 //以上写法为错误写法 //一下为正确写法 let [img1,setImg1] = useState(); useEffect(() => { store.subscribe(() => { setSwitchs(store.getState()) setImg1() }) }) } {img1} 自定义事件 //定义事件 $(\".class\").bind(\"eventName\",function(){}) //触发事件 $(\".class\").trigger(\"eventName\"); 用hook获取后台数据，只需要获取一遍，而useEffect会一直获取 为useEffect添加第二个参数 useEffect(() => { setBlogName(props.match.params.name.replace(/name=/, \"\")); var url = 'http://localhost:9000/blog'; fetch(url) .then((res) => res.json()) .then((data) => { setBlogData(data.content.filedata); }); }, []) hook渲染列表注意点 lists为状态变量，一定要在lists初始化的时候设置初始值 const [lists, submitClick] = useState([]); {lists.map((item,index)=> liClick(index)}>{item} )} React 怎样将后端给的html标签渲染到页面上 , 只改变usestate产生变量的属性的时候注意的问题 例如我们使用usestate生成一个变量arr数组，当我们只想改变数组的某一位的时候应如下操作。 const [cptStyle, setCptStyle] = useState([]); var arr1 = [...setCptStyle]; arr1[1]='change'; setCptStyle(arr1); ! ! ! 此时要注意。一定要用解构赋值。arr1 = setCptStyle 指的是将arr1的地址指向setCptStyle的地址；而 arr1 = [...setCptStyle] 是产生新的数组赋值给arr1。而setCptStyle只有检测到地址有变化的时候才会去改变状态。 更改hr颜色 border:5px solid blue; a标签设置打开新页面而不是刷新页面 qweqweqweq nodejs中模块return的返回值为undefined 在写模块的时候使用promise //假设文件叫做md.js exports.MovieDetil = function (a,b) { return new Promise(function (resolve) { var sum=a+b; resolve(sum); }) } //外部文件中 var md=require(\"./md.js\") md.MovieDetil(ab).then((data)=>{console.log(data)}) react路由上传几种方式 //路由表中 //转跳 XXXX this.props.history.push( '/sort/'+'2' ) //获取参数 this.props.match.params.id //路由表 //跳转(replace不加会无法跳转) XXXX 　　　　　　　 this.props.history.push({ path : '/sort' ,query : { name: ' sunny'} }) //获取参数 this.props.location.query.name //通过state同query差不多，只是属性不一样，而且state传的参数是加密的，query传的参数是公开的 //路由表 //跳转 XXXX this.props.history.push({ pathname:'/sort',state:{name : 'sunny' } }) //获取参数 this.props.location.state.name nodejs获取参数 color类型input标签样式设置 它其实是两层div组成的，chrome提供了两个伪类来控制它们， ::-webkit-color-swatch-wrapper 这个是外面的容器 ::-webkit-color-swatch 这个是内部的颜色按钮，改变颜色后会改变 ::-webkit-color-swatch-wrapper{ background-color:#ffffff; outline: none; } ::-webkit-color-swatch{ position: relative; } ​ nodejs解决跨域问题 res.header(\"Access-Control-Allow-Origin\",\"*\"); 数组如何判等 var a=[1,2,3] var b=[1,2,3] console.log(a.toString()===b.toString()); 如何使文本保留格式（pre标签） &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;loadxmldoc.js&quot;&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; xmlDoc=loadXMLDoc(&quot;books.xml&quot;); document.write(&quot;xmlDoc is loaded, ready for use&quot;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; xmlDoc=loadXMLDoc(\"books.xml\"); document.write(\"xmlDoc is loaded, ready for use\"); 此例演示如何使用 pre 标签 对空行和 空格 进行控制 此例演示如何使用 pre 标签 对空行和 空格 进行控制 常用方法 Math.pow(x,y) //x的y次幂 NumberObject.toFixed(n) //保留n位小数 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/常见组件设计.html":{"url":"web前端/常见组件设计.html","title":"常见组件设计","keywords":"","body":"图标选择后点亮 {selectIndex=idx}\" /> 定义变量selectIndex，当其等于原坐标的时候，使用点击时的图标 tab栏置于底部 /*对于跟组件*/ { height:100%; } /*对于跟组件中，底部tar栏上面的组件，通常是路由*/ { display:flex; flex-direction:column; align-items:stretch; flex:1; } /*布局结束后，底部栏会被撑到最下方*/ 垂直网格布局 /*容器样式[容器组件]*/ { padding: 5px 0; scroll-behavior: smooth; -webkit-overflow-scrolling: touch; display: grid; grid-auto-flow: row;//溢出时新增一行 place-content: stretch; place-items: center; overflow-x: hidden; overflow-y: auto; } 在组件中设置变量 在逻辑中设置 export class VerticalGridComponent implements OnInit { @Input() itemWidth = '4rem'; @Input() itemHeight = '4rem'; @Input() gridGap = '5px'; constructor() {} ngOnInit() {} /* 响应式布局网格，auto-fill 用来在空间足够时尽可能的填充该位置，minmax 是最小和最大的宽度 */ get templateRows() { return `minmax(auto-fill, ${this.itemHeight})`; } /** * CSS Grid Layout 的模版列表达式 */ get templateColumns() { return `repeat(auto-fill, minmax(${this.itemWidth}, 1fr))`; } } 调用时,通过该百年itemWidth的值来决定每行显示几列。例如本例中itemWidth为10rem就是两列20rem就是一列 设置在一个盒子内的上下滚动 通常在一个app中，底部的栏是固定的，但是上面是可滚动的长页面 /*host为整个页面的样式*/ :host { display: flex; flex-direction: column; align-items: stretch; flex: 1; overflow-y: hidden; } /* 让中间部分可滚动，需要计算高度，页面高度减去头部和尾部 */ /*main为中间内容*/ .main { flex-grow: 1; overflow-y: auto; overflow-x: hidden; scroll-behavior: smooth; -webkit-overflow-scrolling: touch; overscroll-behavior-y: contain; height: calc(100% - 3rem); } 卡片 网格布局并不是一个元素只能占一个格子。 例如我们将创建一个左面为图片，右面从上到下分别是简介、标签、价格的卡片。 .container { /*卡片的容器*/ display: grid; grid-template-columns: 10rem 1fr;//每一列的尺寸 grid-template-rows: 3rem 1fr 1rem 2rem;//每一排的尺寸 grid-gap: 5px; //格子之间间隔 grid-template-areas://区域划分，‘.’代表无内容 'image title' 'image .' 'image tags' 'image price'; place-content: stretch;//是align-content(垂直格子和间隔如何分布)和justify-content(水平格子和间隔如何分布)的简写 place-items: stretch;//是align-items(内容在格子里垂直如何分布，stretch为内容占满格子)和justify-items(内容在格子里水平如何分布)的简写 } .product-image { grid-area: image; object-fit: contain; width: 9rem; height: 9rem; } .product-title { grid-area: title; } .product-tags { grid-area: tags; } .product-price { grid-area: price; } 轮播图 模板为 ##控制轮播图片的高度 ##滑动时触发事件 样式为 .container { position: relative; overflow: hidden; } .container .image-slider { display: flex; overflow-x: scroll; scroll-snap-type: x mandatory;/*在x轴添加吸附效果*/ scroll-behavior: smooth;/*使得元素的移动产生移动效果*/ -webkit-overflow-scrolling: touch;/*在手机上可以通过触摸滚动*/ } .container img { width: 100%; height: 100%; object-fit: cover; scroll-snap-align: start;/*吸附参考标准*/ } .nav-section { position: absolute; bottom: 0; width: 100%; opacity: 0.5; color: #fff; background-color: #000; display: flex; justify-content: flex-end; align-items: stretch; } .nav-section .slide-button { display: flex; width: 10px; height: 10px; background-color: #fff; text-decoration: none; border-radius: 50%; margin: 5px; } .container .image-slider::-webkit-scrollbar { display: none; width: 0 !important; } .nav-section .slide-button-select { background-color: #e02f29; } 逻辑为 import { Component, OnInit, Input, ViewChild, ElementRef, Renderer2, AfterViewInit, OnDestroy, ChangeDetectionStrategy } from '@angular/core'; export interface ImageSlider { id: number; imgUrl: string; link: string; caption: string; } @Component({ selector: 'app-image-slider', templateUrl: './image-slider.component.html', styleUrls: ['./image-slider.component.css'], changeDetection: ChangeDetectionStrategy.OnPush }) export class ImageSliderComponent implements OnInit, AfterViewInit, OnDestroy { @Input() sliders: ImageSlider[] = [];/*外部传入的图片的相关数据*/ @Input() sliderHeight = '160px'; @Input() intervalBySeconds = 2; @ViewChild('imageSlider', { static: true }) imgSlider: ElementRef;/*取到名为imgSlider的元素数*/ selectedIndex = 0; constructor(private rd2: Renderer2) {} intervalId; ngOnInit() {} ngAfterViewInit(): void { if (this.intervalBySeconds { this.rd2.setProperty(/*添加属性*/ this.imgSlider.nativeElement,/*对应的图片容器元素*/ 'scrollLeft',/*向左移动的距离*/ (this.getIndex(++this.selectedIndex) * this.imgSlider.nativeElement.scrollWidth) / this.sliders.length/*计算得到现在应向左移动的距离*/ ); }, this.intervalBySeconds * 1000); } ngOnDestroy(): void { clearInterval(this.intervalId);/*解决内存泄漏*/ } getIndex(idx: number): number { /*获取现在应该是第几张图*/ return idx >= 0 ? idx % this.sliders.length : this.sliders.length - (Math.abs(idx) % this.sliders.length); } handleScroll(ev) { /*在手动滑动轮播图后，更改this.selectedIndex。如果没有此函数，例如图片在2，手动划到了1，下一次，图片仍然自动划到3*/ const ratio = ev.target.scrollLeft / (ev.target.scrollWidth / this.sliders.length); this.selectedIndex = Math.round(ratio); } } 两栏布局，左栏固定，右栏滚动（常见开放文档页面） 使用fixed布局 .left{ position:fixed; width:200px; left:0; top:0; } .right{ position: relative; marginLift:200px; } 将左栏黏贴 .left{ /*height: calc(100vh - 90px);//常用来设置高度*/ top: 0; float:left; position: sticky;/*将其粘帖在某个地方不动*/ position: -webkit-sticky; } .right{ float:left; } sticky： 元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。 该值总是创建一个新的层叠上下文（stacking context）。注意，一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是真的滚动祖先。这个阻止了所有“sticky”行为 sticky生效条件： 1、必须指定top、bottom、left、right其中的一个 2、达到设定阔值，top为0时与fixed相同，top大于0时，加成relative属性 fixed与sticky的区别： sticky定位可以被认为是relative和fixed的混合。粘性定位的元素被视为相对定位，直到它超过指定的阈值，此时它被视为固定的，直到它到达其父母的边界。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/前端面试复习.html":{"url":"web前端/前端面试复习.html","title":"前端面试复习","keywords":"","body":"基础 布局 例题：三栏布局，左右各300px，中间自适应 多想一些方法，常见方式使用float、table、grid、flex、fixed去实现 单位 1em，等于本元素的字体大小，所以在不同的元素里1em的绝对大小是不一样的。 1rem，等于根元素的字体大小，在一个页面中，无论在哪个元素上1rem都是一样的。 em 适合于用在需要大小需要跟随字体变化的属性上，比如padding、margin、height、width等等，元素继承了不同的字体大小，这些属性最好也能跟着变化； rem适用于字体，这样就可以通过改变根元素的字体大小来改变整个页面的字体大小。 css盒模型 标准、ie模型 标准宽和高指的是content的宽度 ie模型中宽和高是指content、padding、border的总和 css如何设置两种模型 标准：box-size:content-box; ie：box-size:border-box; js如何获取和模型的对应的宽和高 dom.style.width :只能获取内联样式，无法获取style结点和外部进入的样式 dom.currentStyle.width：渲染出来的宽，只支持ie window.getComputedStyle(dom).width：所有浏览器支持 dom.getBoundingClientRect().width：获得四个数组，分别是left、top、width、height BFC 块级格式化上下文 渲染规则 bfc内部上下垂直方向的边距会有重叠 bfc区域不会和浮动元素重叠 bfc外面和内部元素不会互相影响，他是独立的容器 浮动元素参与计算bfc的高度 如何创建BFC float不为none position不为static、relative display为inline-block，table相关,flex overflow不为visible DOM事件 dom事件类 dom0：ele.onclick=function(){} dom2：ele.addEventListener('click',function(){},false) dom3：增加了鼠标、键盘等事件 事件模型 捕获 冒泡 事件流 捕获-->目标阶段-->冒泡 window-->document-->html-->父元素-->子元素 常见Event对象应用 preventDefault 取消默认事件 stopPropagation 阻止冒泡 stopImmediatePropagation 阻止该事件中其他函数的响应 currentTarget 绑定事件的元素 target 触发事件的元素 自定义事件 var eve=new Event('custome') el.addEventListen('custome',function(){ console.log() }) el.dispatchEvent(eve) 类型转换 数据类型 Boolean、Null、Undefined、Number、String、Symbol、object 显式转换 Number函数 对于object来说 1、先调用valueOf方法（返回Boolean对象的原始值），如果但会原始类型的值，则调用Number方法 2、如果valueOf返回复合类型的值，再向其调用toString方法，如果返回原始类型的值，则调用Number方法 3、如果toString返回的是复合类型的值，则报错。 字符串：变为对应的数值，否则为NaN，空字符串为0 布尔值：true为1，false为0 undefined：NaN null：变为0 数组：有一个元素转为对应数组，多个元素转为NaN,无元素转为0/ String函数 对于object来说 1、向其调用toString方法，如果返回原始类型的值，则调用String方法 2、向其调用valueOf方法，如果但会原始类型的值，则调用String方法 3、如果都返回的是复合类型的值，则报错。 数值：对应字符串 布尔值：转换成true或false undefined：undefined null：null Boolean函数 除了undefined、null、+0、-0、NaN、\"\"为false以外，全为true 隐式转换 触发条件 四则运算 判断语句（例如if语句） Native调用（例如console.log） []+[] //\"\" []+{} //\"[object Object]\" {}+[] //0 此处会将{}当作一个代码块，实际运行的是+[] {}+{} //chrome与firfox不一样 true+true //2 1+{a\"1} //\"1[object Object]\" 对象转换的原理解释 当将对象转化为一版数据类型的时候其实是调用了isPrimitive这个方法。 isPrimitive方法的实现 // 获取类型 const getType = (obj) => { return Object.prototype.toString.call(obj).slice(8,-1); } // 是否为原始类型 const isPrimitive = (obj) => { const types = ['String','Undefined','Null','Boolean','Number']; return types.indexOf(getType(obj)) !== -1; } const ToPrimitive = (input, preferredType) => { // 如果input是原始类型，那么不需要转换，直接返回 if (isPrimitive(input)) { return input; } let hint = '', exoticToPrim = null, methodNames = []; // 当没有提供可选参数preferredType的时候，hint会默认为\"default\"； if (!preferredType) { hint = 'default' } else if (preferredType === 'string') { hint = 'string' } else if (preferredType === 'number') { hint = 'number' } exoticToPrim = input.@@toPrimitive;//data对象才有.@@toPrimitive // 如果有toPrimitive方法 if (exoticToPrim) { // 如果exoticToPrim执行后返回的是原始类型 if (typeof (result = exoticToPrim.call(O, hint)) !== 'object') { return result; // 如果exoticToPrim执行后返回的是object类型 } else { throw new TypeError('TypeError exception') } } // 这里给了默认hint值为number，Symbol和Date通过定义@@toPrimitive方法来修改默认值 if (hint === 'default') { hint = 'number' } return OrdinaryToPrimitive(input, hint) } const OrdinaryToPrimitive = (O, hint) => { let methodNames = null, result = null; if (typeof O !== 'object') { return; } // 这里决定了先调用toString还是valueOf if (hint === 'string') { methodNames = [input.toString, input.valueOf] } else { methodNames = [input.valueOf, input.toString] } for (let name in methodNames) { if (O[name]) { result = O[name]() if (typeof result !== 'object') { return result } } } throw new TypeError('TypeError exception') } 在 ES6 之后提供了 Symbol.toPrimitive 方法，该方法在类型转换的时候优先级最高。 Symbol.toPrimitive的示例 const obj = { toString() { return '1111' }, valueOf() { return 222 }, [Symbol.toPrimitive]() { return 666 } } const num = 1 + obj; // 667 const str = '1' + obj; // '1666' 连接符+ 先对两个数字执行 toPrimitive 方法，参数为默认 然后判断如果有字符串则通过toString 转换后串起来 var a = 'hello ', b = {}; var c = a + b; // \"hello [object Object]\" 网络 http协议特点 简单快速：想访问某个资源只需访问对应的uri（每个资源对应uri是固定的） 灵活：http就可以完成不同数据类型的传输 无连接：不会保持连接 无状态：客户端和服务端是两种身份，服务端是没法区分每次链接者身份 报文组成 请求报文：请求行（http方法、页面地址、http协议版本）、请求头、空行、请求体 响应报文：状态行（http协议版本、状态码、状态信息）、响应头、空行、响应体 http方法 get：获取资源 post：传输资源 put：更新资源 delete：删除资源 head：获得报文首部 post和get的区别 get在浏览器回退时无害的，post会再次提交请求 get的url可以被收藏，post不行 get会被浏览器主动缓存，post不行 get请求参数会保留在浏览器历史记录中，post不会 get在url中传送的参数有长度限制，post无限制 http状态码 1XX：指示信息 2XX：成功请求 200：客户端请求成功 206：可送发送了也带有range（范围）头的get请求，例如当返回一个视频，由于视频很大，所以一段一段接收 3XX：重定向 301：请求已转至新的url 302：请求已转至临时新的url 304：客户端有缓存文档并发出了一个条件性请求，服务器告诉客户，原来缓存的文档还可以继续用 4XX：客户端请求错误 400：请求语法错误，不能被服务器理解 403：请求的资源禁止被访问 404：请求资源不村子啊 5XX：服务器错误 500：服务器发生了不可预期的错误 持久化连接 http采用“请求-应答”模式，当使用普通模式的时候，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建立一个连接，完成之后立即断开链接（http协议为无连接的协议） 当使用Keep-Alive模式（持久链接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当对服务器的后继请求时，Keep-Alive避免了建立或者重新连接。但是这要求http必须为1.1版本。 管线化 在持久连接的情况下，每个消息的传递类似于 请求1->响应1->请求2->响应2->请求3->响应3 使用管线化后，某个连接上的消息变为 请求1->请求2->请求3->响应1->响应2->响应3 管线化通过持久化连接完成，仅支持http/1.1支持此技术 只有get和head可以进行管线化，而post有所限制 他不会影响响应到来的顺序 tcp 三次握手，四次挥手 所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。 所谓的四次挥手即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。 三次握手 客服端 ：请求连接 服务器：收到链接请求 客户端：收到服务端准备好的消息 四次挥手 客户端：请求断开 服务端：收到请求报文 服务端：必要的数据 客户端：收到最后的数据 原型 由浅入深： 如何创建变量 原型、构造函数、实例、原型链 instanceof原理 new运算符 创建对象方式 第一种： var o1={name:'o1'} var o11=new Object({name:'o11'}) 第二种： var M=function(){this.name='o2'} var o2=new M() 第三种：将o3.__proto__指向p var P={name:'o3'}//name变成o3的原型上的属性 var o3=Object.create(P) instanceof 实例对象的__proto__会指向构造函数的prototype指向的对象。 instanceof的实质是在判断前者的__proto__属性和后者的prototype属性是否是一个引用。 所以，instanceof无法区分后者是否为前者的构造函数，还可能是前者构造函数的构造函数。 new运算符工作原理 工作步骤 一个新对象（新实例）被创建，它继承自foo.prototype（foo为构造函数） 构造函数foo被执行，执行的时候，相应的传参会被传入，同时上下文会被指定为这个新实例。 如果构造函数返回了一个对象，那么这个对象会取代new的对象，如果构造函数没有返回对象，new出来的结果为步骤1创建的对象。 var new=function(func){ var o=Object.create(func.prototype) var k=func.call(o); if(typeof k == 'object'){ return k; }else{ return o; } } 面向对象 类与实例 /** 类的声明 */ function Animate(){ this.name='name' } class Animate2{ constructor(){ this.name='name'; } } /** 实例化 */ new Animate() new Animate2() 类与继承 /** 继承 */ 1、借助构造函数 function dog(){ Animate.call(this);//apply.改变this确保父类的属性挂载到子类上 this.type='dog'; } //原理：通过该边this执行使得dog也拥有Animate上的属性 //缺点：Animate原型链（prototype）上的东西不会被dog继承 2、借助原型链 function dog(){ this.type='dog'; } dog.prototype=new Animate(); //原理：使得(new dog).__proto__指向Animate的实例，Animate的实例的__proto__指向Animate的prototype。最后使得dog实例也继承了Animate的原型对象。并且dog实例对象的__proto__上面也有了Animate上生命的属性。 //缺点：dog的两个实例dog1.__proto__===dog2.__proto__。他们都指向同一个Animate的实例，所以Animate声明的方法‘name’对于dog1和dog2是共享的，一个改变另一个也变了。 3、组合方式(了解) function dog(){ Animate.call(this); this.type='dog'; } dog.prototype=new Animate(); //原理：dog1.__proto__中也有name属性，但是dog构造函数中也有，他的实例会首先找到dog构造函数中的name属性。 //缺点：在声明dog的实例时，Animate构造函数被执行了两次 4、组合优化(了解) function dog(){ Animate.call(this); this.type='dog'; } dog.prototype=Animate.prototype; //缺点：无法区分dog1是由dog实例化的还是Animate实例化的 //dog1 instanceof dog //true //dog1 instanceof Animate //true //dog1.constructor===Animate 5、组合再优化 function dog(){ Animate.call(this); this.type='dog'; } dog.prototype=Object.create(Animate.prototype); dog.prototype.constructor=dog; //原理：Object.create(Animate.prototype)生成了一个新对象设叫a,那么a.__proto__指向Animate.prototype。这样借助一个中间变量a，完成了继承。 通信类 浏览器中输入url经历了什么 浏览器首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系， 有，则向其IP地址发送请求 DNS进行递归查询和迭代查询，将域名解析成对应的服务器IP地址，发回给浏览器 获取ip后，开始网络通讯。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上走 渲染阶段，解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 将渲染树每个节点绘制到屏幕。 同源策略及策略 它限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制 其中，源包含协议、域名、端口。 限制方面 Cookie、LocalStorage和IndexDB无法读取 DOM无法获得 AJAX请求不能发送 前后端如何通信 AJAX：无法跨域 WebSocket：不受同源策略限制 CORS：支持跨域通讯也支持同源通讯 如何创建Ajax 注意点：工作流程、兼容性处理、事件触发条件、事件触发顺序 跨域通信 JSONP：使用script标签的异步加载实现 Hash:url地址中#后面的东西，hash的变动页面不会刷新。而search的改变会引起页面刷新，所以search不可做跨域通信 postMessage：h5新增 WebSocket CORS：可理解为支持跨域通信的ajax Hash使用场景？ // 利用hash，场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B // 在A中伪代码如下： var B = document.getElementsByTagName('iframe'); B.src = B.src + '#' + 'data'; // 在B中的伪代码如下 window.onhashchange = function () { var data = window.location.hash; }; postMessage的使用 // postMessage // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息 Bwindow.postMessage('data', 'http://B.com'); // 在窗口B中监听 Awindow.addEventListener('message', function (event) { console.log(event.origin); console.log(event.source); console.log(event.data); }, false); WebSocket的使用 // Websocket【参考资料】http://www.ruanyifeng.com/blog/2017/05/websocket.html var ws = new WebSocket('wss://echo.websocket.org'); ws.onopen = function (evt) { console.log('Connection open ...'); ws.send('Hello WebSockets!'); }; ws.onmessage = function (evt) { console.log('Received Message: ', evt.data); ws.close(); }; ws.onclose = function (evt) { console.log('Connection closed.'); }; CORS标准的运用 原理：浏览器会拦截AJAX请求，当发现AJAX请求跨域后，会在请求头中标记一个origin fetch可以用来实现CORS通讯 // CORS【参考资料】http://www.ruanyifeng.com/blog/2016/04/cors.html // url（必选），options（可选） fetch('/some/url/', { method: 'get', }).then(function (response) { }).catch(function (err) { // 出错了，等价于 then 的第二个参数，但这样更好用更直观 }); 常见工具封装 /** * 功能类库 */ /** * [util 工具类] * @type {Object} */ var util = {}; /** * [function 返回数组的指定项] * @param {[type]} array [description] * @param {[type]} item [description] * @return {[type]} [description] */ util.indexOf = function (array, item) { for (var i = 0; i >> 1)) : (c >>> 1)); c = ((c & 1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1)); c = ((c & 1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1)); c = ((c & 1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1)); c = ((c & 1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1)); c = ((c & 1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1)); c = ((c & 1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1)); c = ((c & 1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1)); table[n] = c; } return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table; })(); var crc32_str = function (str) { var C = -1; for (var i = 0, L = str.length, c, d; i >> 8) ^ T[(C ^ c) & 0xFF]; } else if (c >> 8) ^ T[(C ^ (192 | ((c >> 6) & 31))) & 0xFF]; C = (C >>> 8) ^ T[(C ^ (128 | (c & 63))) & 0xFF]; } else if (c >= 0xD800 && c >> 8) ^ T[(C ^ (240 | ((c >> 8) & 7))) & 0xFF]; C = (C >>> 8) ^ T[(C ^ (128 | ((c >> 2) & 63))) & 0xFF]; C = (C >>> 8) ^ T[(C ^ (128 | ((d >> 6) & 15) | ((c & 3) >> 8) ^ T[(C ^ (128 | (d & 63))) & 0xFF]; } else { C = (C >>> 8) ^ T[(C ^ (224 | ((c >> 12) & 15))) & 0xFF]; C = (C >>> 8) ^ T[(C ^ (128 | ((c >> 6) & 63))) & 0xFF]; C = (C >>> 8) ^ T[(C ^ (128 | (c & 63))) & 0xFF]; } } return C ^ -1; }; var r = a.pathname + '?r=' + Math.random().toString(10).substring(2); if (r[0] != '/') { r = '/' + r; } var s = crc32_str(r) >>> 0; var is_web = location.protocol.indexOf('http') > -1; return (is_web ? [location.protocol, a.hostname] : ['http:', a.hostname]).join('//') + r + '&s=' + s; }; export default util; 安全类 CSRF 基本概念 全称跨站请求伪造。 攻击原理 例如，用户时网站A的用户，并且登录网站A，网站A返回cookie，当用户请求网站B时，B中存在某个链接，这个链接指向的网站A的接口（例如是一个对网站A的get请求），这时用户浏览器会自动上传cookie去访问网站A，网站A验证用户通过请求后便会进行操作。 两个必要点时：首先用户在A网站登录过、网站A在对应接口上有此漏洞 防御措施 添加token验证 Referer验证 隐藏令牌 XSS 跨域脚本攻击 攻击原理 防御措施 算法类 排序 冒泡、快速、选择、希尔 堆栈、队列、链表 递归 波兰式和逆波兰式 深入 渲染机制 DOCTYPE作用 DOCTYPE是用来声明文档类型和DTD规范的，一个主要用途是文件的合法性检验，如果文件不合法，浏览器解析时会出错。 DTD：用它可以告诉浏览器是什么文档类型（告诉浏览器是那种DTD），浏览器会选择相对应的渲染方式。 html5写法 html4.0有两种模式，传统模式和严格模式。在严格模式中，包含所有html元素和属性，但不包括展示性和启用的元素。 浏览器渲染过程 html被domParse转成dom树，css被CSSParser转成css树 将两棵树整合为RenderTree（不知道某一个元素的位置） 通过layout计算位置 最后进行渲染 重排Reflow dom结构中元素都有自己的盒子，这些都需要浏览器根据各种样式来计算结果将元素放到她该出现的位置。这个过程叫重排。 触发重排 增删改查dom结点 当你移动dom位置 修改css样式，例如宽和高 当resize窗口的时候或是滚动（可能引起） 当修改默认网页的默认字体 重绘Repaint 当各种盒子的位置、大小及属性确定后，浏览器将这些元素按照各自的特性绘制了一遍，于是页面内容出现了，这个过程称为repaint。 触发重绘 dom改动 css改动 如何减少repaint 一次性添加创建的dom元素，不要一个一个加，将其放入一个父元素中，一次性加入。 js运行机制 异步任务的执行顺序 浏览器会先执行同步代码，遇到异步方法会先将其挂起，全部执行后才会开始执行之前挂起的方法。 console.log(1) setTimeout(()=>{console.log(2)},1000) while(1){ } //只打印1，然后陷入死循环 Event Loop js引擎将同步任务放到运行栈中，当js引擎遇到settimeout时，浏览器的timer模块会将其拿走，但是先不放到异步任务队列，当settimeout的时间到了之后再放到任务队列中。 浏览器执行运行栈，完成后检测任务队列有没有任务，若有，将任务队列的任务放到运行栈执行，执行结束后继续检测任务队列有没有任务，如此循环叫做事件循环 异步任务的类型 setTimeout和setInterval DOM事件 Promise 宏任务和微任务 而宏任务一般是：同步代码，UI rendering，I/O，setTimeout，setInterval。 微任务：Promise，process.nextTick。 setTimeout(() => { console.log(4); }, 0); new Promise(resolve=>{ console.log(1); for(let i =0;i{ console.log(5) }) console.log(3) //打印12354 //在执行完宏任务后，会执行微任务，而then的内容则是一个微任务，所以要先执行它 页面性能 提升页面性能方式 资源压缩合并，减少http请求 非核心代码异步加载==>异步加载方式==>异步加载区别 利用浏览器缓存==>缓存分类==>缓存原理 使用CDN 预解析DNS 异步加载 异步方式 动态脚本加载（js创建script标签） defer async 异步加载的区别 defer是在html解析完成之后执行，而且按照加载顺序执行 async时再加载完成后立即执行，如果是多个，首先加载完的先执行 使用方法如下 浏览器缓存 强缓存：强迫浏览器必须使用本地缓存。常见http请求头Expires（后面加过期时间，是绝对时间点，以服务器时间为准）Cache-Control（后面加相对时间）当两个请求头都出现时，一第二种为准。 协商缓存：浏览器会先向服务器询问是否使用缓存。常见http请求头Last-Modified（服务器发送的上次修改的时间） If-Modified-Since（浏览器携带此值发送给服务器询问这个时间是否有效）Etag If-None-Match（与上两个值相似，但是携带的是哈希值） DNS预解析 下面第二句是设置预解析。 页面中的a标签在一般浏览器默认打开dns预解析，如果页面是https协议开头的，一般浏览器时默认不开启dns预解析，通过第一句话去设置预解析。 错误监控 前端错误的分类 代码错误(即时运行错误) 资源加载错误 错误的捕获 捕获执行运行错误 try...catch window.onerror 捕获资源加载错误 object.onerror：此处的object指的是某个具体html元素如img对象，因为错误是无法冒泡的，所以要监控元素本身而不能检测其父元素 performance.getEntries()：高级浏览器自带对象，返回所有加载资源的 Error事件捕获：错误无法冒泡但是可以捕获，通过在捕获阶段获取错误 跨域时，可以捕获错误么？ 可以但是错误提示只有Script error,无法获取报错信息。需要在script标签中加入crossorigin属性，然后再js资源响应头中加入Access-Control-Allow-Origin:* 上报错误的基本原理 采用Ajax信息的方式上报 利用image对象上报 (new Image()).src=\"http://baidu.com/psth?r=test\" 利用这种方式发送一个请求。 MVVM 对mvvm的认识 是从mvc和mvp演化而来 mvvm定义 mvvm与mvc的区别 双向绑定的原理 简易版mvvm 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/开源项目流程.html":{"url":"web前端/开源项目流程.html","title":"开源项目流程","keywords":"","body":"目录 由于本文内容较多，先列一下目录供参考。 什么是开源？ 为何做开源？ 做什么？ 注册账号 搭建开发环境 提交代码 创建官网 如何宣传？ 持续迭代 总结 什么是开源？ 您可能有很多次打开 github 去查阅下载一些项目的源码，但是您有没有总结过，开源项目到底是什么？ 我与开源 我是开源编辑器 wangEditor 的作者（欢迎去 star），这个项目已经做了有近 4 年了，目前积累了 4.5k star（现在是 2018.5）。4 年时间，我一直未间断维护升级，其中还经历了 2 次大型的重构，积累了一些经验和教训。接下来我将根据自己的经历，来为大家分析开源。 开源项目包含什么 开源软件并不是只是一堆源代码，如果你仔细分析或者有亲身体会的话，包含内容还是比较多的。我总结了以下内容： 源码 文档，如二次开发文档和用户使用文档 开发环境，告诉二次开发者如何搭建和运行代码 允许他人贡献代码，而不是仅仅给别人阅读源码的权限 问题，用户提问，维护者答复，问题共享（而不是私聊） 问题列表和升级计划，记录当前问题，以及何时解决、何时升级 其他配套设施 要做成一个成熟靠谱的开源软件产品，除了以上源码相关的方面，还需要以下配套的设施，才能完备。 官网，如 wangEditor 官网 文档，可以和官网整合在一起 问答社区，wangEditor 的问题社区就用了 github issue 及时交流社区，即 QQ 群、微信群 为何做开源？ 做开源不挣钱，这是确定的，但是为何要做开源，而且那么多人坚持做开源呢 —— 他们不是完全为了兴趣爱好，完全下班没事儿干。人只要付出劳动、付出努力，都是奔着目的性去的，有兴趣的原因，但是能让自己持之以恒做下去的，肯定不是兴趣。 其实这个问题很简单，就像看书不挣钱（买书还花钱呢），但是为何要看书呢？因为大家都知道看书能提高自己的知识面和能力。而做开源也有相似的想过，只不过很多人没接触过不知道而已。我总结了如下几个理由： 全面提高编程能力。 你需要从 0 打造，每部分代码都需要自己负责，不像在公司中的一颗螺丝钉。 提高自己的社区知名度。 github 上的 star 能间接的反应你的身价，它能让你得到业内认可。业内同行认可了，做啥事儿都好做，如内推工作。 锻炼自己的产品意识。 因为做开源做的是产品，不再是单纯的技术活，UI、运维、推广、收集反馈、甚至成本预算，你都得考虑。 技术范儿、极客精神。 作为一名程序猿，能业余打造一款开源产品是一件很帅的事情，满足自己的虚荣心。 有了充分的理由，那就开干！ 做什么？ 迈出第一步 这是做开源要想到的第一件事情，很多想做开源的同学，到这一步就想不下去了。还有同学，一上来就定位太高，做着做着发现根本做不出来，就提前放弃。做什么，看似简单的问题，但是很重要的一步。 不做什么 一些早期就知名的开源作品，很多都是因为作者在工作中遇到一个需求，而这个需求目前还没有开源产品去满足，因此自己做一个。但是对于我们大众基层程序猿，天天写业务代码，重复劳动，你遇到这种需求的概率不是特别大。因此，这个方面就不在继续往下讨论了。 想要知道做什么，你就得先明白你做开源的一些期望，然后再去想做什么。我总结了两点： 要快速做出第一版，至少能用。后面再慢慢迭代升级。 要能方便的推广使用，最好是 0 成本使用。 即做出来，推出去，要快。即，你做的快，别人用的也快。按照这种期望往下想，首先你能排除不做什么： 大型的框架，如做一个 UI 框架。 短期做不完，使用成本高 模拟成熟轮子，如在造一个 jQuery 。 有成熟方案，用户不会换 小众的东西。 基本没人用 没有特色，100% 的模仿。 用户没有更换的理由 做什么 排除以上这些，还剩下的范围就不做了，我推荐做开源产品的方向： 小而精的工具。 开发快，使用成本低。 要有特色，哪怕是一个。 要和别人不一样，差异化竞争。 一定要大众，50% 以上的开发人员都会用到 避开已经被成熟产品垄断的领域。 你就不要去跟 jQuery vue React 竞争了。 例如，前几天 is-odd 在知乎闹的沸沸扬扬，这个库就是判断奇数偶数，只不过考虑了各种数据类型的转换。但是你看它的 weekly downloads 数量多大。 下面列举几个我认为比较合适做开源的例子： cache 工具（缓存工具，整合 localStorage，以及合理的内存销毁机制） query2json，解析 url 参数为 json 格式 移动端打印 console.log ，方便移动端输出内容 其他符合上述条件的，根据自己当前的情况，大家可以自由发挥。最后，选择哪个不重要，重要的是你选择出来了。因此，如果你实在没有合适的选择，不如就从我举例中选择一个，抓阄也行。选择出来，你就可以继续往下做了，否则你一直都在纠结。 本文将做什么 好了，本教程就确定要做一个 cache 工具，取一个性的名字，不和现有的重复（是否重复，去 github 一搜便知），叫做fast-cache。 注册账号 注意，你如果现在已经有了 github 账号，也不好忽略这一章的内容，很重要！ 你一旦注册一个 github 账号并且去做开源产品，那你就要作为一个个人品牌持续运营下去，不能随便改名字。因此注册账号时一定要慎重考虑，不能随便弄一个，做一段时间又想改。 组织还是项目 首先，你要明确你即将注册的账号是专门针对一个产品（即项目账号）还是将运维多个产品（即组织账号）？ 例如，facebook 就是 github 中的组织账号，其下有很多开源产品，如 react 和 hhvm 等。而 rollup 就是 github 中的项目账号，其下就一个项目 rollup ，其他的项目都是一些附件插件。 对于我们个人开发者，我推荐注册项目账号，即以你项目的名称取个账号的名字。这样还有一个好处，就是后面讲到官网的时候，你可以用更短、更好记的官网地址。例如，如果不自己申请域名、假设服务器（即不花一分钱）的情况下，以上例子中他们的官网有区别。 rollup 的官网地址将是 rollup.github.io ，很短； react 的官网地址只能是 facebook.github.io/react，多了一级目录；（注意是不申请域名、不花钱的情况下） 最后，我选择项目账号，因此我需要注册的账号是 fast-cache 。 注册账号 我们分别要去 github 和 npm 注册以 fast-cache 为用户名的账号，注册过程就不写了，都是傻瓜式操作。需要注意的是，如果被墙，自己想法办科学上网。 创建项目 登录 github ，点击右上角的“+”可看到新建项目的链接，或者直接访问 https://github.com/new 。创建项目如下图所示，注意图中红框部分。 创建完成之后，通过 https://github.com/fast-cache/fast-cache 即可访问到项目的主页，这是你就已经有了自己的开源项目了。 添加 ssh key ssh key 就是连接你的电脑和 github 服务器的一把钥匙，只有添加成功了才能把你本地的代码提交到 github 服务器。 如果你是 mac os 系统，运行 ssh-keygen 即可一步一步生成 ssh key ，然后运行 pbcopy 即可拷贝下来，等着粘贴。windows 系统用户，自己百度搜索 github ssh key 即可找到相关介绍文章，跟着做就行了。 在 github 个人中心的设置界面，能找到 SSH and GPS keys 菜单栏，或者直接访问 https://github.com/settings/keys 。页面中点击右侧“new ssh key”按钮即可添加 ssh key ，把刚才的内容粘贴过来添加上就行了。 下载代码 进入 github 项目主页，复制 git 地址（注意选择 use ssh ，不要 use https ），如下图 复制下来的内容应该是 git@github.com:fast-cache/fast-cache.git ，然后你选择一个合适的文件夹或目录，执行下载命令。 git clone git@github.com:fast-cache/fast-cache.git 下载完毕，进入代码目录，运行如下命令修改当前 git 的用户名和邮箱，改成和当前 github 用户名和注册邮箱一致。 cd fast-cache git config user.name 'fast-cache' git config user.email 'fast-cache@github.com' 最后，随便修改一下 README.md 文件的内容，然后提交，看能否成功？成功了就说明刚才的ssh key 生效了。 git add . git commit -m \"first update\" git push origin master 搭建开发环境 初始化 进入项目目录，然后命令行运行 npm init ，按照提示进行初始化即可。提示中的信息，能写的都写上，别随意忽略了。初始化完成之后，项目根目录下会有 package.json 的文件。 规范版本号 打开 package.json 文件，将版本号定义为 \"version\": \"0.0.1\" 。以后我们每次正式提交代码，版本号都不一样。版本号分三级，分别为： 一级，重构版本 二级，重大功能改进 三级，小升级或者 bug 修复 为何从 0.0.1 开始？因为 0.x.x 可以认为是非正式版本、测试版，而从 1.x.x 开始，就是正式发布的版本了。 规范一级目录 项目的一级目录要提前规范好，最起码一些常用的目录要提前订好留用，不能乱来。例如： src - 源代码 release - 发布结果 test - 单元测试用例 doc - 文档 example - 示例 build 构建脚本 dist 编译出来的发布版 docs 文档 examples 示例文件 src 源码 test 测试脚本 .babelrc Babel 交叉编译的配置 .eslintrc ESLint 测试配置 .gitignore 哪些文件不要上传到 GitHub .gitattributes 文件属性，如 EOL、是否为二进制等 LICENSE 授权协议 README.md 自述文件，里面至少得写： 项目的特色 各种 Badge 比如 CI 的 怎么下载安装 示例运行/使用 怎么编译（尤其 C/C++，要把编译器、要装什么工具、依赖库全部写清楚。要带版本号！） 怎么参与 circle.yml Circle CI 持续集成配置文件（当然你可能用别的 CI，名字会变。比如我那个 otfcc 使用了两个 CI：Travis 和 Appveyor，就写了两个配置） bower.json Bower 包管理器配置文件 package.json npm 包管理器配置文件 构建工具 这部分比较独立，内容也比较多，就不详细讲了，用最常用的 webpack 做一个简单演示吧。 安装插件 npm i babel-core babel-loader babel-polyfill babel-preset-es2015 babel-preset-latest webpack webpack-cli --save-dev 。 项目根目录下创建 .babelrc 文件，内容如 { \"presets\": [\"es2015\", \"latest\"], \"plugins\": [] } 项目根目录下创建 webpack.config.js 文件，内容如 module.exports = { entry: './src/index.js', output: { path: __dirname, filename: './release/bundle.js' }, module: { rules: [{ test: /\\.js?$/, exclude: /(node_modules)/, loader: 'babel-loader' }] } } 最后，修改 package.json 中的 scripts ，增加 \"release\": \"webpack\" 。然后命令行运行 npm run release ，就可生成 release 的内容。 运行示例 release 的内容已经发布出来了，还要运行起来，最简单的方式，在example创建test.html，然后引用 release 的内容。 example example 为何规范化运行，可以修改 package.json 中的 scripts ，增加 \"example\": \"http-server -p 8880\" 。然后命令行运行 npm run example ，浏览器访问 http://localhost:8880/example/test.html 。 规范 git 分支 至少要存在两个分支，master 和 dev ， dev 是开发中的代码。当然，你可以规范更多的分支，例如 next fix-bug 等，但是注意一个原则 —— 用不到的就先不要规划。 完善 README.md README.md 是开源项目的一张脸，用户的第一印象。必须包含以下内容： 产品简介（此处要突出特点，打差异化竞争） 产品安装和下载 快速使用（详细的使用文档或者二次开发文档，外链即可） 交流提问区 关于作者（放你的博客链接，和收款二维码） 最后，把以上完成的工作，都提交到 github 中。 提交代码 写代码 具体写什么代码不是本文的重点，你尽情的根据自己的项目来写自己的代码就是了。记得一定要使用编码规范的工具，例如 es-lint 等，否则经过长时间的维护，必然留坑。 写文档 & 写测试用例 注意，文档和测试用例对于一个开源产品来说非常重要！非常重要！非常重要！而且，文档和测试用例本身就是代码不可分割的一部分。 如何写测试用例，需要用到其他工具，内容也相对独立，这里就不介绍了，自己去查一查吧。再次强调，测试用例很重要！！！ 在写文档之前，还需要准备其他的工具。定位到项目目录下，npm i gitbook-cli -g 安装 gitbook ，然后创建 SUMMARY.md ，内容如下： # Summary * [项目介绍](README.md) * [使用文档](doc/use/README.md) * [使用1](doc/use/use1.md) * [使用2](doc/use/use2.md) * [二次开发](doc/dev/README.md) * [开发1](doc/dev/dev1.md) * [开发2](doc/dev/dev2.md) 其实一看这个文件内容就知道，这是一个文档的目录，你可以根据自己项目的需要重新定义这个目录。需要注意的是，第一行 * [项目介绍](README.md) 对应的是已经存在的 README.md 文件。 运行 gitbook init ，会看到各个文件都被创建了，就可以完善各个文档的内容。内容完成之后，运行 gitbook build 可以将 md 文件发布为 html 文件，默认放在 _book 文件夹。启动了 npm run example 之后，可以访问 http://127.0.0.1:8880/_book/ 查看效果。 最后，再次修改一下 README.md ，把文档的链接加上 [如何使用](./doc/use/README.md) [二次开发](./doc/dev/README.md) 提交第一版代码 首先，修改一下 .gitignore 文件，加上一行 _book ，把打包出来的文件忽略掉。然后用之前的方式提交到 github 的 master 分支，这里不再赘述了。 接下来，创建 tag 并提交，代码如下： git tag -a 'v0.0.1' -m 'first commit' git push origin v0.0.1 提交之后，下载地址就有了 ， https://github.com/fast-cache/fast-cache/releases 这里可以下载到各个版本的源码。 最后要提交到 npm 上，能让使用者通过 npm 进行安装。首先，运行 npm add user 和 npm login 来登录，根据提示将你之前注册 npm 时的账号、密码、邮箱写上就行了，问题不大。然后，在项目的根目录运行 npm publish . ，此时问题来了！！！ 运行之后报了 403 错误，刚才明明登录成功了，不可能有权限问题呀。后来一查才知道，原来 fast-cache 在 npm 中和其他项目重名了！！！没办法，只能改名，将 package.json 中的名称改为 fast-cache-npm ，然后再发布就成功了。 发布之后，通过 https://www.npmjs.com/package/fast-cache-npm 就可以访问 npm 项目主页了。 注意，为项目取名时，一定要提前把名字在 github 和 npm 搜索一下，确认没有重名才行！！！ 升级代码并提交 上述是第一次提交代码的流程，下面简述一下升级代码之后的提交流程。在代码开发阶段的步骤总结如下： 来一个 dev 分支，不要在 master 分支开发 修改 package.json 版本号，按照之前既定的版本规则修改，不能乱改 修改代码、文档和测试用例 自测 将 dev 分支提交到远程 代码开发完成之后，提交的流程如下： 再次确认版本号，因为版本号非常重要 将 dev 合并到 master ，并提交 master 到远程 创建 tag 并提交到远程 提交到 npm 合并 pr pr 即 Pull Request 的简称。 开源软件最大的特色就是允许全世界的开发者都能为其贡献代码，你这个开源项目也不例外。其他人很有可能会通过 github 的 pr 为你的项目贡献自己的代码，到时候你既得欣然接受，又不能茫然接受。 其他人贡献的 pr 可以通过 https://github.com/fast-cache/fast-cache/pulls 链接看到。对于每一个 pr ，如果你想合并，直接 merge 就好了（合并完之后，本地代码要随时更新一下）；如果你不想合并，留言说明然后关闭掉即可。 创建官网 我们通过 github pages 的机制即可免费创建项目的挂网，不用花一分钱。 创建项目 登录 github ，创建一个名为 fast-cache.github.io 的项目，名字必须是这一个！！！然后下载到本地，即 git clone xxxx 。然后，进入项目目录，新建一个 index.html ，然后随便写点什么，例如 hello world ，提交到 github 远程。 最后，访问 fast-cache.github.io ，你就能看到刚才的内容了，最简单的官网就这么出来了。做到这里，你应该知道 github pages 就是一个静态页面的服务器，上传相应的 html 就能显示。 生成官网 此前用 gitbook 将文档生成为 html 了，应该还记得。那么我们现在重新运行 gitbook build 生成 html ，然后将所有的 html 拷贝到这里来，全部提交上去，正式的官网也就出来了。 更新 README.md 记得要修改 README.md ，把官网的地址加进去。 引自：思否 作者：双越 链接：http://www.imooc.com/article/28240 来源：慕课网 本文原创发布于慕课网 ，转载请注明出处，谢谢合作 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"web前端/前端常见特效原理.html":{"url":"web前端/前端常见特效原理.html","title":"前端常见特效原理","keywords":"","body":"canvas效果 粒子系统 在粒子系统中，最长出现的概念就是向量,粒子,粒子系统。我们可以把它们各封装成一个类，但根据不同场景也可以把其中一个简化为对象直接作为另一种的一个变量。 向量是每个粒子位置的关键，他定义了粒子坐标位置，以及对坐标位置的操作的方法。粒子是最小的移动元素，它定义了自己的在坐标系中的位置，速度，生命及大小颜色等属性，当然还有绘制规则。粒子系统，在他里面会定义粒子集，并且定了他们的行动和杀死指令，控制他们的渲染 常见的粒子系统封装如下 //向量 Vector = function (x, y) { this.x = x; this.y = y; this.add=function (v) { return new Vector(this.x + v.x, this.y + v.y); } }; //粒子 Particle = function(position, velocity, life, color, size) { this.position = position; this.velocity = velocity; this.age = 0; this.life = life; this.color = color; this.size = size; }; //粒子系统 function ParticleSystem() { // Private fields var particles = new Array(); // Public fields } 常用到的方法 canvas上的方法 toDataURL(\"image/png\")：将画布内容转化为base64格式的图片,可直接赋值给image对象的src context上的方法 getImageData(0,0,canvas.width,canvas.height)：将范围内的图画数据取出，对象中包括width、height、data。data数据格式是每个像素的rgba ctx.putImageData(imgData,0,0)：将值重新付给canvas绘制 以下是方法演示 var imgData=ctx.getImageData(0,0,c.width,c.height); for (var i=0;i 利用image每格像素 我们将实现一个像素零散聚合成自己名字的动画 这个动画我们使用面向过程的思想去完成，那么他的实现过程如下 画出目标图像 筛选出需要移动的像素 动画 在这种方法下，我们主要存储的数据是有颜色的格子，因为如果存储所有的格子将极其消耗内存。我们将这些有颜色的像素格子看作是一个粒子，整个画布是粒子系统。 以下为零散聚合示例 Document body { color: aqua; } var canvas = document.getElementById('canvas') var ctx = canvas.getContext('2d') var data = [] var dataObj = [] var dataScreen = [] canvas.width = 800 canvas.height = 400 var id = 0; init() choose(0.3) animate(id, 20) //画出字样、收集数据 function init() { ctx.font = '200px Arial' ctx.fillStyle = 'aqua' ctx.textBaseline = 'top' ctx.fillText('夏炜轩', 0, canvas.height / 3) data = ctx.getImageData(0, 0, canvas.width, canvas.height).data var i = 0, n = 0; var index=0; for (var row = 0; row 0) { dataObj[index++] = { x: col, y: row, color: `rgba(${data[i]},${data[i + 1]},${data[i + 2]},${data[i + 3]})`, red: data[i], green: data[i + 1], blue: data[i + 2], randomX: Math.floor(Math.random() * canvas.height), randomY: Math.floor(Math.random() * canvas.width), } } } } } //筛选数据 function choose(op) { var n = Math.floor(dataObj.length * op); for (var i = 0; i 上面得效果比较简单，我们使用的是面向过程得思想，当项目复杂得时候我们可以使用面向对象得方式将他们抽象成类。 手动创建粒子系统 接下来我们制作粒子随鼠标移动的经典案例 动画原理：这样的动画，我们的思路为不断刷新绘制，于此同时使用另一个计时器按照时间改变粒子对象的属性，这样就可以呈现出粒子动的效果 效果原理：我们会在刚开始将满屏画满粒子，但是全部设置为透明，接近鼠标的改变颜色属性 //粒子定义 function Particle() { this.x = 0;//粒子现在的x坐标 this.y = 0; this.originX = 0;//粒子原始的x坐标 this.originY = 0; this.radius = 0;//粒子的半径 this.color = 0;//粒子颜色 this.closest = []//本粒子相离最近的五个粒子 this.active = 0;//粒子状态 this.circleActive = 0;//绘制出圆球的状态 this.draw = function (ctx) {//画出粒子球 if (!this.active) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); ctx.fillStyle = 'rgba(156,217,249,' + this.active + ')'; ctx.fill(); } this.drawLine = function (ctx) {//画出粒子间的线 if (!this.active) return; for (var i in this.closest) { ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.closest[i].x, this.closest[i].y); ctx.strokeStyle = 'rgba(156,217,249,' + this.active + ')'; ctx.stroke(); } } } 接下来我们来定义粒子系统,它包含了粒子的集合，以及他们的渲染的动作 function System(canvas) { this.width = window.innerWidth; this.height = window.innerHeight; this.largeHeader; this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.points = []; this.target = {//鼠标的位置 x: canvas.width / 2, y: canvas.height / 2 }; this.animateHeader = true; canvas.width = this.width; canvas.height = this.height; } System.prototype.initHeader=function(){};//初始化每个粒子的属性 System.prototype.initAnimation=function(){};//动画 System.prototype.addListeners=function(){};//根据鼠标的移动而产生变化 我们逐个实现，初始化每个粒子的属性 System.prototype.initHeader = function () { //初始化点线 points = this.points; width = this.width; height = this.height; //定义一定数量的点 for (var x = 0; x 接下来实现动画，动画要做的有两点，首先是动画循环渲染，可以使用计时器间隔1/60秒渲染一次，也可以使用h5的requestAnimationFrame方法。这里的定时器负责每个相应的时间渲染，他根据每个粒子的x,y属性循环渲染所有粒子。于此同时我们还应该需要一个计时器来定时改变每个粒子的x,y，当然，时间也需要足够短，让他实现渐变的效果。对于改变对象属性，我们可以使用现在存在的一些优秀动画库去实现，此处使用的是TweenLite,所以实现如下 System.prototype.initAnimation = function () { this._animate(); for (var i in this.points) { this._shiftPoint(this.points[i]); } }; System.prototype._animate = function () { var points = this.points var target = this.target if (this.animateHeader) { //清屏、渲染重复 this.ctx.clearRect(0, 0, this.width, this.height); for (var i in points) { if (Math.abs(this._getDistance(target, points[i])) 这时，动画已经可以在屏幕中显示了，我们还需要添加跟随鼠标移动的时间 System.prototype.addListeners = function () { if (!('ontouchstart' in window)) { window.addEventListener('mousemove', this._mouseMove.bind(this)); } window.addEventListener('scroll', this._scrollCheck.bind(this)); window.addEventListener('resize', this._resize.bind(this)); }; System.prototype._mouseMove = function (e) { var posx = posy = 0; if (e.pageX || e.pageY) { posx = e.pageX; posy = e.pageY; } else if (e.clientX || e.clientY) { posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop; } this.target.x = posx; this.target.y = posy; } System.prototype._scrollCheck = function () { if (document.body.scrollTop > height) this.animateHeader = false; else this.animateHeader = true; } System.prototype._resize = function () { this.width = window.innerWidth; this.height = window.innerHeight; this.canvas.width = this.width; this.canvas.height = this.height; } 至此我们完成了所有效果，现在只需要去调用这个我们定义好的类 body { width: 100%; background: #333; overflow: hidden; background-size: cover; background-position: center center; z-index: 1; } //上面的封装 var canvas = document.getElementById('canvas') var c = new System(canvas) c.initHeader() c.initAnimation() c.addListeners() 动画效果 上面我们将所有的粒子提前画到了canvas上，我们也可以在使用的时候再创建粒子。但主体思想是不变的，粒子对象定义了自己如何渲染以及更新，每个粒子被放在粒子系统中，然后利用动画去不间断渲染粒子系统中每一个粒子 var canvas = document.createElement(\"canvas\"); canvas.style.zIndex = '1'; canvas.style.position = 'absolute'; canvas.style.left = 0; canvas.style.top = 0; canvas.id = 'canvas'; document.body.appendChild(canvas); var ctx = canvas.getContext(\"2d\"); var starlist = []; function init() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; } window.onresize = init; document.body.addEventListener('mousemove', function (e) { starlist.push(new Star(e.clientX, e.clientY)); }, true) /*粒子生成*/ function random(min, max) { return Math.floor((max - min) * Math.random() + min); } function Star(x, y) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 3; this.vy = (Math.random() - 0.5) * 3; this.color = 'rgba(' + random(0, 256) + ',' + random(0, 256) + ',' + random(0, 256) + ',' + 0.5 + ')'; this.a = 1; this.draw(); } Star.prototype = { draw: function () { ctx.beginPath(); ctx.fillStyle = this.color; ctx.globalCompositeOperation = 'lighter' ctx.globalAlpha = this.a; ctx.arc(this.x, this.y, 15, 0, Math.PI * 2, false); ctx.fill(); this.updata(); }, updata() { this.x += this.vx; this.y += this.vy; this.a *= 0.98; } } /*画出粒子*/ function render() { ctx.clearRect(0, 0, canvas.width, canvas.height) starlist.forEach((item, i) => { item.draw(); if (item.a 视觉差页面 常用到的方法 { background-attachment: fixed; } /* html元素的data-*属性：为元素起别名，赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。 */ 背景固定 利用background-attachment: fixed;属性，将图片定位在此处 此属性部分移动端无法支持，iphone暂不支持,可用其他方法实现 body:before { content: \"\"; background: url(../img/beiJing3.png) no-repeat; background-size: 100%; position: fixed; top: 1rem; left: 0; bottom: 0; right: 0; z-index: -1; } 元素滚动速度差异 监听滚动事件，让元素的移动速度和滚轮的滚动速度不同从而展示出视觉差效果 some废话 $(document).ready(function () { $window = $(window); $('[data-type]').each(function () { $(this).data('offsetY', parseInt($(this).attr('data-offsetY'))); $(this).data('Xposition', $(this).attr('data-Xposition')); $(this).data('speed', $(this).attr('data-speed')); }); $('section[data-type=\"background\"]').each(function () { var $self = $(this), offsetCoords = $self.offset(), topOffset = offsetCoords.top; $(window).scroll(function () { if (($window.scrollTop() + $window.height()) > (topOffset) && ((topOffset + $self.height()) > $window.scrollTop())) { var yPos = -($window.scrollTop() / $self.data('speed')); if ($self.data('offsetY')) { yPos += $self.data('offsetY'); } var coords = '50% ' + yPos + 'px'; $self.css({ backgroundPosition: coords }); $('[data-type=\"sprite\"]', $self).each(function () { var $sprite = $(this); var yPos = -($window.scrollTop() / $sprite.data('speed')); var coords = $sprite.data('Xposition') + ' ' + (yPos + $sprite.data('offsetY')) + 'px'; $sprite.css({ backgroundPosition: coords }); }); $('[data-type=\"video\"]', $self).each(function () { var $video = $(this); var yPos = -($window.scrollTop() / $video.data('speed')); var coords = (yPos + $video.data('offsetY')) + 'px'; $video.css({ top: coords }); }); // video }; // in view }); // window scroll }); // each data-type }); // document ready css3动画 css3动画常用到keyframes创建 /*旋转照片动画定义*/ @keyframes myfirst { from { transform: rotateX(10deg); } to { transform: rotateX(50deg); } } .animate_box { z-index: 2000; position: absolute; width: 200px; left: 50px; top: 150px; height: 200px; margin: 50px auto; perspective: 2800px; /*距离屏幕距离*/ perspective-origin: -100% -100%; /*倾斜度*/ transform-style: preserve-3d; } .animate_box ul { width: 100px; height: 100px; z-index: 1500; position: relative; top: 200px; margin: 0 auto; transform-style: preserve-3d; /*子元素保留3d位置*/ } .animate_box ul li { z-index: 1000; width: 100px; height: 100px; text-align: center; line-height: 100px; font-size: 25px; color: white; position: absolute; background: rgba(225, 0, 0, 0.2); /* border: 1px solid black; */ transition: all 1s linear; overflow: hidden; } /* 上面 */ .animate_box li:nth-child(1) { transform: translateY(-50px) rotateX(90deg); } .animate_box:hover li:nth-child(1) { transform: translateY(-100px) rotateX(90deg); background: palevioletred; border: 0; border-radius: 50%; } /*后面*/ .animate_box li:nth-child(2) { transform: translateX(50px) rotateY(90deg); } .animate_box:hover li:nth-child(2) { transform: translateX(100px) rotateY(90deg); background: #92ecae; border: 0; border-radius: 50%; } /*下面*/ .animate_box li:nth-child(3) { transform: translateY(50px) rotateX(90deg); } .animate_box:hover li:nth-child(3) { transform: translateY(100px) rotateX(90deg); background: #ff916a; border: 0; border-radius: 50%; } /*左面*/ .animate_box li:nth-child(4) { transform: translateX(-50px) rotateY(90deg); } .animate_box:hover li:nth-child(4) { transform: translateX(-100px) rotateY(90deg); background: greenyellow; border: 0; border-radius: 50%; } /*右面*/ .animate_box li:nth-child(5) { transform: translateZ(-50px); } .animate_box:hover li:nth-child(5) { transform: translateZ(-100px); background: lightskyblue; border: 0; border-radius: 50%; } /*正面*/ .animate_box li:nth-child(6) { transform: translateZ(50px); } .animate_box:hover li:nth-child(6) { transform: translateZ(100px); background: #be46d8; border: 0; border-radius: 50%; } .animate_box ul:hover { transform: rotateX(9000deg) rotateY(5000deg); transition: all 100s linear; } 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"服务端/windows如何安装mysql.html":{"url":"服务端/windows如何安装mysql.html","title":"windows如何安装mysql","keywords":"","body":"在mysql下载地址下载mysql压缩包，解压到文件中（例如安装到c:\\mysql）。 进入c:\\mysql中，创建my.ini文件像文件中加入 [client] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] # 设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=C:\\\\mysql # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 # datadir=C:\\\\mysql\\\\sqldata # 允许最大连接数 max_connections=20 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 然后以管理员身份打开cmd并进入C:\\mysql\\bin中(初始化) mysqld.exe --initialize --console 执行后出现root@localhost：后面加的是原始密码 然后继续以管理员身份执行 (创建服务) .\\mysqld.exe install 启动服务 net start mysql 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"小程序/小程序开发如何使用colorUI框架.html":{"url":"小程序/小程序开发如何使用colorUI框架.html","title":"小程序开发如何使用colorUI框架","keywords":"","body":"小程序开发如何使用colorui框架 当我们进行微信开发的时候难免会为自己的样式发愁，这时就会苦于寻找、学习一些ui框架的使用。本篇文章就向大家介绍colorui框架的使用。 首先我们在github上下载到本地 colorui的github仓库 将整个库clone下来后发现里面有这些文件 在此我们只介绍在微信开发者工具中开发的使用方法 ColorUIdemo文件下 Colorui-UniApp是在vue框架中的使用及demo，在此我们不做介绍；demo文件是colorui框架中所有效果及组件的演示demo；templat则是作者配置好的一个文件，大家可以直接在里面开始新的项目（将template文件中除project.config.json、sitemap.json文件以外的copy到你的小程序文件中，让他覆盖你原有的文件，然后即可开始自己的项目）。 接下来讲不使用他创建的模板，自己创建项目引入ui内容。 打开ColorUIdemo文件下的demo文件，将里面的colorui拷贝到你创建的项目的根目录。打开app.wxss加入下面代码 @import \"colorui/main.wxss\"; @import \"colorui/icon.wxss\"; 这样就将样式引入了自己的项目中 接下来我们就可以通过添加类名的方式来修改我们自己的样式了，具体样式大家也可以在叫colorui组件库的小程序中查看属性名、及样式。 那么如何使用组件呢？ 我们继续打开ColorUIdemo文件下的demo文件，再打开pages文件，再打开component文件，会发现如何的文件夹 这就是各个组件的样式demo，我们可以直接选择某个文件夹中的wxml，然后拷贝它里面的所有文件到自己的项目中即可运行起来了。 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "},"计算机基础/os.html":{"url":"计算机基础/os.html","title":"os","keywords":"","body":"操作系统 2018 -  by 夏炜轩. All rights reserved.本站访客人数  人次document.getElementsByClassName(\"bsz-this-year\")[0].innerHTML = new Date().getFullYear(); "}}